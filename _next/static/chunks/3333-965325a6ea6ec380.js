(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[3333],{77142:function(e,r,t){e.exports=function(){const e=t(81260),r=e.ids,n=new(t(48234)),s=new(t(3158)),l=new(t(35129)),o=new e.parser;o.ast=new e.ast,o.callbacks=n.callbacks,o.ast.callbacks=s.callbacks;const i=function(e,r,t){if(r<0||r>=t)return-1;for(let t=0;t<e.length;t+=1)if(r>=e[t].beginChar&&r<e[t].beginChar+e[t].length)return t;return-1},u=function(e,r){let t=-1;if(r<e.length)for(let n=r;n<e.length;n+=1)if(null!==e[n]){t=e[n];break}return t};this.syntax=function(e,r,t,n,s,u){if(u){if("traceObject"!==u.traceObject)throw new TypeError("parser: trace argument is not a trace object");o.trace=u}const c={};c.errors=t,c.strict=!!n,c.lite=!!s,c.lines=r,c.findLine=i,c.charsLength=e.length,c.ruleCount=0;o.parse(l,"file",e,c).success||t.push({line:0,char:0,msg:"syntax analysis of input grammar failed"})},this.semantic=function(e,t,n){const s={};return s.errors=n,s.lines=t,s.findLine=i,s.charsLength=e.length,o.ast.translate(s),n.length?null:(s.rules.forEach((e=>{const t=[],n=[];let s=0;e.opcodes.forEach((e=>{e.type===r.ALT&&1===e.children.length||e.type===r.CAT&&1===e.children.length||e.type===r.REP&&1===e.min&&1===e.max?n.push(null):(n.push(s),t.push(e),s+=1)})),n.push(s),t.forEach((e=>{if(e.type===r.ALT||e.type===r.CAT)for(let r=0;r<e.children.length;r+=1)e.children[r]=u(n,e.children[r])})),e.opcodes=t})),{rules:s.rules,udts:s.udts,lineMap:s.rulesLineMap})},this.generateSource=function(e,t,n,s,l){let o,i,u,c="",a=!1,p=!1;l&&(l.typescript?(a=!0,p=!1):l.lite&&(a=!1,p=!0));let f=0,d=1/0,h=0;const y=[],g=[];let m,$=0,b=0,T=0,k=0,x=0,A=0,C=0,E=0,R=0,N=0,B=0,D=0,w=0,S=0,L=0;return n.forEach((e=>{y.push(e.lower),f+=e.opcodes.length,e.opcodes.forEach((e=>{switch(e.type){case r.ALT:$+=1;break;case r.CAT:b+=1;break;case r.RNM:T+=1;break;case r.UDT:k+=1;break;case r.REP:x+=1;break;case r.AND:A+=1;break;case r.NOT:C+=1;break;case r.BKA:D+=1;break;case r.BKN:w+=1;break;case r.BKR:B+=1;break;case r.ABG:S+=1;break;case r.AEN:L+=1;break;case r.TLS:for(E+=1,o=0;o<e.string.length;o+=1)e.string[o]<d&&(d=e.string[o]),e.string[o]>h&&(h=e.string[o]);break;case r.TBS:for(R+=1,o=0;o<e.string.length;o+=1)e.string[o]<d&&(d=e.string[o]),e.string[o]>h&&(h=e.string[o]);break;case r.TRG:N+=1,e.min<d&&(d=e.min),e.max>h&&(h=e.max);break;default:throw new Error("generateSource: unrecognized opcode")}}))})),y.sort(),s.length>0&&(s.forEach((e=>{g.push(e.lower)})),g.sort()),c+="// copyright: Copyright (c) 2024 Lowell D. Thomas, all rights reserved<br>\n",c+="//   license: BSD-2-Clause (https://opensource.org/licenses/BSD-2-Clause)<br>\n",c+="//\n",c+="// Generated by apg-js, Version 4.4.0 [apg-js](https://github.com/ldthomas/apg-js)\n",l?l.funcName?c+=`const ${l.funcName} = function grammar(){\n`:c+=a?"export function grammar(){\n":p?"export default function grammar(){\n":"module.exports = function grammar(){\n":c+="module.exports = function grammar(){\n",c+="  // ```\n",c+="  // SUMMARY\n",c+=`  //      rules = ${n.length}\n`,c+=`  //       udts = ${s.length}\n`,c+=`  //    opcodes = ${f}\n`,c+="  //        ---   ABNF original opcodes\n",c+=`  //        ALT = ${$}\n`,c+=`  //        CAT = ${b}\n`,c+=`  //        REP = ${x}\n`,c+=`  //        RNM = ${T}\n`,c+=`  //        TLS = ${E}\n`,c+=`  //        TBS = ${R}\n`,c+=`  //        TRG = ${N}\n`,c+="  //        ---   SABNF superset opcodes\n",c+=`  //        UDT = ${k}\n`,c+=`  //        AND = ${A}\n`,c+=`  //        NOT = ${C}\n`,p||(c+=`  //        BKA = ${D}\n`,c+=`  //        BKN = ${w}\n`,c+=`  //        BKR = ${B}\n`,c+=`  //        ABG = ${S}\n`,c+=`  //        AEN = ${L}\n`),c+="  // characters = [",c+=E+R+N===0?" none defined ]":`${d} - ${h}]`,k>0&&(c+=" + user defined"),c+="\n",c+="  // ```\n",c+="  /* OBJECT IDENTIFIER (for internal parser use) */\n",c+="  this.grammarObject = 'grammarObject';\n",c+="\n",c+="  /* RULES */\n",c+="  this.rules = [];\n",n.forEach(((e,r)=>{let t="  this.rules[";t+=r,t+="] = { name: '",t+=e.name,t+="', lower: '",t+=e.lower,t+="', index: ",t+=e.index,t+=", isBkr: ",t+=e.isBkr,t+=" };\n",c+=t})),c+="\n",c+="  /* UDTS */\n",c+="  this.udts = [];\n",s.length>0&&s.forEach(((e,r)=>{let t="  this.udts[";t+=r,t+="] = { name: '",t+=e.name,t+="', lower: '",t+=e.lower,t+="', index: ",t+=e.index,t+=", empty: ",t+=e.empty,t+=", isBkr: ",t+=e.isBkr,t+=" };\n",c+=t})),c+="\n",c+="  /* OPCODES */\n",n.forEach(((e,t)=>{t>0&&(c+="\n"),c+=`  /* ${e.name} */\n`,c+=`  this.rules[${t}].opcodes = [];\n`,e.opcodes.forEach(((e,l)=>{let o;switch(e.type){case r.ALT:c+=`  this.rules[${t}].opcodes[${l}] = { type: ${e.type}, children: [${e.children.toString()}] };// ALT\n`;break;case r.CAT:c+=`  this.rules[${t}].opcodes[${l}] = { type: ${e.type}, children: [${e.children.toString()}] };// CAT\n`;break;case r.RNM:c+=`  this.rules[${t}].opcodes[${l}] = { type: ${e.type}, index: ${e.index} };// RNM(${n[e.index].name})\n`;break;case r.BKR:e.index>=n.length?(i=s[e.index-n.length].name,u=s[e.index-n.length].lower):(i=n[e.index].name,u=n[e.index].lower),o="%i",e.bkrCase===r.BKR_MODE_CS&&(o="%s"),e.bkrMode===r.BKR_MODE_UM?o+="%u":o+="%p",i=o+i,c+=`  this.rules[${t}].opcodes[${l}] = { type: ${e.type}, index: ${e.index}, lower: '${u}', bkrCase: ${e.bkrCase}, bkrMode: ${e.bkrMode} };// BKR(\\${i})\n`;break;case r.UDT:c+=`  this.rules[${t}].opcodes[${l}] = { type: ${e.type}, empty: ${e.empty}, index: ${e.index} };// UDT(${s[e.index].name})\n`;break;case r.REP:c+=`  this.rules[${t}].opcodes[${l}] = { type: ${e.type}, min: ${e.min}, max: ${e.max} };// REP\n`;break;case r.AND:c+=`  this.rules[${t}].opcodes[${l}] = { type: ${e.type} };// AND\n`;break;case r.NOT:c+=`  this.rules[${t}].opcodes[${l}] = { type: ${e.type} };// NOT\n`;break;case r.ABG:c+=`  this.rules[${t}].opcodes[${l}] = { type: ${e.type} };// ABG(%^)\n`;break;case r.AEN:c+=`  this.rules[${t}].opcodes[${l}] = { type: ${e.type} };// AEN(%$)\n`;break;case r.BKA:c+=`  this.rules[${t}].opcodes[${l}] = { type: ${e.type} };// BKA\n`;break;case r.BKN:c+=`  this.rules[${t}].opcodes[${l}] = { type: ${e.type} };// BKN\n`;break;case r.TLS:c+=`  this.rules[${t}].opcodes[${l}] = { type: ${e.type}, string: [${e.string.toString()}] };// TLS\n`;break;case r.TBS:c+=`  this.rules[${t}].opcodes[${l}] = { type: ${e.type}, string: [${e.string.toString()}] };// TBS\n`;break;case r.TRG:c+=`  this.rules[${t}].opcodes[${l}] = { type: ${e.type}, min: ${e.min}, max: ${e.max} };// TRG\n`;break;default:throw new Error("parser.js: ~143: unrecognized opcode")}}))})),c+="\n",c+="  // The `toString()` function will display the original grammar file(s) that produced these opcodes.\n",c+="  this.toString = function toString(){\n",c+='    let str = "";\n',t.forEach((r=>{const t=r.beginChar+r.length;m="",c+='    str += "';for(let n=r.beginChar;n<t;n+=1){switch(e[n]){case 9:m=" ";break;case 10:m="\\n";break;case 13:m="\\r";break;case 34:m='\\"';break;case 92:m="\\\\";break;default:m=String.fromCharCode(e[n])}c+=m}c+='";\n'})),c+="    return str;\n",c+="  }\n",c+="}\n",c},this.generateObject=function(e,r,t){const n={},s=[],l=[],o=e.slice(0);return n.grammarObject="grammarObject",r.forEach((e=>{s.push(e.lower)})),s.sort(),t.length>0&&(t.forEach((e=>{l.push(e.lower)})),l.sort()),n.callbacks=[],s.forEach((e=>{n.callbacks[e]=!1})),t.length>0&&l.forEach((e=>{n.callbacks[e]=!1})),n.rules=r,n.udts=t,n.toString=function(){return o},n}}},29933:function(e,r,t){e.exports=function(){const e=t(62086);let r=null;function n(e){return!(e.left||e.nested||e.right||e.cyclic)&&e.empty}function s(e){return!!(e.left||e.nested||e.right||e.cyclic)}function l(e,r,t,l){let i=0;const u=r[t],c=u.children.length,a=[];for(i=0;i<c;i+=1)a.push(e.attrGen());for(i=0;i<c;i+=1)o(e,r,u.children[i],a[i]);l.left=function(e,r){for(let t=0;t<r;t+=1){if(e[t].left)return!0;if(!e[t].empty)return!1}return!1}(a,c),l.right=function(e,r){for(let t=r-1;t>=0;t-=1){if(e[t].right)return!0;if(!e[t].empty)return!1}return!1}(a,c),l.nested=function(e,r){let t=0,l=0,o=0;for(t=0;t<r;t+=1)if(e[t].nested)return!0;for(t=0;t<r;t+=1)if(e[t].right&&!e[t].leaf)for(l=t+1;l<r;l+=1)if(!n(e[l]))return!0;for(t=r-1;t>=0;t-=1)if(e[t].left&&!e[t].leaf)for(l=t-1;l>=0;l-=1)if(!n(e[l]))return!0;for(t=0;t<r;t+=1)if(!e[t].empty&&!s(e[t]))for(l=t+1;l<r;l+=1)if(s(e[l]))for(o=l+1;o<r;o+=1)if(!e[o].empty&&!s(e[o]))return!0;return!1}(a,c),l.empty=function(e,r){for(let t=0;t<r;t+=1)if(!e[t].empty)return!1;return!0}(a,c),l.finite=function(e,r){for(let t=0;t<r;t+=1)if(!e[t].finite)return!1;return!0}(a,c),l.cyclic=function(e,r){for(let t=0;t<r;t+=1)if(!e[t].cyclic)return!1;return!0}(a,c)}function o(r,t,n,s){r.attrInit(s);const u=t[n];switch(u.type){case e.ALT:!function(e,r,t,n){let s=0;const l=r[t],i=l.children.length,u=[];for(s=0;s<i;s+=1)u.push(e.attrGen());for(s=0;s<i;s+=1)o(e,r,l.children[s],u[s]);for(n.left=!1,n.right=!1,n.nested=!1,n.empty=!1,n.finite=!1,n.cyclic=!1,s=0;s<i;s+=1)u[s].left&&(n.left=!0),u[s].nested&&(n.nested=!0),u[s].right&&(n.right=!0),u[s].empty&&(n.empty=!0),u[s].finite&&(n.finite=!0),u[s].cyclic&&(n.cyclic=!0)}(r,t,n,s);break;case e.CAT:l(r,t,n,s);break;case e.REP:o(r,t,n+1,s),0===u.min&&(s.empty=!0,s.finite=!0);break;case e.RNM:i(r,t[n].index,s);break;case e.BKR:!function(e,r,t,n){const s=r[t];s.index>=e.ruleCount?(n.empty=e.udts[s.index-e.ruleCount].empty,n.finite=!0):(i(e,s.index,n),n.left=!1,n.nested=!1,n.right=!1,n.cyclic=!1)}(r,t,n,s);break;case e.AND:case e.NOT:case e.BKA:case e.BKN:o(r,t,n+1,s),s.empty=!0;break;case e.TLS:s.empty=!t[n].string.length,s.finite=!0,s.cyclic=!1;break;case e.TBS:case e.TRG:s.empty=!1,s.finite=!0,s.cyclic=!1;break;case e.UDT:s.empty=u.empty,s.finite=!0,s.cyclic=!1;break;case e.ABG:case e.AEN:s.empty=!0,s.finite=!0,s.cyclic=!1;break;default:throw new Error(`unknown opcode type: ${u}`)}}function i(e,r,t){const n=e.attrsWorking[r];n.isComplete?e.attrCopy(t,n):n.isOpen?r===e.startRule?r===e.startRule&&(t.left=!0,t.right=!0,t.cyclic=!0,t.leaf=!0):t.finite=!0:(n.isOpen=!0,o(e,n.rule.opcodes,0,t),n.left=t.left,n.right=t.right,n.nested=t.nested,n.empty=t.empty,n.finite=t.finite,n.cyclic=t.cyclic,n.leaf=!1,n.isOpen=!1,n.isComplete=!0)}const u=e=>e?"t":"f",c=e=>e?"e":"f",a=(t,n,s,l)=>{let o=`${t}:${n}:`;return o+=`${c(s.left)} `,o+=`${u(s.nested)} `,o+=`${u(s.right)} `,o+=`${c(s.cyclic)} `,o+=(s.finite?"t":"e")+" ",o+=`${u(s.empty)}:`,o+=`${r.typeToString(l.recursiveType)}:`,o+=l.recursiveType===e.ATTR_MR?l.groupNumber:"-",o+=`:${s.rule.name}\n`,o},p=()=>{let e="LEGEND - t=true, f=false, e=error\n";return e+="sequence:rule index:left nested right cyclic finite empty:type:group number:rule name\n","LEGEND - t=true, f=false, e=error\nsequence:rule index:left nested right cyclic finite empty:type:group number:rule name\n"},f=e=>{let t=0,n=0,s=null,l=null,o="",{ruleIndexes:i}=r;for(97===e?i=r.ruleAlphaIndexes:116===e&&(i=r.ruleTypeIndexes),t=0;t<r.ruleCount;t+=1)n=i[t],s=r.attrs[n],l=r.ruleDeps[n],o+=a(t,n,s,l);return o};return{ruleAttributes:e=>{r=e;let t=0,n=0;const s=r.attrGen();for(t=0;t<r.ruleCount;t+=1){for(n=0;n<r.ruleCount;n+=1)r.attrInit(r.attrsWorking[n]);r.startRule=t,i(r,t,s),r.attrCopy(r.attrs[t],r.attrsWorking[t])}r.attributesComplete=!0;let l=null;for(t=0;t<r.ruleCount;t+=1)if(l=r.attrs[t],l.left||!l.finite||l.cyclic){const e=r.attrGen(l.rule);r.attrCopy(e,l),r.attrsErrors.push(e),r.attrsErrorCount+=1}},showAttributes:(e="index")=>{if(!r.attributesComplete)throw new Error("rule-attributes.js:showAttributes: attributes not available");let t="";const n="RULE ATTRIBUTES\n";return 97===e.charCodeAt(0)?(t+="alphabetical by rule name\n",t+=n,t+=p(),t+=f(97)):116===e.charCodeAt(0)?(t+="ordered by rule type\n",t+=n,t+=p(),t+=f(116)):(t+="ordered by rule index\n",t+=n,t+=p(),t+=f()),t},showAttributeErrors:()=>{let e=null,t=null,n="";if(n+="RULE ATTRIBUTES WITH ERRORS\n",n+=p(),r.attrsErrorCount)for(let s=0;s<r.attrsErrorCount;s+=1)e=r.attrsErrors[s],t=r.ruleDeps[e.rule.index],n+=a(s,e.rule.index,e,t);else n+="<none>\n";return n}}}()},6462:function(e,r,t){e.exports=(()=>{const e=t(62086);let r=null;const n=(r,t,s,l)=>{let o=0,i=0;const u=t[s];l[s]=!0;const c=u.rule.opcodes;for(o=0;o<c.length;o+=1){const s=c[o];if(s.type===e.RNM)for(u.refersTo[s.index]=!0,l[s.index]||n(r,t,s.index,l),i=0;i<r;i+=1)t[s.index].refersTo[i]&&(u.refersTo[i]=!0);else s.type===e.UDT?u.refersToUdt[s.index]=!0:s.type===e.BKR&&(s.index<r?(u.refersTo[s.index]=!0,l[s.index]||n(r,t,s.index,l)):u.refersToUdt[r-s.index]=!0)}},s=(e=null)=>{let t=0,n=0,s=0,l=0;const o=r.ruleCount-1,i=r.udtCount-1;let u="",c="";const a="=> ";let p=!1,f=null,{ruleIndexes:d}=r,{udtIndexes:h}=r;for(97===e?(d=r.ruleAlphaIndexes,h=r.udtAlphaIndexes):116===e&&(d=r.ruleTypeIndexes,h=r.udtAlphaIndexes),t=0;t<r.ruleCount;t+=1){for(f=r.ruleDeps[d[t]],c=`${d[t]}:${r.typeToString(f.recursiveType)}:`,r.isMutuallyRecursive&&(c+=f.groupNumber>-1?f.groupNumber:"-",c+=":"),c+=" ",u+=`${c+r.rules[d[t]].name}\n`,p=!0,s=0,l=u.length,u+=c,n=0;n<r.ruleCount;n+=1)f.refersTo[d[n]]&&(p?(u+=a,p=!1,u+=r.ruleDeps[d[n]].rule.name):u+=`, ${r.ruleDeps[d[n]].rule.name}`,s+=1),u.length-l>100&&n!==o&&(u+=`\n${c}${a}`,l=u.length);if(r.udtCount)for(n=0;n<r.udtCount;n+=1)f.refersToUdt[h[n]]&&(p?(u+=a,p=!1,u+=r.udts[h[n]].name):u+=`, ${r.udts[h[n]].name}`,s+=1),u.length-l>100&&n!==i&&(u+=`\n${c}${a}`,l=u.length);for(0===s&&(u+="=> <none>\n"),!1===p&&(u+="\n"),p=!0,s=0,l=u.length,u+=c,n=0;n<r.ruleCount;n+=1)f.referencedBy[d[n]]&&(p?(u+="<= ",p=!1,u+=r.ruleDeps[d[n]].rule.name):u+=`, ${r.ruleDeps[d[n]].rule.name}`,s+=1),u.length-l>100&&n!==o&&(u+=`\n${c}${a}`,l=u.length);0===s&&(u+="<= <none>\n"),!1===p&&(u+="\n"),u+="\n"}return u};return{ruleDependencies:t=>{r=t;let s=0,l=0,o=0,i=null,u=null,c=!1;r.dependenciesComplete=!1;const a=r.falseArray(r.ruleCount);for(s=0;s<r.ruleCount;s+=1)r.falsifyArray(a),n(r.ruleCount,r.ruleDeps,s,a);for(s=0;s<r.ruleCount;s+=1)for(l=0;l<r.ruleCount;l+=1)s!==l&&r.ruleDeps[l].refersTo[s]&&(r.ruleDeps[s].referencedBy[l]=!0);for(s=0;s<r.ruleCount;s+=1)r.ruleDeps[s].recursiveType=e.ATTR_N,r.ruleDeps[s].refersTo[s]&&(r.ruleDeps[s].recursiveType=e.ATTR_R);for(o=-1,s=0;s<r.ruleCount;s+=1)if(i=r.ruleDeps[s],i.recursiveType===e.ATTR_R)for(c=!0,l=0;l<r.ruleCount;l+=1)s!==l&&(u=r.ruleDeps[l],u.recursiveType===e.ATTR_R&&i.refersTo[l]&&u.refersTo[s]&&(c&&(o+=1,i.recursiveType=e.ATTR_MR,i.groupNumber=o,c=!1),u.recursiveType=e.ATTR_MR,u.groupNumber=o));r.isMutuallyRecursive=o>-1,r.ruleAlphaIndexes.sort(r.compRulesAlpha),r.ruleTypeIndexes.sort(r.compRulesAlpha),r.ruleTypeIndexes.sort(r.compRulesType),r.isMutuallyRecursive&&r.ruleTypeIndexes.sort(r.compRulesGroup),r.udtCount&&r.udtAlphaIndexes.sort(r.compUdtsAlpha),r.dependenciesComplete=!0},showRuleDependencies:(e="index")=>{let t="RULE DEPENDENCIES(index:type:[group number:])\n";return t+="=> refers to rule names\n",t+="<= referenced by rule names\n",r.dependenciesComplete?(97===e.charCodeAt(0)?(t+="alphabetical by rule name\n",t+=s(97)):116===e.charCodeAt(0)?(t+="ordered by rule type\n",t+=s(116)):(t+="ordered by rule index\n",t+=s(null)),t):t}}})()}}]);
//# sourceMappingURL=3333-965325a6ea6ec380.js.map