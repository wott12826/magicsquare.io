"use strict";(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[1495],{71703:function(t,e,s){s.d(e,{Z:function(){return lt}});var i=s(78348),r=s(17486),n=s(11899),a=s(38149),c=s(98912),o=s(11632),h=s(78186),p=s(25788),d=s.n(p);const u="error",l="wc@2:universal_provider:",m="https://rpc.walletconnect.org/v1/",v="generic",f=`${m}bundler`,P="default_chain_changed";var g=Object.defineProperty,w=Object.defineProperties,C=Object.getOwnPropertyDescriptors,I=Object.getOwnPropertySymbols,b=Object.prototype.hasOwnProperty,$=Object.prototype.propertyIsEnumerable,H=(t,e,s)=>e in t?g(t,e,{enumerable:!0,configurable:!0,writable:!0,value:s}):t[e]=s,q=(t,e)=>{for(var s in e||(e={}))b.call(e,s)&&H(t,s,e[s]);if(I)for(var s of I(e))$.call(e,s)&&H(t,s,e[s]);return t},y=(t,e)=>w(t,C(e));function E(t,e,s){var i;const n=(0,r.DQe)(t);return(null==(i=e.rpcMap)?void 0:i[n.reference])||`${m}?chainId=${n.namespace}:${n.reference}&projectId=${s}`}function O(t){return t.includes(":")?t.split(":")[1]:t}function S(t){return t.map((t=>`${t.split(":")[0]}:${t.split(":")[1]}`))}function N(t={},e={}){const s=j(t),i=j(e);return(0,a.merge)(s,i)}function j(t){var e,s,i,n;const a={};if(!(0,r.L5o)(t))return a;for(const[c,o]of Object.entries(t)){const t=(0,r.gpE)(c)?[c]:o.chains,h=o.methods||[],p=o.events||[],d=o.rpcMap||{},u=(0,r.Maj)(c);a[u]=y(q(q({},a[u]),o),{chains:(0,r.eGA)(t,null==(e=a[u])?void 0:e.chains),methods:(0,r.eGA)(h,null==(s=a[u])?void 0:s.methods),events:(0,r.eGA)(p,null==(i=a[u])?void 0:i.events),rpcMap:q(q({},d),null==(n=a[u])?void 0:n.rpcMap)})}return a}function A(t){return t.includes(":")?t.split(":")[2]:t}function D(t){const e={};for(const[s,i]of Object.entries(t)){const t=i.methods||[],n=i.events||[],a=i.accounts||[],c=(0,r.gpE)(s)?[s]:i.chains?i.chains:S(i.accounts);e[s]={chains:c,methods:t,events:n,accounts:a}}return e}function R(t){return"number"==typeof t?t:t.includes("0x")?parseInt(t,16):(t=t.includes(":")?t.split(":")[1]:t,isNaN(Number(t))?t:Number(t))}const k={},_=t=>k[t],M=(t,e)=>{k[t]=e};class U{constructor(t){this.name="polkadot",this.namespace=t.namespace,this.events=_("events"),this.client=_("client"),this.chainId=this.getDefaultChain(),this.httpProviders=this.createHttpProviders()}updateNamespace(t){this.namespace=Object.assign(this.namespace,t)}requestAccounts(){return this.getAccounts()}getDefaultChain(){if(this.chainId)return this.chainId;if(this.namespace.defaultChain)return this.namespace.defaultChain;const t=this.namespace.chains[0];if(!t)throw new Error("ChainId not found");return t.split(":")[1]}request(t){return this.namespace.methods.includes(t.request.method)?this.client.request(t):this.getHttpProvider().request(t.request)}setDefaultChain(t,e){this.httpProviders[t]||this.setHttpProvider(t,e),this.chainId=t,this.events.emit(P,`${this.name}:${t}`)}getAccounts(){const t=this.namespace.accounts;return t&&t.filter((t=>t.split(":")[1]===this.chainId.toString())).map((t=>t.split(":")[2]))||[]}createHttpProviders(){const t={};return this.namespace.chains.forEach((e=>{var s;const i=O(e);t[i]=this.createHttpProvider(i,null==(s=this.namespace.rpcMap)?void 0:s[e])})),t}getHttpProvider(){const t=`${this.name}:${this.chainId}`,e=this.httpProviders[t];if(typeof e>"u")throw new Error(`JSON-RPC provider for ${t} not found`);return e}setHttpProvider(t,e){const s=this.createHttpProvider(t,e);s&&(this.httpProviders[t]=s)}createHttpProvider(t,e){const s=e||E(t,this.namespace,this.client.core.projectId);if(!s)throw new Error(`No RPC url provided for chainId: ${t}`);return new o.r(new c.Z(s,_("disableProviderPing")))}}var J=Object.defineProperty,x=Object.defineProperties,z=Object.getOwnPropertyDescriptors,Z=Object.getOwnPropertySymbols,F=Object.prototype.hasOwnProperty,T=Object.prototype.propertyIsEnumerable,L=(t,e,s)=>e in t?J(t,e,{enumerable:!0,configurable:!0,writable:!0,value:s}):t[e]=s,G=(t,e)=>{for(var s in e||(e={}))F.call(e,s)&&L(t,s,e[s]);if(Z)for(var s of Z(e))T.call(e,s)&&L(t,s,e[s]);return t},B=(t,e)=>x(t,z(e));class Q{constructor(t){this.name="eip155",this.namespace=t.namespace,this.events=_("events"),this.client=_("client"),this.httpProviders=this.createHttpProviders(),this.chainId=parseInt(this.getDefaultChain())}async request(t){switch(t.request.method){case"eth_requestAccounts":case"eth_accounts":return this.getAccounts();case"wallet_switchEthereumChain":return await this.handleSwitchChain(t);case"eth_chainId":return parseInt(this.getDefaultChain());case"wallet_getCapabilities":return await this.getCapabilities(t);case"wallet_getCallsStatus":return await this.getCallStatus(t)}return this.namespace.methods.includes(t.request.method)?await this.client.request(t):this.getHttpProvider().request(t.request)}updateNamespace(t){this.namespace=Object.assign(this.namespace,t)}setDefaultChain(t,e){this.httpProviders[t]||this.setHttpProvider(parseInt(t),e),this.chainId=parseInt(t),this.events.emit(P,`${this.name}:${t}`)}requestAccounts(){return this.getAccounts()}getDefaultChain(){if(this.chainId)return this.chainId.toString();if(this.namespace.defaultChain)return this.namespace.defaultChain;const t=this.namespace.chains[0];if(!t)throw new Error("ChainId not found");return t.split(":")[1]}createHttpProvider(t,e){const s=e||E(`${this.name}:${t}`,this.namespace,this.client.core.projectId);if(!s)throw new Error(`No RPC url provided for chainId: ${t}`);return new o.r(new c.k(s,_("disableProviderPing")))}setHttpProvider(t,e){const s=this.createHttpProvider(t,e);s&&(this.httpProviders[t]=s)}createHttpProviders(){const t={};return this.namespace.chains.forEach((e=>{var s;const i=parseInt(O(e));t[i]=this.createHttpProvider(i,null==(s=this.namespace.rpcMap)?void 0:s[e])})),t}getAccounts(){const t=this.namespace.accounts;return t?[...new Set(t.filter((t=>t.split(":")[1]===this.chainId.toString())).map((t=>t.split(":")[2])))]:[]}getHttpProvider(){const t=this.chainId,e=this.httpProviders[t];if(typeof e>"u")throw new Error(`JSON-RPC provider for ${t} not found`);return e}async handleSwitchChain(t){var e,s;let i=t.request.params?null==(e=t.request.params[0])?void 0:e.chainId:"0x0";i=i.startsWith("0x")?i:`0x${i}`;const r=parseInt(i,16);if(this.isChainApproved(r))this.setDefaultChain(`${r}`);else{if(!this.namespace.methods.includes("wallet_switchEthereumChain"))throw new Error(`Failed to switch to chain 'eip155:${r}'. The chain is not approved or the wallet does not support 'wallet_switchEthereumChain' method.`);await this.client.request({topic:t.topic,request:{method:t.request.method,params:[{chainId:i}]},chainId:null==(s=this.namespace.chains)?void 0:s[0]}),this.setDefaultChain(`${r}`)}return null}isChainApproved(t){return this.namespace.chains.includes(`${this.name}:${t}`)}async getCapabilities(t){var e,s,i;const r=null==(s=null==(e=t.request)?void 0:e.params)?void 0:s[0];if(!r)throw new Error("Missing address parameter in `wallet_getCapabilities` request");const n=this.client.session.get(t.topic),a=(null==(i=n?.sessionProperties)?void 0:i.capabilities)||{};if(null!=a&&a[r])return a?.[r];const c=await this.client.request(t);try{await this.client.session.update(t.topic,{sessionProperties:B(G({},n.sessionProperties||{}),{capabilities:B(G({},a||{}),{[r]:c})})})}catch(t){console.warn("Failed to update session with capabilities",t)}return c}async getCallStatus(t){var e,s;const i=this.client.session.get(t.topic),r=null==(e=i.sessionProperties)?void 0:e.bundler_name;if(r){const e=this.getBundlerUrl(t.chainId,r);try{return await this.getUserOperationReceipt(e,t)}catch(t){console.warn("Failed to fetch call status from bundler",t,e)}}const n=null==(s=i.sessionProperties)?void 0:s.bundler_url;if(n)try{return await this.getUserOperationReceipt(n,t)}catch(t){console.warn("Failed to fetch call status from custom bundler",t,n)}if(this.namespace.methods.includes(t.request.method))return await this.client.request(t);throw new Error("Fetching call status not approved by the wallet.")}async getUserOperationReceipt(t,e){var s;const i=new URL(t),r=await fetch(i,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify((0,h.formatJsonRpcRequest)("eth_getUserOperationReceipt",[null==(s=e.request.params)?void 0:s[0]]))});if(!r.ok)throw new Error(`Failed to fetch user operation receipt - ${r.status}`);return await r.json()}getBundlerUrl(t,e){return`${f}?projectId=${this.client.core.projectId}&chainId=${t}&bundler=${e}`}}class W{constructor(t){this.name="solana",this.namespace=t.namespace,this.events=_("events"),this.client=_("client"),this.chainId=this.getDefaultChain(),this.httpProviders=this.createHttpProviders()}updateNamespace(t){this.namespace=Object.assign(this.namespace,t)}requestAccounts(){return this.getAccounts()}request(t){return this.namespace.methods.includes(t.request.method)?this.client.request(t):this.getHttpProvider().request(t.request)}setDefaultChain(t,e){this.httpProviders[t]||this.setHttpProvider(t,e),this.chainId=t,this.events.emit(P,`${this.name}:${t}`)}getDefaultChain(){if(this.chainId)return this.chainId;if(this.namespace.defaultChain)return this.namespace.defaultChain;const t=this.namespace.chains[0];if(!t)throw new Error("ChainId not found");return t.split(":")[1]}getAccounts(){const t=this.namespace.accounts;return t?[...new Set(t.filter((t=>t.split(":")[1]===this.chainId.toString())).map((t=>t.split(":")[2])))]:[]}createHttpProviders(){const t={};return this.namespace.chains.forEach((e=>{var s;const i=O(e);t[i]=this.createHttpProvider(i,null==(s=this.namespace.rpcMap)?void 0:s[e])})),t}getHttpProvider(){const t=`${this.name}:${this.chainId}`,e=this.httpProviders[t];if(typeof e>"u")throw new Error(`JSON-RPC provider for ${t} not found`);return e}setHttpProvider(t,e){const s=this.createHttpProvider(t,e);s&&(this.httpProviders[t]=s)}createHttpProvider(t,e){const s=e||E(t,this.namespace,this.client.core.projectId);if(!s)throw new Error(`No RPC url provided for chainId: ${t}`);return new o.r(new c.Z(s,_("disableProviderPing")))}}class K{constructor(t){this.name="cosmos",this.namespace=t.namespace,this.events=_("events"),this.client=_("client"),this.chainId=this.getDefaultChain(),this.httpProviders=this.createHttpProviders()}updateNamespace(t){this.namespace=Object.assign(this.namespace,t)}requestAccounts(){return this.getAccounts()}getDefaultChain(){if(this.chainId)return this.chainId;if(this.namespace.defaultChain)return this.namespace.defaultChain;const t=this.namespace.chains[0];if(!t)throw new Error("ChainId not found");return t.split(":")[1]}request(t){return this.namespace.methods.includes(t.request.method)?this.client.request(t):this.getHttpProvider().request(t.request)}setDefaultChain(t,e){this.httpProviders[t]||this.setHttpProvider(t,e),this.chainId=t,this.events.emit(P,`${this.name}:${this.chainId}`)}getAccounts(){const t=this.namespace.accounts;return t?[...new Set(t.filter((t=>t.split(":")[1]===this.chainId.toString())).map((t=>t.split(":")[2])))]:[]}createHttpProviders(){const t={};return this.namespace.chains.forEach((e=>{var s;const i=O(e);t[i]=this.createHttpProvider(i,null==(s=this.namespace.rpcMap)?void 0:s[e])})),t}getHttpProvider(){const t=`${this.name}:${this.chainId}`,e=this.httpProviders[t];if(typeof e>"u")throw new Error(`JSON-RPC provider for ${t} not found`);return e}setHttpProvider(t,e){const s=this.createHttpProvider(t,e);s&&(this.httpProviders[t]=s)}createHttpProvider(t,e){const s=e||E(t,this.namespace,this.client.core.projectId);if(!s)throw new Error(`No RPC url provided for chainId: ${t}`);return new o.r(new c.Z(s,_("disableProviderPing")))}}class V{constructor(t){this.name="algorand",this.namespace=t.namespace,this.events=_("events"),this.client=_("client"),this.chainId=this.getDefaultChain(),this.httpProviders=this.createHttpProviders()}updateNamespace(t){this.namespace=Object.assign(this.namespace,t)}requestAccounts(){return this.getAccounts()}request(t){return this.namespace.methods.includes(t.request.method)?this.client.request(t):this.getHttpProvider().request(t.request)}setDefaultChain(t,e){if(!this.httpProviders[t]){const s=e||E(`${this.name}:${t}`,this.namespace,this.client.core.projectId);if(!s)throw new Error(`No RPC url provided for chainId: ${t}`);this.setHttpProvider(t,s)}this.chainId=t,this.events.emit(P,`${this.name}:${this.chainId}`)}getDefaultChain(){if(this.chainId)return this.chainId;if(this.namespace.defaultChain)return this.namespace.defaultChain;const t=this.namespace.chains[0];if(!t)throw new Error("ChainId not found");return t.split(":")[1]}getAccounts(){const t=this.namespace.accounts;return t?[...new Set(t.filter((t=>t.split(":")[1]===this.chainId.toString())).map((t=>t.split(":")[2])))]:[]}createHttpProviders(){const t={};return this.namespace.chains.forEach((e=>{var s;t[e]=this.createHttpProvider(e,null==(s=this.namespace.rpcMap)?void 0:s[e])})),t}getHttpProvider(){const t=`${this.name}:${this.chainId}`,e=this.httpProviders[t];if(typeof e>"u")throw new Error(`JSON-RPC provider for ${t} not found`);return e}setHttpProvider(t,e){const s=this.createHttpProvider(t,e);s&&(this.httpProviders[t]=s)}createHttpProvider(t,e){const s=e||E(t,this.namespace,this.client.core.projectId);return typeof s>"u"?void 0:new o.r(new c.Z(s,_("disableProviderPing")))}}class X{constructor(t){this.name="cip34",this.namespace=t.namespace,this.events=_("events"),this.client=_("client"),this.chainId=this.getDefaultChain(),this.httpProviders=this.createHttpProviders()}updateNamespace(t){this.namespace=Object.assign(this.namespace,t)}requestAccounts(){return this.getAccounts()}getDefaultChain(){if(this.chainId)return this.chainId;if(this.namespace.defaultChain)return this.namespace.defaultChain;const t=this.namespace.chains[0];if(!t)throw new Error("ChainId not found");return t.split(":")[1]}request(t){return this.namespace.methods.includes(t.request.method)?this.client.request(t):this.getHttpProvider().request(t.request)}setDefaultChain(t,e){this.httpProviders[t]||this.setHttpProvider(t,e),this.chainId=t,this.events.emit(P,`${this.name}:${this.chainId}`)}getAccounts(){const t=this.namespace.accounts;return t?[...new Set(t.filter((t=>t.split(":")[1]===this.chainId.toString())).map((t=>t.split(":")[2])))]:[]}createHttpProviders(){const t={};return this.namespace.chains.forEach((e=>{const s=this.getCardanoRPCUrl(e),i=O(e);t[i]=this.createHttpProvider(i,s)})),t}getHttpProvider(){const t=`${this.name}:${this.chainId}`,e=this.httpProviders[t];if(typeof e>"u")throw new Error(`JSON-RPC provider for ${t} not found`);return e}getCardanoRPCUrl(t){const e=this.namespace.rpcMap;if(e)return e[t]}setHttpProvider(t,e){const s=this.createHttpProvider(t,e);s&&(this.httpProviders[t]=s)}createHttpProvider(t,e){const s=e||this.getCardanoRPCUrl(t);if(!s)throw new Error(`No RPC url provided for chainId: ${t}`);return new o.r(new c.Z(s,_("disableProviderPing")))}}class Y{constructor(t){this.name="elrond",this.namespace=t.namespace,this.events=_("events"),this.client=_("client"),this.chainId=this.getDefaultChain(),this.httpProviders=this.createHttpProviders()}updateNamespace(t){this.namespace=Object.assign(this.namespace,t)}requestAccounts(){return this.getAccounts()}request(t){return this.namespace.methods.includes(t.request.method)?this.client.request(t):this.getHttpProvider().request(t.request)}setDefaultChain(t,e){this.httpProviders[t]||this.setHttpProvider(t,e),this.chainId=t,this.events.emit(P,`${this.name}:${t}`)}getDefaultChain(){if(this.chainId)return this.chainId;if(this.namespace.defaultChain)return this.namespace.defaultChain;const t=this.namespace.chains[0];if(!t)throw new Error("ChainId not found");return t.split(":")[1]}getAccounts(){const t=this.namespace.accounts;return t?[...new Set(t.filter((t=>t.split(":")[1]===this.chainId.toString())).map((t=>t.split(":")[2])))]:[]}createHttpProviders(){const t={};return this.namespace.chains.forEach((e=>{var s;const i=O(e);t[i]=this.createHttpProvider(i,null==(s=this.namespace.rpcMap)?void 0:s[e])})),t}getHttpProvider(){const t=`${this.name}:${this.chainId}`,e=this.httpProviders[t];if(typeof e>"u")throw new Error(`JSON-RPC provider for ${t} not found`);return e}setHttpProvider(t,e){const s=this.createHttpProvider(t,e);s&&(this.httpProviders[t]=s)}createHttpProvider(t,e){const s=e||E(t,this.namespace,this.client.core.projectId);if(!s)throw new Error(`No RPC url provided for chainId: ${t}`);return new o.r(new c.Z(s,_("disableProviderPing")))}}class tt{constructor(t){this.name="multiversx",this.namespace=t.namespace,this.events=_("events"),this.client=_("client"),this.chainId=this.getDefaultChain(),this.httpProviders=this.createHttpProviders()}updateNamespace(t){this.namespace=Object.assign(this.namespace,t)}requestAccounts(){return this.getAccounts()}request(t){return this.namespace.methods.includes(t.request.method)?this.client.request(t):this.getHttpProvider().request(t.request)}setDefaultChain(t,e){this.httpProviders[t]||this.setHttpProvider(t,e),this.chainId=t,this.events.emit(P,`${this.name}:${t}`)}getDefaultChain(){if(this.chainId)return this.chainId;if(this.namespace.defaultChain)return this.namespace.defaultChain;const t=this.namespace.chains[0];if(!t)throw new Error("ChainId not found");return t.split(":")[1]}getAccounts(){const t=this.namespace.accounts;return t?[...new Set(t.filter((t=>t.split(":")[1]===this.chainId.toString())).map((t=>t.split(":")[2])))]:[]}createHttpProviders(){const t={};return this.namespace.chains.forEach((e=>{var s;const i=O(e);t[i]=this.createHttpProvider(i,null==(s=this.namespace.rpcMap)?void 0:s[e])})),t}getHttpProvider(){const t=`${this.name}:${this.chainId}`,e=this.httpProviders[t];if(typeof e>"u")throw new Error(`JSON-RPC provider for ${t} not found`);return e}setHttpProvider(t,e){const s=this.createHttpProvider(t,e);s&&(this.httpProviders[t]=s)}createHttpProvider(t,e){const s=e||E(t,this.namespace,this.client.core.projectId);if(!s)throw new Error(`No RPC url provided for chainId: ${t}`);return new o.r(new c.Z(s,_("disableProviderPing")))}}class et{constructor(t){this.name="near",this.namespace=t.namespace,this.events=_("events"),this.client=_("client"),this.chainId=this.getDefaultChain(),this.httpProviders=this.createHttpProviders()}updateNamespace(t){this.namespace=Object.assign(this.namespace,t)}requestAccounts(){return this.getAccounts()}getDefaultChain(){if(this.chainId)return this.chainId;if(this.namespace.defaultChain)return this.namespace.defaultChain;const t=this.namespace.chains[0];if(!t)throw new Error("ChainId not found");return t.split(":")[1]}request(t){return this.namespace.methods.includes(t.request.method)?this.client.request(t):this.getHttpProvider().request(t.request)}setDefaultChain(t,e){if(this.chainId=t,!this.httpProviders[t]){const s=e||E(`${this.name}:${t}`,this.namespace);if(!s)throw new Error(`No RPC url provided for chainId: ${t}`);this.setHttpProvider(t,s)}this.events.emit(P,`${this.name}:${this.chainId}`)}getAccounts(){const t=this.namespace.accounts;return t&&t.filter((t=>t.split(":")[1]===this.chainId.toString())).map((t=>t.split(":")[2]))||[]}createHttpProviders(){const t={};return this.namespace.chains.forEach((e=>{var s;t[e]=this.createHttpProvider(e,null==(s=this.namespace.rpcMap)?void 0:s[e])})),t}getHttpProvider(){const t=`${this.name}:${this.chainId}`,e=this.httpProviders[t];if(typeof e>"u")throw new Error(`JSON-RPC provider for ${t} not found`);return e}setHttpProvider(t,e){const s=this.createHttpProvider(t,e);s&&(this.httpProviders[t]=s)}createHttpProvider(t,e){const s=e||E(t,this.namespace);return typeof s>"u"?void 0:new o.r(new c.Z(s,_("disableProviderPing")))}}class st{constructor(t){this.name="tezos",this.namespace=t.namespace,this.events=_("events"),this.client=_("client"),this.chainId=this.getDefaultChain(),this.httpProviders=this.createHttpProviders()}updateNamespace(t){this.namespace=Object.assign(this.namespace,t)}requestAccounts(){return this.getAccounts()}getDefaultChain(){if(this.chainId)return this.chainId;if(this.namespace.defaultChain)return this.namespace.defaultChain;const t=this.namespace.chains[0];if(!t)throw new Error("ChainId not found");return t.split(":")[1]}request(t){return this.namespace.methods.includes(t.request.method)?this.client.request(t):this.getHttpProvider().request(t.request)}setDefaultChain(t,e){if(this.chainId=t,!this.httpProviders[t]){const s=e||E(`${this.name}:${t}`,this.namespace);if(!s)throw new Error(`No RPC url provided for chainId: ${t}`);this.setHttpProvider(t,s)}this.events.emit(P,`${this.name}:${this.chainId}`)}getAccounts(){const t=this.namespace.accounts;return t&&t.filter((t=>t.split(":")[1]===this.chainId.toString())).map((t=>t.split(":")[2]))||[]}createHttpProviders(){const t={};return this.namespace.chains.forEach((e=>{t[e]=this.createHttpProvider(e)})),t}getHttpProvider(){const t=`${this.name}:${this.chainId}`,e=this.httpProviders[t];if(typeof e>"u")throw new Error(`JSON-RPC provider for ${t} not found`);return e}setHttpProvider(t,e){const s=this.createHttpProvider(t,e);s&&(this.httpProviders[t]=s)}createHttpProvider(t,e){const s=e||E(t,this.namespace);return typeof s>"u"?void 0:new o.r(new c.Z(s))}}class it{constructor(t){this.name=v,this.namespace=t.namespace,this.events=_("events"),this.client=_("client"),this.chainId=this.getDefaultChain(),this.httpProviders=this.createHttpProviders()}updateNamespace(t){this.namespace.chains=[...new Set((this.namespace.chains||[]).concat(t.chains||[]))],this.namespace.accounts=[...new Set((this.namespace.accounts||[]).concat(t.accounts||[]))],this.namespace.methods=[...new Set((this.namespace.methods||[]).concat(t.methods||[]))],this.namespace.events=[...new Set((this.namespace.events||[]).concat(t.events||[]))],this.httpProviders=this.createHttpProviders()}requestAccounts(){return this.getAccounts()}request(t){return this.namespace.methods.includes(t.request.method)?this.client.request(t):this.getHttpProvider(t.chainId).request(t.request)}setDefaultChain(t,e){this.httpProviders[t]||this.setHttpProvider(t,e),this.chainId=t,this.events.emit(P,`${this.name}:${t}`)}getDefaultChain(){if(this.chainId)return this.chainId;if(this.namespace.defaultChain)return this.namespace.defaultChain;const t=this.namespace.chains[0];if(!t)throw new Error("ChainId not found");return t.split(":")[1]}getAccounts(){const t=this.namespace.accounts;return t?[...new Set(t.filter((t=>t.split(":")[1]===this.chainId.toString())).map((t=>t.split(":")[2])))]:[]}createHttpProviders(){var t,e;const s={};return null==(e=null==(t=this.namespace)?void 0:t.accounts)||e.forEach((t=>{const e=(0,r.DQe)(t);s[`${e.namespace}:${e.reference}`]=this.createHttpProvider(t)})),s}getHttpProvider(t){const e=this.httpProviders[t];if(typeof e>"u")throw new Error(`JSON-RPC provider for ${t} not found`);return e}setHttpProvider(t,e){const s=this.createHttpProvider(t,e);s&&(this.httpProviders[t]=s)}createHttpProvider(t,e){const s=e||E(t,this.namespace,this.client.core.projectId);if(!s)throw new Error(`No RPC url provided for chainId: ${t}`);return new o.r(new c.Z(s,_("disableProviderPing")))}}var rt=Object.defineProperty,nt=Object.defineProperties,at=Object.getOwnPropertyDescriptors,ct=Object.getOwnPropertySymbols,ot=Object.prototype.hasOwnProperty,ht=Object.prototype.propertyIsEnumerable,pt=(t,e,s)=>e in t?rt(t,e,{enumerable:!0,configurable:!0,writable:!0,value:s}):t[e]=s,dt=(t,e)=>{for(var s in e||(e={}))ot.call(e,s)&&pt(t,s,e[s]);if(ct)for(var s of ct(e))ht.call(e,s)&&pt(t,s,e[s]);return t},ut=(t,e)=>nt(t,at(e));class lt{constructor(t){this.events=new(d()),this.rpcProviders={},this.shouldAbortPairingAttempt=!1,this.maxPairingAttempts=10,this.disableProviderPing=!1,this.providerOpts=t,this.logger=typeof t?.logger<"u"&&"string"!=typeof t?.logger?t.logger:(0,n.gw)((0,n.jI)({level:t?.logger||u})),this.disableProviderPing=t?.disableProviderPing||!1}static async init(t){const e=new lt(t);return await e.initialize(),e}async request(t,e,s){const[i,r]=this.validateChain(e);if(!this.session)throw new Error("Please call connect() before request()");return await this.getProvider(i).request({request:dt({},t),chainId:`${i}:${r}`,topic:this.session.topic,expiry:s})}sendAsync(t,e,s,i){const r=(new Date).getTime();this.request(t,s,i).then((t=>e(null,(0,h.formatJsonRpcResult)(r,t)))).catch((t=>e(t,void 0)))}async enable(){if(!this.client)throw new Error("Sign Client not initialized");return this.session||await this.connect({namespaces:this.namespaces,optionalNamespaces:this.optionalNamespaces,sessionProperties:this.sessionProperties}),await this.requestAccounts()}async disconnect(){var t;if(!this.session)throw new Error("Please call connect() before enable()");await this.client.disconnect({topic:null==(t=this.session)?void 0:t.topic,reason:(0,r.D6H)("USER_DISCONNECTED")}),await this.cleanup()}async connect(t){if(!this.client)throw new Error("Sign Client not initialized");if(this.setNamespaces(t),await this.cleanupPendingPairings(),!t.skipPairing)return await this.pair(t.pairingTopic)}async authenticate(t,e){if(!this.client)throw new Error("Sign Client not initialized");this.setNamespaces(t),await this.cleanupPendingPairings();const{uri:s,response:i}=await this.client.authenticate(t,e);s&&(this.uri=s,this.events.emit("display_uri",s));const r=await i();if(this.session=r.session,this.session){const t=D(this.session.namespaces);this.namespaces=N(this.namespaces,t),this.persist("namespaces",this.namespaces),this.onConnect()}return r}on(t,e){this.events.on(t,e)}once(t,e){this.events.once(t,e)}removeListener(t,e){this.events.removeListener(t,e)}off(t,e){this.events.off(t,e)}get isWalletConnect(){return!0}async pair(t){this.shouldAbortPairingAttempt=!1;let e=0;do{if(this.shouldAbortPairingAttempt)throw new Error("Pairing aborted");if(e>=this.maxPairingAttempts)throw new Error("Max auto pairing attempts reached");const{uri:s,approval:r}=await this.client.connect({pairingTopic:t,requiredNamespaces:this.namespaces,optionalNamespaces:this.optionalNamespaces,sessionProperties:this.sessionProperties});s&&(this.uri=s,this.events.emit("display_uri",s)),await r().then((t=>{this.session=t;const e=D(t.namespaces);this.namespaces=N(this.namespaces,e),this.persist("namespaces",this.namespaces)})).catch((t=>{if(t.message!==i.lO)throw t;e++}))}while(!this.session);return this.onConnect(),this.session}setDefaultChain(t,e){try{if(!this.session)return;const[s,i]=this.validateChain(t),r=this.getProvider(s);r.name===v?r.setDefaultChain(`${s}:${i}`,e):r.setDefaultChain(i,e)}catch(t){if(!/Please call connect/.test(t.message))throw t}}async cleanupPendingPairings(t={}){this.logger.info("Cleaning up inactive pairings...");const e=this.client.pairing.getAll();if((0,r.qt8)(e)){for(const s of e)t.deletePairings?this.client.core.expirer.set(s.topic,0):await this.client.core.relayer.subscriber.unsubscribe(s.topic);this.logger.info(`Inactive pairings cleared: ${e.length}`)}}abortPairingAttempt(){this.shouldAbortPairingAttempt=!0}async checkStorage(){if(this.namespaces=await this.getFromStore("namespaces"),this.optionalNamespaces=await this.getFromStore("optionalNamespaces")||{},this.client.session.length){const t=this.client.session.keys.length-1;this.session=this.client.session.get(this.client.session.keys[t]),this.createProviders()}}async initialize(){this.logger.trace("Initialized"),await this.createClient(),await this.checkStorage(),this.registerEventListeners()}async createClient(){this.client=this.providerOpts.client||await i.ZP.init({core:this.providerOpts.core,logger:this.providerOpts.logger||u,relayUrl:this.providerOpts.relayUrl||"wss://relay.walletconnect.org",projectId:this.providerOpts.projectId,metadata:this.providerOpts.metadata,storageOptions:this.providerOpts.storageOptions,storage:this.providerOpts.storage,name:this.providerOpts.name,customStoragePrefix:this.providerOpts.customStoragePrefix,telemetryEnabled:this.providerOpts.telemetryEnabled}),this.logger.trace("SignClient Initialized")}createProviders(){if(!this.client)throw new Error("Sign Client not initialized");if(!this.session)throw new Error("Session not initialized. Please call connect() before enable()");const t=[...new Set(Object.keys(this.session.namespaces).map((t=>(0,r.Maj)(t))))];M("client",this.client),M("events",this.events),M("disableProviderPing",this.disableProviderPing),t.forEach((t=>{if(!this.session)return;const e=function(t,e){const s=Object.keys(e.namespaces).filter((e=>e.includes(t)));if(!s.length)return[];const i=[];return s.forEach((t=>{const s=e.namespaces[t].accounts;i.push(...s)})),i}(t,this.session),s=S(e),i=N(this.namespaces,this.optionalNamespaces),r=ut(dt({},i[t]),{accounts:e,chains:s});switch(t){case"eip155":this.rpcProviders[t]=new Q({namespace:r});break;case"algorand":this.rpcProviders[t]=new V({namespace:r});break;case"solana":this.rpcProviders[t]=new W({namespace:r});break;case"cosmos":this.rpcProviders[t]=new K({namespace:r});break;case"polkadot":this.rpcProviders[t]=new U({namespace:r});break;case"cip34":this.rpcProviders[t]=new X({namespace:r});break;case"elrond":this.rpcProviders[t]=new Y({namespace:r});break;case"multiversx":this.rpcProviders[t]=new tt({namespace:r});break;case"near":this.rpcProviders[t]=new et({namespace:r});break;case"tezos":this.rpcProviders[t]=new st({namespace:r});break;default:this.rpcProviders[v]?this.rpcProviders[v].updateNamespace(r):this.rpcProviders[v]=new it({namespace:r})}}))}registerEventListeners(){if(typeof this.client>"u")throw new Error("Sign Client is not initialized");this.client.on("session_ping",(t=>{this.events.emit("session_ping",t)})),this.client.on("session_event",(t=>{const{params:e}=t,{event:s}=e;if("accountsChanged"===s.name){const t=s.data;t&&(0,r.qt8)(t)&&this.events.emit("accountsChanged",t.map(A))}else if("chainChanged"===s.name){const t=e.chainId,s=e.event.data,i=(0,r.Maj)(t),n=R(t)!==R(s)?`${i}:${R(s)}`:t;this.onChainChanged(n)}else this.events.emit(s.name,s.data);this.events.emit("session_event",t)})),this.client.on("session_update",(({topic:t,params:e})=>{var s;const{namespaces:i}=e,r=null==(s=this.client)?void 0:s.session.get(t);this.session=ut(dt({},r),{namespaces:i}),this.onSessionUpdate(),this.events.emit("session_update",{topic:t,params:e})})),this.client.on("session_delete",(async t=>{await this.cleanup(),this.events.emit("session_delete",t),this.events.emit("disconnect",ut(dt({},(0,r.D6H)("USER_DISCONNECTED")),{data:t.topic}))})),this.on(P,(t=>{this.onChainChanged(t,!0)}))}getProvider(t){return this.rpcProviders[t]||this.rpcProviders[v]}onSessionUpdate(){Object.keys(this.rpcProviders).forEach((t=>{var e;this.getProvider(t).updateNamespace(null==(e=this.session)?void 0:e.namespaces[t])}))}setNamespaces(t){const{namespaces:e,optionalNamespaces:s,sessionProperties:i}=t;e&&Object.keys(e).length&&(this.namespaces=e),s&&Object.keys(s).length&&(this.optionalNamespaces=s),this.sessionProperties=i,this.persist("namespaces",e),this.persist("optionalNamespaces",s)}validateChain(t){const[e,s]=t?.split(":")||["",""];if(!this.namespaces||!Object.keys(this.namespaces).length)return[e,s];if(e&&!Object.keys(this.namespaces||{}).map((t=>(0,r.Maj)(t))).includes(e))throw new Error(`Namespace '${e}' is not configured. Please call connect() first with namespace config.`);if(e&&s)return[e,s];const i=(0,r.Maj)(Object.keys(this.namespaces)[0]);return[i,this.rpcProviders[i].getDefaultChain()]}async requestAccounts(){const[t]=this.validateChain();return await this.getProvider(t).requestAccounts()}onChainChanged(t,e=!1){if(!this.namespaces)return;const[s,i]=this.validateChain(t);i&&(e||this.getProvider(s).setDefaultChain(i),this.namespaces[s]?this.namespaces[s].defaultChain=i:this.namespaces[`${s}:${i}`]?this.namespaces[`${s}:${i}`].defaultChain=i:this.namespaces[`${s}:${i}`]={defaultChain:i},this.persist("namespaces",this.namespaces),this.events.emit("chainChanged",i))}onConnect(){this.createProviders(),this.events.emit("connect",{session:this.session})}async cleanup(){this.session=void 0,this.namespaces=void 0,this.optionalNamespaces=void 0,this.sessionProperties=void 0,this.persist("namespaces",void 0),this.persist("optionalNamespaces",void 0),this.persist("sessionProperties",void 0),await this.cleanupPendingPairings({deletePairings:!0})}persist(t,e){this.client.core.storage.setItem(`${l}/${t}`,e)}async getFromStore(t){return await this.client.core.storage.getItem(`${l}/${t}`)}}}}]);