"use strict";(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[2980],{32980:function(e,t,i){i.d(t,{E9:function(){return re},I8:function(){return F},Mb:function(){return O},QY:function(){return Pi},QZ:function(){return M},Wk:function(){return te},ZF:function(){return S},cQ:function(){return ie},i9:function(){return Y},jb:function(){return ee},ne:function(){return X},sG:function(){return W},t7:function(){return se},yh:function(){return ni}});var s=i(25788),r=i.n(s),n=i(70298),o=i(80791),a=i(11899),h=i(62863),c=i(2621),l=i(73633),p=i(14374),g=i(17486),d=i(20097),u=i(11632),y=i(78186),m=i(63283),b=i(98702),f=i.n(b),w=i(16469);const v="core",_=`wc@2:${v}:`,E="error",I={database:":memory:"},x="client_ed25519_seed",P=c.ONE_DAY,T=c.SIX_HOURS,S="irn",C="wss://relay.walletconnect.org",O={message:"relayer_message",message_ack:"relayer_message_ack",connect:"relayer_connect",disconnect:"relayer_disconnect",error:"relayer_error",connection_stalled:"relayer_connection_stalled",transport_closed:"relayer_transport_closed",publish:"relayer_publish"},k="payload",R="connect",D="disconnect",z="error",A="2.17.2",M={link_mode:"link_mode",relay:"relay"},N="WALLETCONNECT_LINK_MODE_APPS",K="subscription_created",L="subscription_deleted",$="subscription_sync",U="subscription_resubscribed",j=1e3*c.FIVE_SECONDS,q={wc_pairingDelete:{req:{ttl:c.ONE_DAY,prompt:!1,tag:1e3},res:{ttl:c.ONE_DAY,prompt:!1,tag:1001}},wc_pairingPing:{req:{ttl:c.THIRTY_SECONDS,prompt:!1,tag:1002},res:{ttl:c.THIRTY_SECONDS,prompt:!1,tag:1003}},unregistered_method:{req:{ttl:c.ONE_DAY,prompt:!1,tag:0},res:{ttl:c.ONE_DAY,prompt:!1,tag:0}}},F={create:"pairing_create",expire:"pairing_expire",delete:"pairing_delete",ping:"pairing_ping"},B="history_created",V="history_updated",H="history_deleted",J="history_sync",Y={created:"expirer_created",deleted:"expirer_deleted",expired:"expirer_expired",sync:"expirer_sync"},G="https://verify.walletconnect.org",W=G,Z=`${W}/v3`,Q=["https://verify.walletconnect.com",G],X={pairing_started:"pairing_started",pairing_uri_validation_success:"pairing_uri_validation_success",pairing_uri_not_expired:"pairing_uri_not_expired",store_new_pairing:"store_new_pairing",subscribing_pairing_topic:"subscribing_pairing_topic",subscribe_pairing_topic_success:"subscribe_pairing_topic_success",existing_pairing:"existing_pairing",pairing_not_expired:"pairing_not_expired",emit_inactive_pairing:"emit_inactive_pairing",emit_session_proposal:"emit_session_proposal",subscribing_to_pairing_topic:"subscribing_to_pairing_topic"},ee={no_wss_connection:"no_wss_connection",no_internet_connection:"no_internet_connection",malformed_pairing_uri:"malformed_pairing_uri",active_pairing_already_exists:"active_pairing_already_exists",subscribe_pairing_topic_failure:"subscribe_pairing_topic_failure",pairing_expired:"pairing_expired",proposal_expired:"proposal_expired",proposal_listener_not_found:"proposal_listener_not_found"},te={session_approve_started:"session_approve_started",proposal_not_expired:"proposal_not_expired",session_namespaces_validation_success:"session_namespaces_validation_success",create_session_topic:"create_session_topic",subscribing_session_topic:"subscribing_session_topic",subscribe_session_topic_success:"subscribe_session_topic_success",publishing_session_approve:"publishing_session_approve",session_approve_publish_success:"session_approve_publish_success",store_session:"store_session",publishing_session_settle:"publishing_session_settle",session_settle_publish_success:"session_settle_publish_success"},ie={no_internet_connection:"no_internet_connection",no_wss_connection:"no_wss_connection",proposal_expired:"proposal_expired",subscribe_session_topic_failure:"subscribe_session_topic_failure",session_approve_publish_failure:"session_approve_publish_failure",session_settle_publish_failure:"session_settle_publish_failure",session_approve_namespace_validation_failure:"session_approve_namespace_validation_failure",proposal_not_found:"proposal_not_found"},se={authenticated_session_approve_started:"authenticated_session_approve_started",authenticated_session_not_expired:"authenticated_session_not_expired",chains_caip2_compliant:"chains_caip2_compliant",chains_evm_compliant:"chains_evm_compliant",create_authenticated_session_topic:"create_authenticated_session_topic",cacaos_verified:"cacaos_verified",store_authenticated_session:"store_authenticated_session",subscribing_authenticated_session_topic:"subscribing_authenticated_session_topic",subscribe_authenticated_session_topic_success:"subscribe_authenticated_session_topic_success",publishing_authenticated_session_approve:"publishing_authenticated_session_approve",authenticated_session_approve_publish_success:"authenticated_session_approve_publish_success"},re={no_internet_connection:"no_internet_connection",no_wss_connection:"no_wss_connection",missing_session_authenticate_request:"missing_session_authenticate_request",session_authenticate_request_expired:"session_authenticate_request_expired",chains_caip2_compliant_failure:"chains_caip2_compliant_failure",chains_evm_compliant_failure:"chains_evm_compliant_failure",invalid_cacao:"invalid_cacao",subscribe_authenticated_session_topic_failure:"subscribe_authenticated_session_topic_failure",authenticated_session_approve_publish_failure:"authenticated_session_approve_publish_failure",authenticated_session_pending_request_not_found:"authenticated_session_pending_request_not_found"};var ne=function(e,t){if(e.length>=255)throw new TypeError("Alphabet too long");for(var i=new Uint8Array(256),s=0;s<i.length;s++)i[s]=255;for(var r=0;r<e.length;r++){var n=e.charAt(r),o=n.charCodeAt(0);if(255!==i[o])throw new TypeError(n+" is ambiguous");i[o]=r}var a=e.length,h=e.charAt(0),c=Math.log(a)/Math.log(256),l=Math.log(256)/Math.log(a);function p(e){if("string"!=typeof e)throw new TypeError("Expected String");if(0===e.length)return new Uint8Array;var t=0;if(" "!==e[t]){for(var s=0,r=0;e[t]===h;)s++,t++;for(var n=(e.length-t)*c+1>>>0,o=new Uint8Array(n);e[t];){var l=i[e.charCodeAt(t)];if(255===l)return;for(var p=0,g=n-1;(0!==l||p<r)&&-1!==g;g--,p++)l+=a*o[g]>>>0,o[g]=l%256>>>0,l=l/256>>>0;if(0!==l)throw new Error("Non-zero carry");r=p,t++}if(" "!==e[t]){for(var d=n-r;d!==n&&0===o[d];)d++;for(var u=new Uint8Array(s+(n-d)),y=s;d!==n;)u[y++]=o[d++];return u}}}return{encode:function(t){if(t instanceof Uint8Array||(ArrayBuffer.isView(t)?t=new Uint8Array(t.buffer,t.byteOffset,t.byteLength):Array.isArray(t)&&(t=Uint8Array.from(t))),!(t instanceof Uint8Array))throw new TypeError("Expected Uint8Array");if(0===t.length)return"";for(var i=0,s=0,r=0,n=t.length;r!==n&&0===t[r];)r++,i++;for(var o=(n-r)*l+1>>>0,c=new Uint8Array(o);r!==n;){for(var p=t[r],g=0,d=o-1;(0!==p||g<s)&&-1!==d;d--,g++)p+=256*c[d]>>>0,c[d]=p%a>>>0,p=p/a>>>0;if(0!==p)throw new Error("Non-zero carry");s=g,r++}for(var u=o-s;u!==o&&0===c[u];)u++;for(var y=h.repeat(i);u<o;++u)y+=e.charAt(c[u]);return y},decodeUnsafe:p,decode:function(e){var i=p(e);if(i)return i;throw new Error(`Non-${t} character`)}}};const oe=e=>{if(e instanceof Uint8Array&&"Uint8Array"===e.constructor.name)return e;if(e instanceof ArrayBuffer)return new Uint8Array(e);if(ArrayBuffer.isView(e))return new Uint8Array(e.buffer,e.byteOffset,e.byteLength);throw new Error("Unknown type, must be binary type")};class ae{constructor(e,t,i){this.name=e,this.prefix=t,this.baseEncode=i}encode(e){if(e instanceof Uint8Array)return`${this.prefix}${this.baseEncode(e)}`;throw Error("Unknown type, must be binary type")}}class he{constructor(e,t,i){if(this.name=e,this.prefix=t,void 0===t.codePointAt(0))throw new Error("Invalid prefix character");this.prefixCodePoint=t.codePointAt(0),this.baseDecode=i}decode(e){if("string"==typeof e){if(e.codePointAt(0)!==this.prefixCodePoint)throw Error(`Unable to decode multibase string ${JSON.stringify(e)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);return this.baseDecode(e.slice(this.prefix.length))}throw Error("Can only multibase decode strings")}or(e){return le(this,e)}}class ce{constructor(e){this.decoders=e}or(e){return le(this,e)}decode(e){const t=e[0],i=this.decoders[t];if(i)return i.decode(e);throw RangeError(`Unable to decode multibase string ${JSON.stringify(e)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`)}}const le=(e,t)=>new ce({...e.decoders||{[e.prefix]:e},...t.decoders||{[t.prefix]:t}});class pe{constructor(e,t,i,s){this.name=e,this.prefix=t,this.baseEncode=i,this.baseDecode=s,this.encoder=new ae(e,t,i),this.decoder=new he(e,t,s)}encode(e){return this.encoder.encode(e)}decode(e){return this.decoder.decode(e)}}const ge=({name:e,prefix:t,encode:i,decode:s})=>new pe(e,t,i,s),de=({prefix:e,name:t,alphabet:i})=>{const{encode:s,decode:r}=ne(i,t);return ge({prefix:e,name:t,encode:s,decode:e=>oe(r(e))})},ue=({name:e,prefix:t,bitsPerChar:i,alphabet:s})=>ge({prefix:t,name:e,encode(e){return((e,t,i)=>{const s="="===t[t.length-1],r=(1<<i)-1;let n="",o=0,a=0;for(let s=0;s<e.length;++s)for(a=a<<8|e[s],o+=8;o>i;)o-=i,n+=t[r&a>>o];if(o&&(n+=t[r&a<<i-o]),s)for(;n.length*i&7;)n+="=";return n})(e,s,i)},decode(t){return((e,t,i,s)=>{const r={};for(let e=0;e<t.length;++e)r[t[e]]=e;let n=e.length;for(;"="===e[n-1];)--n;const o=new Uint8Array(n*i/8|0);let a=0,h=0,c=0;for(let t=0;t<n;++t){const n=r[e[t]];if(void 0===n)throw new SyntaxError(`Non-${s} character`);h=h<<i|n,a+=i,a>=8&&(a-=8,o[c++]=255&h>>a)}if(a>=i||255&h<<8-a)throw new SyntaxError("Unexpected end of data");return o})(t,s,i,e)}}),ye=ge({prefix:"\0",name:"identity",encode:e=>(e=>(new TextDecoder).decode(e))(e),decode:e=>(e=>(new TextEncoder).encode(e))(e)});var me=Object.freeze({__proto__:null,identity:ye});const be=ue({prefix:"0",name:"base2",alphabet:"01",bitsPerChar:1});var fe=Object.freeze({__proto__:null,base2:be});const we=ue({prefix:"7",name:"base8",alphabet:"01234567",bitsPerChar:3});var ve=Object.freeze({__proto__:null,base8:we});const _e=de({prefix:"9",name:"base10",alphabet:"0123456789"});var Ee=Object.freeze({__proto__:null,base10:_e});const Ie=ue({prefix:"f",name:"base16",alphabet:"0123456789abcdef",bitsPerChar:4}),xe=ue({prefix:"F",name:"base16upper",alphabet:"0123456789ABCDEF",bitsPerChar:4});var Pe=Object.freeze({__proto__:null,base16:Ie,base16upper:xe});const Te=ue({prefix:"b",name:"base32",alphabet:"abcdefghijklmnopqrstuvwxyz234567",bitsPerChar:5}),Se=ue({prefix:"B",name:"base32upper",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",bitsPerChar:5}),Ce=ue({prefix:"c",name:"base32pad",alphabet:"abcdefghijklmnopqrstuvwxyz234567=",bitsPerChar:5}),Oe=ue({prefix:"C",name:"base32padupper",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",bitsPerChar:5}),ke=ue({prefix:"v",name:"base32hex",alphabet:"0123456789abcdefghijklmnopqrstuv",bitsPerChar:5}),Re=ue({prefix:"V",name:"base32hexupper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUV",bitsPerChar:5}),De=ue({prefix:"t",name:"base32hexpad",alphabet:"0123456789abcdefghijklmnopqrstuv=",bitsPerChar:5}),ze=ue({prefix:"T",name:"base32hexpadupper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUV=",bitsPerChar:5}),Ae=ue({prefix:"h",name:"base32z",alphabet:"ybndrfg8ejkmcpqxot1uwisza345h769",bitsPerChar:5});var Me=Object.freeze({__proto__:null,base32:Te,base32upper:Se,base32pad:Ce,base32padupper:Oe,base32hex:ke,base32hexupper:Re,base32hexpad:De,base32hexpadupper:ze,base32z:Ae});const Ne=de({prefix:"k",name:"base36",alphabet:"0123456789abcdefghijklmnopqrstuvwxyz"}),Ke=de({prefix:"K",name:"base36upper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"});var Le=Object.freeze({__proto__:null,base36:Ne,base36upper:Ke});const $e=de({name:"base58btc",prefix:"z",alphabet:"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"}),Ue=de({name:"base58flickr",prefix:"Z",alphabet:"123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"});var je=Object.freeze({__proto__:null,base58btc:$e,base58flickr:Ue});const qe=ue({prefix:"m",name:"base64",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",bitsPerChar:6}),Fe=ue({prefix:"M",name:"base64pad",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",bitsPerChar:6}),Be=ue({prefix:"u",name:"base64url",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",bitsPerChar:6}),Ve=ue({prefix:"U",name:"base64urlpad",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",bitsPerChar:6});var He=Object.freeze({__proto__:null,base64:qe,base64pad:Fe,base64url:Be,base64urlpad:Ve});const Je=Array.from("ðŸš€ðŸªâ˜„ðŸ›°ðŸŒŒðŸŒ‘ðŸŒ’ðŸŒ“ðŸŒ”ðŸŒ•ðŸŒ–ðŸŒ—ðŸŒ˜ðŸŒðŸŒðŸŒŽðŸ‰â˜€ðŸ’»ðŸ–¥ðŸ’¾ðŸ’¿ðŸ˜‚â¤ðŸ˜ðŸ¤£ðŸ˜ŠðŸ™ðŸ’•ðŸ˜­ðŸ˜˜ðŸ‘ðŸ˜…ðŸ‘ðŸ˜ðŸ”¥ðŸ¥°ðŸ’”ðŸ’–ðŸ’™ðŸ˜¢ðŸ¤”ðŸ˜†ðŸ™„ðŸ’ªðŸ˜‰â˜ºðŸ‘ŒðŸ¤—ðŸ’œðŸ˜”ðŸ˜ŽðŸ˜‡ðŸŒ¹ðŸ¤¦ðŸŽ‰ðŸ’žâœŒâœ¨ðŸ¤·ðŸ˜±ðŸ˜ŒðŸŒ¸ðŸ™ŒðŸ˜‹ðŸ’—ðŸ’šðŸ˜ðŸ’›ðŸ™‚ðŸ’“ðŸ¤©ðŸ˜„ðŸ˜€ðŸ–¤ðŸ˜ƒðŸ’¯ðŸ™ˆðŸ‘‡ðŸŽ¶ðŸ˜’ðŸ¤­â£ðŸ˜œðŸ’‹ðŸ‘€ðŸ˜ªðŸ˜‘ðŸ’¥ðŸ™‹ðŸ˜žðŸ˜©ðŸ˜¡ðŸ¤ªðŸ‘ŠðŸ¥³ðŸ˜¥ðŸ¤¤ðŸ‘‰ðŸ’ƒðŸ˜³âœ‹ðŸ˜šðŸ˜ðŸ˜´ðŸŒŸðŸ˜¬ðŸ™ƒðŸ€ðŸŒ·ðŸ˜»ðŸ˜“â­âœ…ðŸ¥ºðŸŒˆðŸ˜ˆðŸ¤˜ðŸ’¦âœ”ðŸ˜£ðŸƒðŸ’â˜¹ðŸŽŠðŸ’˜ðŸ˜ â˜ðŸ˜•ðŸŒºðŸŽ‚ðŸŒ»ðŸ˜ðŸ–•ðŸ’ðŸ™ŠðŸ˜¹ðŸ—£ðŸ’«ðŸ’€ðŸ‘‘ðŸŽµðŸ¤žðŸ˜›ðŸ”´ðŸ˜¤ðŸŒ¼ðŸ˜«âš½ðŸ¤™â˜•ðŸ†ðŸ¤«ðŸ‘ˆðŸ˜®ðŸ™†ðŸ»ðŸƒðŸ¶ðŸ’ðŸ˜²ðŸŒ¿ðŸ§¡ðŸŽâš¡ðŸŒžðŸŽˆâŒâœŠðŸ‘‹ðŸ˜°ðŸ¤¨ðŸ˜¶ðŸ¤ðŸš¶ðŸ’°ðŸ“ðŸ’¢ðŸ¤ŸðŸ™ðŸš¨ðŸ’¨ðŸ¤¬âœˆðŸŽ€ðŸºðŸ¤“ðŸ˜™ðŸ’ŸðŸŒ±ðŸ˜–ðŸ‘¶ðŸ¥´â–¶âž¡â“ðŸ’ŽðŸ’¸â¬‡ðŸ˜¨ðŸŒšðŸ¦‹ðŸ˜·ðŸ•ºâš ðŸ™…ðŸ˜ŸðŸ˜µðŸ‘ŽðŸ¤²ðŸ¤ ðŸ¤§ðŸ“ŒðŸ”µðŸ’…ðŸ§ðŸ¾ðŸ’ðŸ˜—ðŸ¤‘ðŸŒŠðŸ¤¯ðŸ·â˜ŽðŸ’§ðŸ˜¯ðŸ’†ðŸ‘†ðŸŽ¤ðŸ™‡ðŸ‘â„ðŸŒ´ðŸ’£ðŸ¸ðŸ’ŒðŸ“ðŸ¥€ðŸ¤¢ðŸ‘…ðŸ’¡ðŸ’©ðŸ‘ðŸ“¸ðŸ‘»ðŸ¤ðŸ¤®ðŸŽ¼ðŸ¥µðŸš©ðŸŽðŸŠðŸ‘¼ðŸ’ðŸ“£ðŸ¥‚"),Ye=Je.reduce(((e,t,i)=>(e[i]=t,e)),[]),Ge=Je.reduce(((e,t,i)=>(e[t.codePointAt(0)]=i,e)),[]);const We=ge({prefix:"ðŸš€",name:"base256emoji",encode:function(e){return e.reduce(((e,t)=>e+=Ye[t]),"")},decode:function(e){const t=[];for(const i of e){const e=Ge[i.codePointAt(0)];if(void 0===e)throw new Error(`Non-base256emoji character: ${i}`);t.push(e)}return new Uint8Array(t)}});var Ze=Object.freeze({__proto__:null,base256emoji:We}),Qe=function e(t,i,s){i=i||[];for(var r=s=s||0;t>=tt;)i[s++]=255&t|Xe,t/=128;for(;t&et;)i[s++]=255&t|Xe,t>>>=7;return i[s]=0|t,e.bytes=s-r+1,i},Xe=128,et=-128,tt=Math.pow(2,31);var it=function e(t,i){var s,r=0,n=0,o=i=i||0,a=t.length;do{if(o>=a)throw e.bytes=0,new RangeError("Could not decode varint");s=t[o++],r+=n<28?(s&rt)<<n:(s&rt)*Math.pow(2,n),n+=7}while(s>=st);return e.bytes=o-i,r},st=128,rt=127;var nt=Math.pow(2,7),ot=Math.pow(2,14),at=Math.pow(2,21),ht=Math.pow(2,28),ct=Math.pow(2,35),lt=Math.pow(2,42),pt=Math.pow(2,49),gt=Math.pow(2,56),dt=Math.pow(2,63),ut={encode:Qe,decode:it,encodingLength:function(e){return e<nt?1:e<ot?2:e<at?3:e<ht?4:e<ct?5:e<lt?6:e<pt?7:e<gt?8:e<dt?9:10}};const yt=(e,t,i=0)=>(ut.encode(e,t,i),t),mt=e=>ut.encodingLength(e),bt=(e,t)=>{const i=t.byteLength,s=mt(e),r=s+mt(i),n=new Uint8Array(r+i);return yt(e,n,0),yt(i,n,s),n.set(t,r),new ft(e,i,t,n)};class ft{constructor(e,t,i,s){this.code=e,this.size=t,this.digest=i,this.bytes=s}}const wt=({name:e,code:t,encode:i})=>new vt(e,t,i);class vt{constructor(e,t,i){this.name=e,this.code=t,this.encode=i}digest(e){if(e instanceof Uint8Array){const t=this.encode(e);return t instanceof Uint8Array?bt(this.code,t):t.then((e=>bt(this.code,e)))}throw Error("Unknown type, must be binary type")}}const _t=e=>async t=>new Uint8Array(await crypto.subtle.digest(e,t)),Et=wt({name:"sha2-256",code:18,encode:_t("SHA-256")}),It=wt({name:"sha2-512",code:19,encode:_t("SHA-512")});Object.freeze({__proto__:null,sha256:Et,sha512:It});const xt=oe,Pt={code:0,name:"identity",encode:xt,digest:e=>bt(0,xt(e))};Object.freeze({__proto__:null,identity:Pt});new TextEncoder,new TextDecoder;const Tt={...me,...fe,...ve,...Ee,...Pe,...Me,...Le,...je,...He,...Ze};function St(e,t,i,s){return{name:e,prefix:t,encoder:{name:e,prefix:t,encode:i},decoder:{decode:s}}}const Ct=St("utf8","u",(e=>"u"+new TextDecoder("utf8").decode(e)),(e=>(new TextEncoder).encode(e.substring(1)))),Ot=St("ascii","a",(e=>{let t="a";for(let i=0;i<e.length;i++)t+=String.fromCharCode(e[i]);return t}),(e=>{const t=function(e=0){return null!=globalThis.Buffer&&null!=globalThis.Buffer.allocUnsafe?globalThis.Buffer.allocUnsafe(e):new Uint8Array(e)}((e=e.substring(1)).length);for(let i=0;i<e.length;i++)t[i]=e.charCodeAt(i);return t})),kt={utf8:Ct,"utf-8":Ct,hex:Tt.base16,latin1:Ot,ascii:Ot,binary:Ot,...Tt};class Rt{constructor(e,t){this.core=e,this.logger=t,this.keychain=new Map,this.name="keychain",this.version="0.3",this.initialized=!1,this.storagePrefix=_,this.init=async()=>{if(!this.initialized){const e=await this.getKeyChain();typeof e<"u"&&(this.keychain=e),this.initialized=!0}},this.has=e=>(this.isInitialized(),this.keychain.has(e)),this.set=async(e,t)=>{this.isInitialized(),this.keychain.set(e,t),await this.persist()},this.get=e=>{this.isInitialized();const t=this.keychain.get(e);if(typeof t>"u"){const{message:t}=(0,g.kCb)("NO_MATCHING_KEY",`${this.name}: ${e}`);throw new Error(t)}return t},this.del=async e=>{this.isInitialized(),this.keychain.delete(e),await this.persist()},this.core=e,this.logger=(0,a.Ep)(t,this.name)}get context(){return(0,a.Fd)(this.logger)}get storageKey(){return this.storagePrefix+this.version+this.core.customStoragePrefix+"//"+this.name}async setKeyChain(e){await this.core.storage.setItem(this.storageKey,(0,g.KCv)(e))}async getKeyChain(){const e=await this.core.storage.getItem(this.storageKey);return typeof e<"u"?(0,g.IPd)(e):void 0}async persist(){await this.setKeyChain(this.keychain)}isInitialized(){if(!this.initialized){const{message:e}=(0,g.kCb)("NOT_INITIALIZED",this.name);throw new Error(e)}}}class Dt{constructor(e,t,i){this.core=e,this.logger=t,this.name="crypto",this.randomSessionIdentifier=(0,g.jdp)(),this.initialized=!1,this.init=async()=>{this.initialized||(await this.keychain.init(),this.initialized=!0)},this.hasKeys=e=>(this.isInitialized(),this.keychain.has(e)),this.getClientId=async()=>{this.isInitialized();const e=await this.getClientSeed(),t=p.generateKeyPair(e);return p.encodeIss(t.publicKey)},this.generateKeyPair=()=>{this.isInitialized();const e=(0,g.Au2)();return this.setPrivateKey(e.publicKey,e.privateKey)},this.signJWT=async e=>{this.isInitialized();const t=await this.getClientSeed(),i=p.generateKeyPair(t),s=this.randomSessionIdentifier,r=P;return await p.signJWT(s,e,r,i)},this.generateSharedKey=(e,t,i)=>{this.isInitialized();const s=this.getPrivateKey(e),r=(0,g.m$A)(s,t);return this.setSymKey(r,i)},this.setSymKey=async(e,t)=>{this.isInitialized();const i=t||(0,g.YmJ)(e);return await this.keychain.set(i,e),i},this.deleteKeyPair=async e=>{this.isInitialized(),await this.keychain.del(e)},this.deleteSymKey=async e=>{this.isInitialized(),await this.keychain.del(e)},this.encode=async(e,t,i)=>{this.isInitialized();const s=(0,g.ENt)(i),r=(0,l.u)(t);if((0,g.Hs$)(s))return(0,g.Spz)(r,i?.encoding);if((0,g.Q8x)(s)){const t=s.senderPublicKey,i=s.receiverPublicKey;e=await this.generateSharedKey(t,i)}const n=this.getSymKey(e),{type:o,senderPublicKey:a}=s;return(0,g.HIp)({type:o,symKey:n,message:r,senderPublicKey:a,encoding:i?.encoding})},this.decode=async(e,t,i)=>{this.isInitialized();const s=(0,g.Llj)(t,i);if((0,g.Hs$)(s)){const e=(0,g.xQU)(t,i?.encoding);return(0,l.D)(e)}if((0,g.Q8x)(s)){const t=s.receiverPublicKey,i=s.senderPublicKey;e=await this.generateSharedKey(t,i)}try{const s=this.getSymKey(e),r=(0,g.peR)({symKey:s,encoded:t,encoding:i?.encoding});return(0,l.D)(r)}catch(t){this.logger.error(`Failed to decode message from topic: '${e}', clientId: '${await this.getClientId()}'`),this.logger.error(t)}},this.getPayloadType=(e,t=g.$dT)=>{const i=(0,g.vBi)({encoded:e,encoding:t});return(0,g.WGe)(i.type)},this.getPayloadSenderPublicKey=(e,t=g.$dT)=>{const i=(0,g.vBi)({encoded:e,encoding:t});return i.senderPublicKey?(0,d.BB)(i.senderPublicKey,g.AWt):void 0},this.core=e,this.logger=(0,a.Ep)(t,this.name),this.keychain=i||new Rt(this.core,this.logger)}get context(){return(0,a.Fd)(this.logger)}async setPrivateKey(e,t){return await this.keychain.set(e,t),e}getPrivateKey(e){return this.keychain.get(e)}async getClientSeed(){let e="";try{e=this.keychain.get(x)}catch{e=(0,g.jdp)(),await this.keychain.set(x,e)}return function(e,t="utf8"){const i=kt[t];if(!i)throw new Error(`Unsupported encoding "${t}"`);return"utf8"!==t&&"utf-8"!==t||null==globalThis.Buffer||null==globalThis.Buffer.from?i.decoder.decode(`${i.prefix}${e}`):globalThis.Buffer.from(e,"utf8")}(e,"base16")}getSymKey(e){return this.keychain.get(e)}isInitialized(){if(!this.initialized){const{message:e}=(0,g.kCb)("NOT_INITIALIZED",this.name);throw new Error(e)}}}class zt extends h.kZ{constructor(e,t){super(e,t),this.logger=e,this.core=t,this.messages=new Map,this.name="messages",this.version="0.3",this.initialized=!1,this.storagePrefix=_,this.init=async()=>{if(!this.initialized){this.logger.trace("Initialized");try{const e=await this.getRelayerMessages();typeof e<"u"&&(this.messages=e),this.logger.debug(`Successfully Restored records for ${this.name}`),this.logger.trace({type:"method",method:"restore",size:this.messages.size})}catch(e){this.logger.debug(`Failed to Restore records for ${this.name}`),this.logger.error(e)}finally{this.initialized=!0}}},this.set=async(e,t)=>{this.isInitialized();const i=(0,g.rjm)(t);let s=this.messages.get(e);return typeof s>"u"&&(s={}),typeof s[i]<"u"||(s[i]=t,this.messages.set(e,s),await this.persist()),i},this.get=e=>{this.isInitialized();let t=this.messages.get(e);return typeof t>"u"&&(t={}),t},this.has=(e,t)=>{this.isInitialized();return typeof this.get(e)[(0,g.rjm)(t)]<"u"},this.del=async e=>{this.isInitialized(),this.messages.delete(e),await this.persist()},this.logger=(0,a.Ep)(e,this.name),this.core=t}get context(){return(0,a.Fd)(this.logger)}get storageKey(){return this.storagePrefix+this.version+this.core.customStoragePrefix+"//"+this.name}async setRelayerMessages(e){await this.core.storage.setItem(this.storageKey,(0,g.KCv)(e))}async getRelayerMessages(){const e=await this.core.storage.getItem(this.storageKey);return typeof e<"u"?(0,g.IPd)(e):void 0}async persist(){await this.setRelayerMessages(this.messages)}isInitialized(){if(!this.initialized){const{message:e}=(0,g.kCb)("NOT_INITIALIZED",this.name);throw new Error(e)}}}class At extends h.z9{constructor(e,t){super(e,t),this.relayer=e,this.logger=t,this.events=new s.EventEmitter,this.name="publisher",this.queue=new Map,this.publishTimeout=(0,c.toMiliseconds)(c.ONE_MINUTE),this.failedPublishTimeout=(0,c.toMiliseconds)(c.ONE_SECOND),this.needsTransportRestart=!1,this.publish=async(e,t,i)=>{var s;this.logger.debug("Publishing Payload"),this.logger.trace({type:"method",method:"publish",params:{topic:e,message:t,opts:i}});const r=i?.ttl||T,n=(0,g._HE)(i),o=i?.prompt||!1,a=i?.tag||0,h=i?.id||(0,y.getBigIntRpcId)().toString(),c={topic:e,message:t,opts:{ttl:r,relay:n,prompt:o,tag:a,id:h,attestation:i?.attestation}},l=`Failed to publish payload, please try again. id:${h} tag:${a}`,p=Date.now();let d,u=1;try{for(;void 0===d;){if(Date.now()-p>this.publishTimeout)throw new Error(l);this.logger.trace({id:h,attempts:u},`publisher.publish - attempt ${u}`),d=await await(0,g.hFY)(this.rpcPublish(e,t,r,n,o,a,h,i?.attestation).catch((e=>this.logger.warn(e))),this.publishTimeout,l),u++,d||await new Promise((e=>setTimeout(e,this.failedPublishTimeout)))}this.relayer.events.emit(O.publish,c),this.logger.debug("Successfully Published Payload"),this.logger.trace({type:"method",method:"publish",params:{id:h,topic:e,message:t,opts:i}})}catch(e){if(this.logger.debug("Failed to Publish Payload"),this.logger.error(e),null!=(s=i?.internal)&&s.throwOnFailedPublish)throw e;this.queue.set(h,c)}},this.on=(e,t)=>{this.events.on(e,t)},this.once=(e,t)=>{this.events.once(e,t)},this.off=(e,t)=>{this.events.off(e,t)},this.removeListener=(e,t)=>{this.events.removeListener(e,t)},this.relayer=e,this.logger=(0,a.Ep)(t,this.name),this.registerEventListeners()}get context(){return(0,a.Fd)(this.logger)}rpcPublish(e,t,i,s,r,n,o,a){var h,c,l,p;const d={method:(0,g.cOS)(s.protocol).publish,params:{topic:e,message:t,ttl:i,prompt:r,tag:n,attestation:a},id:o};return(0,g.o8e)(null==(h=d.params)?void 0:h.prompt)&&(null==(c=d.params)||delete c.prompt),(0,g.o8e)(null==(l=d.params)?void 0:l.tag)&&(null==(p=d.params)||delete p.tag),this.logger.debug("Outgoing Relay Payload"),this.logger.trace({type:"message",direction:"outgoing",request:d}),this.relayer.request(d)}removeRequestFromQueue(e){this.queue.delete(e)}checkQueue(){this.queue.forEach((async e=>{const{topic:t,message:i,opts:s}=e;await this.publish(t,i,s)}))}registerEventListeners(){this.relayer.core.heartbeat.on(n.Lx.pulse,(()=>{if(this.needsTransportRestart)return this.needsTransportRestart=!1,void this.relayer.events.emit(O.connection_stalled);this.checkQueue()})),this.relayer.on(O.message_ack,(e=>{this.removeRequestFromQueue(e.id.toString())}))}}class Mt{constructor(){this.map=new Map,this.set=(e,t)=>{const i=this.get(e);this.exists(e,t)||this.map.set(e,[...i,t])},this.get=e=>this.map.get(e)||[],this.exists=(e,t)=>this.get(e).includes(t),this.delete=(e,t)=>{if(typeof t>"u")return void this.map.delete(e);if(!this.map.has(e))return;const i=this.get(e);if(!this.exists(e,t))return;const s=i.filter((e=>e!==t));s.length?this.map.set(e,s):this.map.delete(e)},this.clear=()=>{this.map.clear()}}get topics(){return Array.from(this.map.keys())}}var Nt=Object.defineProperty,Kt=Object.defineProperties,Lt=Object.getOwnPropertyDescriptors,$t=Object.getOwnPropertySymbols,Ut=Object.prototype.hasOwnProperty,jt=Object.prototype.propertyIsEnumerable,qt=(e,t,i)=>t in e?Nt(e,t,{enumerable:!0,configurable:!0,writable:!0,value:i}):e[t]=i,Ft=(e,t)=>{for(var i in t||(t={}))Ut.call(t,i)&&qt(e,i,t[i]);if($t)for(var i of $t(t))jt.call(t,i)&&qt(e,i,t[i]);return e},Bt=(e,t)=>Kt(e,Lt(t));class Vt extends h.sY{constructor(e,t){super(e,t),this.relayer=e,this.logger=t,this.subscriptions=new Map,this.topicMap=new Mt,this.events=new s.EventEmitter,this.name="subscription",this.version="0.3",this.pending=new Map,this.cached=[],this.initialized=!1,this.pendingSubscriptionWatchLabel="pending_sub_watch_label",this.pollingInterval=20,this.storagePrefix=_,this.subscribeTimeout=(0,c.toMiliseconds)(c.ONE_MINUTE),this.restartInProgress=!1,this.batchSubscribeTopicsLimit=500,this.pendingBatchMessages=[],this.init=async()=>{this.initialized||(this.logger.trace("Initialized"),this.registerEventListeners(),this.clientId=await this.relayer.core.crypto.getClientId(),await this.restore()),this.initialized=!0},this.subscribe=async(e,t)=>{this.isInitialized(),this.logger.debug("Subscribing Topic"),this.logger.trace({type:"method",method:"subscribe",params:{topic:e,opts:t}});try{const i=(0,g._HE)(t),s={topic:e,relay:i,transportType:t?.transportType};this.pending.set(e,s);const r=await this.rpcSubscribe(e,i,t);return"string"==typeof r&&(this.onSubscribe(r,s),this.logger.debug("Successfully Subscribed Topic"),this.logger.trace({type:"method",method:"subscribe",params:{topic:e,opts:t}})),r}catch(e){throw this.logger.debug("Failed to Subscribe Topic"),this.logger.error(e),e}},this.unsubscribe=async(e,t)=>{await this.restartToComplete(),this.isInitialized(),typeof t?.id<"u"?await this.unsubscribeById(e,t.id,t):await this.unsubscribeByTopic(e,t)},this.isSubscribed=async e=>{if(this.topics.includes(e))return!0;const t=`${this.pendingSubscriptionWatchLabel}_${e}`;return await new Promise(((i,s)=>{const r=new c.Watch;r.start(t);const n=setInterval((()=>{!this.pending.has(e)&&this.topics.includes(e)&&(clearInterval(n),r.stop(t),i(!0)),r.elapsed(t)>=j&&(clearInterval(n),r.stop(t),s(new Error("Subscription resolution timeout")))}),this.pollingInterval)})).catch((()=>!1))},this.on=(e,t)=>{this.events.on(e,t)},this.once=(e,t)=>{this.events.once(e,t)},this.off=(e,t)=>{this.events.off(e,t)},this.removeListener=(e,t)=>{this.events.removeListener(e,t)},this.start=async()=>{await this.onConnect()},this.stop=async()=>{await this.onDisconnect()},this.restart=async()=>{this.restartInProgress=!0,await this.restore(),await this.reset(),this.restartInProgress=!1},this.relayer=e,this.logger=(0,a.Ep)(t,this.name),this.clientId=""}get context(){return(0,a.Fd)(this.logger)}get storageKey(){return this.storagePrefix+this.version+this.relayer.core.customStoragePrefix+"//"+this.name}get length(){return this.subscriptions.size}get ids(){return Array.from(this.subscriptions.keys())}get values(){return Array.from(this.subscriptions.values())}get topics(){return this.topicMap.topics}hasSubscription(e,t){let i=!1;try{i=this.getSubscription(e).topic===t}catch{}return i}onEnable(){this.cached=[],this.initialized=!0}onDisable(){this.cached=this.values,this.subscriptions.clear(),this.topicMap.clear()}async unsubscribeByTopic(e,t){const i=this.topicMap.get(e);await Promise.all(i.map((async i=>await this.unsubscribeById(e,i,t))))}async unsubscribeById(e,t,i){this.logger.debug("Unsubscribing Topic"),this.logger.trace({type:"method",method:"unsubscribe",params:{topic:e,id:t,opts:i}});try{const s=(0,g._HE)(i);await this.rpcUnsubscribe(e,t,s);const r=(0,g.D6H)("USER_DISCONNECTED",`${this.name}, ${e}`);await this.onUnsubscribe(e,t,r),this.logger.debug("Successfully Unsubscribed Topic"),this.logger.trace({type:"method",method:"unsubscribe",params:{topic:e,id:t,opts:i}})}catch(e){throw this.logger.debug("Failed to Unsubscribe Topic"),this.logger.error(e),e}}async rpcSubscribe(e,t,i){var s;i?.transportType===M.relay&&await this.restartToComplete();const r={method:(0,g.cOS)(t.protocol).subscribe,params:{topic:e}};this.logger.debug("Outgoing Relay Payload"),this.logger.trace({type:"payload",direction:"outgoing",request:r});const n=null==(s=i?.internal)?void 0:s.throwOnFailedPublish;try{const t=(0,g.rjm)(e+this.clientId);if(i?.transportType===M.link_mode)return setTimeout((()=>{(this.relayer.connected||this.relayer.connecting)&&this.relayer.request(r).catch((e=>this.logger.warn(e)))}),(0,c.toMiliseconds)(c.ONE_SECOND)),t;const s=await(0,g.hFY)(this.relayer.request(r).catch((e=>this.logger.warn(e))),this.subscribeTimeout,`Subscribing to ${e} failed, please try again`);if(!s&&n)throw new Error(`Subscribing to ${e} failed, please try again`);return s?t:null}catch(e){if(this.logger.debug("Outgoing Relay Subscribe Payload stalled"),this.relayer.events.emit(O.connection_stalled),n)throw e}return null}async rpcBatchSubscribe(e){if(!e.length)return;const t=e[0].relay,i={method:(0,g.cOS)(t.protocol).batchSubscribe,params:{topics:e.map((e=>e.topic))}};this.logger.debug("Outgoing Relay Payload"),this.logger.trace({type:"payload",direction:"outgoing",request:i});try{return await await(0,g.hFY)(this.relayer.request(i).catch((e=>this.logger.warn(e))),this.subscribeTimeout)}catch{this.relayer.events.emit(O.connection_stalled)}}async rpcBatchFetchMessages(e){if(!e.length)return;const t=e[0].relay,i={method:(0,g.cOS)(t.protocol).batchFetchMessages,params:{topics:e.map((e=>e.topic))}};let s;this.logger.debug("Outgoing Relay Payload"),this.logger.trace({type:"payload",direction:"outgoing",request:i});try{s=await await(0,g.hFY)(this.relayer.request(i).catch((e=>this.logger.warn(e))),this.subscribeTimeout)}catch{this.relayer.events.emit(O.connection_stalled)}return s}rpcUnsubscribe(e,t,i){const s={method:(0,g.cOS)(i.protocol).unsubscribe,params:{topic:e,id:t}};return this.logger.debug("Outgoing Relay Payload"),this.logger.trace({type:"payload",direction:"outgoing",request:s}),this.relayer.request(s)}onSubscribe(e,t){this.setSubscription(e,Bt(Ft({},t),{id:e})),this.pending.delete(t.topic)}onBatchSubscribe(e){e.length&&e.forEach((e=>{this.setSubscription(e.id,Ft({},e)),this.pending.delete(e.topic)}))}async onUnsubscribe(e,t,i){this.events.removeAllListeners(t),this.hasSubscription(t,e)&&this.deleteSubscription(t,i),await this.relayer.messages.del(e)}async setRelayerSubscriptions(e){await this.relayer.core.storage.setItem(this.storageKey,e)}async getRelayerSubscriptions(){return await this.relayer.core.storage.getItem(this.storageKey)}setSubscription(e,t){this.logger.debug("Setting subscription"),this.logger.trace({type:"method",method:"setSubscription",id:e,subscription:t}),this.addSubscription(e,t)}addSubscription(e,t){this.subscriptions.set(e,Ft({},t)),this.topicMap.set(t.topic,e),this.events.emit(K,t)}getSubscription(e){this.logger.debug("Getting subscription"),this.logger.trace({type:"method",method:"getSubscription",id:e});const t=this.subscriptions.get(e);if(!t){const{message:t}=(0,g.kCb)("NO_MATCHING_KEY",`${this.name}: ${e}`);throw new Error(t)}return t}deleteSubscription(e,t){this.logger.debug("Deleting subscription"),this.logger.trace({type:"method",method:"deleteSubscription",id:e,reason:t});const i=this.getSubscription(e);this.subscriptions.delete(e),this.topicMap.delete(i.topic,e),this.events.emit(L,Bt(Ft({},i),{reason:t}))}async persist(){await this.setRelayerSubscriptions(this.values),this.events.emit($)}async reset(){if(this.cached.length){const e=Math.ceil(this.cached.length/this.batchSubscribeTopicsLimit);for(let t=0;t<e;t++){const e=this.cached.splice(0,this.batchSubscribeTopicsLimit);await this.batchFetchMessages(e),await this.batchSubscribe(e)}}this.events.emit(U)}async restore(){try{const e=await this.getRelayerSubscriptions();if(typeof e>"u"||!e.length)return;if(this.subscriptions.size){const{message:e}=(0,g.kCb)("RESTORE_WILL_OVERRIDE",this.name);throw this.logger.error(e),this.logger.error(`${this.name}: ${JSON.stringify(this.values)}`),new Error(e)}this.cached=e,this.logger.debug(`Successfully Restored subscriptions for ${this.name}`),this.logger.trace({type:"method",method:"restore",subscriptions:this.values})}catch(e){this.logger.debug(`Failed to Restore subscriptions for ${this.name}`),this.logger.error(e)}}async batchSubscribe(e){if(!e.length)return;const t=await this.rpcBatchSubscribe(e);(0,g.qt8)(t)&&this.onBatchSubscribe(t.map(((t,i)=>Bt(Ft({},e[i]),{id:t}))))}async batchFetchMessages(e){if(!e.length)return;this.logger.trace(`Fetching batch messages for ${e.length} subscriptions`);const t=await this.rpcBatchFetchMessages(e);t&&t.messages&&(this.pendingBatchMessages=this.pendingBatchMessages.concat(t.messages))}async onConnect(){await this.restart(),this.onEnable()}onDisconnect(){this.onDisable()}async checkPending(){if(!this.initialized||!this.relayer.connected)return;const e=[];this.pending.forEach((t=>{e.push(t)})),await this.batchSubscribe(e),this.pendingBatchMessages.length&&(await this.relayer.handleBatchMessageEvents(this.pendingBatchMessages),this.pendingBatchMessages=[])}registerEventListeners(){this.relayer.core.heartbeat.on(n.Lx.pulse,(async()=>{await this.checkPending()})),this.events.on(K,(async e=>{const t=K;this.logger.info(`Emitting ${t}`),this.logger.debug({type:"event",event:t,data:e}),await this.persist()})),this.events.on(L,(async e=>{const t=L;this.logger.info(`Emitting ${t}`),this.logger.debug({type:"event",event:t,data:e}),await this.persist()}))}isInitialized(){if(!this.initialized){const{message:e}=(0,g.kCb)("NOT_INITIALIZED",this.name);throw new Error(e)}}async restartToComplete(){!this.relayer.connected&&!this.relayer.connecting&&await this.relayer.transportOpen(),this.restartInProgress&&await new Promise((e=>{const t=setInterval((()=>{this.restartInProgress||(clearInterval(t),e())}),this.pollingInterval)}))}}var Ht=Object.defineProperty,Jt=Object.getOwnPropertySymbols,Yt=Object.prototype.hasOwnProperty,Gt=Object.prototype.propertyIsEnumerable,Wt=(e,t,i)=>t in e?Ht(e,t,{enumerable:!0,configurable:!0,writable:!0,value:i}):e[t]=i,Zt=(e,t)=>{for(var i in t||(t={}))Yt.call(t,i)&&Wt(e,i,t[i]);if(Jt)for(var i of Jt(t))Gt.call(t,i)&&Wt(e,i,t[i]);return e};class Qt extends h.oe{constructor(e){super(e),this.protocol="wc",this.version=2,this.events=new s.EventEmitter,this.name="relayer",this.transportExplicitlyClosed=!1,this.initialized=!1,this.connectionAttemptInProgress=!1,this.connectionStatusPollingInterval=20,this.staleConnectionErrors=["socket hang up","stalled","interrupted"],this.hasExperiencedNetworkDisruption=!1,this.requestsInFlight=new Map,this.heartBeatTimeout=(0,c.toMiliseconds)(c.THIRTY_SECONDS+c.ONE_SECOND),this.request=async e=>{var t,i;this.logger.debug("Publishing Request Payload");const s=e.id||(0,y.getBigIntRpcId)().toString();await this.toEstablishConnection();try{const r=this.provider.request(e);this.requestsInFlight.set(s,{promise:r,request:e}),this.logger.trace({id:s,method:e.method,topic:null==(t=e.params)?void 0:t.topic},"relayer.request - attempt to publish...");const n=await new Promise((async(e,t)=>{const i=()=>{t(new Error(`relayer.request - publish interrupted, id: ${s}`))};this.provider.on(D,i);const n=await r;this.provider.off(D,i),e(n)}));return this.logger.trace({id:s,method:e.method,topic:null==(i=e.params)?void 0:i.topic},"relayer.request - published"),n}catch(e){throw this.logger.debug(`Failed to Publish Request: ${s}`),e}finally{this.requestsInFlight.delete(s)}},this.resetPingTimeout=()=>{if((0,g.UGU)())try{clearTimeout(this.pingTimeout),this.pingTimeout=setTimeout((()=>{var e,t,i;null==(i=null==(t=null==(e=this.provider)?void 0:e.connection)?void 0:t.socket)||i.terminate()}),this.heartBeatTimeout)}catch(e){this.logger.warn(e)}},this.onPayloadHandler=e=>{this.onProviderPayload(e),this.resetPingTimeout()},this.onConnectHandler=()=>{this.logger.trace("relayer connected"),this.startPingTimeout(),this.events.emit(O.connect)},this.onDisconnectHandler=()=>{this.logger.trace("relayer disconnected"),this.onProviderDisconnect()},this.onProviderErrorHandler=e=>{this.logger.error(e),this.events.emit(O.error,e),this.logger.info("Fatal socket error received, closing transport"),this.transportClose()},this.registerProviderListeners=()=>{this.provider.on(k,this.onPayloadHandler),this.provider.on(R,this.onConnectHandler),this.provider.on(D,this.onDisconnectHandler),this.provider.on(z,this.onProviderErrorHandler)},this.core=e.core,this.logger=typeof e.logger<"u"&&"string"!=typeof e.logger?(0,a.Ep)(e.logger,this.name):(0,a.gw)((0,a.jI)({level:e.logger||"error"})),this.messages=new zt(this.logger,e.core),this.subscriber=new Vt(this,this.logger),this.publisher=new At(this,this.logger),this.relayUrl=e?.relayUrl||C,this.projectId=e.projectId,this.bundleId=(0,g.X_B)(),this.provider={}}async init(){if(this.logger.trace("Initialized"),this.registerEventListeners(),await Promise.all([this.messages.init(),this.subscriber.init()]),this.initialized=!0,this.subscriber.cached.length>0)try{await this.transportOpen()}catch(e){this.logger.warn(e)}}get context(){return(0,a.Fd)(this.logger)}get connected(){var e,t,i;return 1===(null==(i=null==(t=null==(e=this.provider)?void 0:e.connection)?void 0:t.socket)?void 0:i.readyState)}get connecting(){var e,t,i;return 0===(null==(i=null==(t=null==(e=this.provider)?void 0:e.connection)?void 0:t.socket)?void 0:i.readyState)}async publish(e,t,i){this.isInitialized(),await this.publisher.publish(e,t,i),await this.recordMessageEvent({topic:e,message:t,publishedAt:Date.now(),transportType:M.relay})}async subscribe(e,t){var i,s,r;this.isInitialized(),"relay"===t?.transportType&&await this.toEstablishConnection();const n=typeof(null==(i=t?.internal)?void 0:i.throwOnFailedPublish)>"u"||(null==(s=t?.internal)?void 0:s.throwOnFailedPublish);let o,a=(null==(r=this.subscriber.topicMap.get(e))?void 0:r[0])||"";const h=t=>{t.topic===e&&(this.subscriber.off(K,h),o())};return await Promise.all([new Promise((e=>{o=e,this.subscriber.on(K,h)})),new Promise((async(i,s)=>{a=await this.subscriber.subscribe(e,Zt({internal:{throwOnFailedPublish:n}},t)).catch((e=>{n&&s(e)}))||a,i()}))]),a}async unsubscribe(e,t){this.isInitialized(),await this.subscriber.unsubscribe(e,t)}on(e,t){this.events.on(e,t)}once(e,t){this.events.once(e,t)}off(e,t){this.events.off(e,t)}removeListener(e,t){this.events.removeListener(e,t)}async transportDisconnect(){if(!this.hasExperiencedNetworkDisruption&&this.connected&&this.requestsInFlight.size>0)try{await Promise.all(Array.from(this.requestsInFlight.values()).map((e=>e.promise)))}catch(e){this.logger.warn(e)}this.provider.disconnect&&(this.hasExperiencedNetworkDisruption||this.connected)?await(0,g.hFY)(this.provider.disconnect(),2e3,"provider.disconnect()").catch((()=>this.onProviderDisconnect())):this.onProviderDisconnect()}async transportClose(){this.transportExplicitlyClosed=!0,await this.transportDisconnect()}async transportOpen(e){await this.confirmOnlineStateOrThrow(),e&&e!==this.relayUrl&&(this.relayUrl=e,await this.transportDisconnect()),await this.createProvider(),this.connectionAttemptInProgress=!0,this.transportExplicitlyClosed=!1;try{await new Promise((async(e,t)=>{const i=()=>{this.provider.off(D,i),t(new Error("Connection interrupted while trying to subscribe"))};this.provider.on(D,i),await(0,g.hFY)(this.provider.connect(),(0,c.toMiliseconds)(c.ONE_MINUTE),`Socket stalled when trying to connect to ${this.relayUrl}`).catch((e=>{t(e)})).finally((()=>{clearTimeout(this.reconnectTimeout),this.reconnectTimeout=void 0})),this.subscriber.start().catch((e=>{this.logger.error(e),this.onDisconnectHandler()})),this.hasExperiencedNetworkDisruption=!1,e()}))}catch(e){this.logger.error(e);const t=e;if(this.hasExperiencedNetworkDisruption=!0,!this.isConnectionStalled(t.message))throw e}finally{this.connectionAttemptInProgress=!1}}async restartTransport(e){this.connectionAttemptInProgress||(this.relayUrl=e||this.relayUrl,await this.confirmOnlineStateOrThrow(),await this.transportClose(),await this.transportOpen())}async confirmOnlineStateOrThrow(){if(!await(0,g.Ggh)())throw new Error("No internet connection detected. Please restart your network and try again.")}async handleBatchMessageEvents(e){if(0===e?.length)return void this.logger.trace("Batch message events is empty. Ignoring...");const t=e.sort(((e,t)=>e.publishedAt-t.publishedAt));this.logger.trace(`Batch of ${t.length} message events sorted`);for(const e of t)try{await this.onMessageEvent(e)}catch(e){this.logger.warn(e)}this.logger.trace(`Batch of ${t.length} message events processed`)}async onLinkMessageEvent(e,t){const{topic:i}=e;if(!t.sessionExists){const e={topic:i,expiry:(0,g.gn4)(c.FIVE_MINUTES),relay:{protocol:"irn"},active:!1};await this.core.pairing.pairings.set(i,e)}this.events.emit(O.message,e),await this.recordMessageEvent(e)}startPingTimeout(){var e,t,i,s,r;if((0,g.UGU)())try{null!=(t=null==(e=this.provider)?void 0:e.connection)&&t.socket&&(null==(r=null==(s=null==(i=this.provider)?void 0:i.connection)?void 0:s.socket)||r.once("ping",(()=>{this.resetPingTimeout()}))),this.resetPingTimeout()}catch(e){this.logger.warn(e)}}isConnectionStalled(e){return this.staleConnectionErrors.some((t=>e.includes(t)))}async createProvider(){this.provider.connection&&this.unregisterProviderListeners();const e=await this.core.crypto.signJWT(this.relayUrl);this.provider=new u.r(new m.Z((0,g.$0m)({sdkVersion:A,protocol:this.protocol,version:this.version,relayUrl:this.relayUrl,projectId:this.projectId,auth:e,useOnCloseEvent:!0,bundleId:this.bundleId}))),this.registerProviderListeners()}async recordMessageEvent(e){const{topic:t,message:i}=e;await this.messages.set(t,i)}async shouldIgnoreMessageEvent(e){const{topic:t,message:i}=e;if(!i||0===i.length)return this.logger.debug(`Ignoring invalid/empty message: ${i}`),!0;if(!await this.subscriber.isSubscribed(t))return this.logger.debug(`Ignoring message for non-subscribed topic ${t}`),!0;const s=this.messages.has(t,i);return s&&this.logger.debug(`Ignoring duplicate message: ${i}`),s}async onProviderPayload(e){if(this.logger.debug("Incoming Relay Payload"),this.logger.trace({type:"payload",direction:"incoming",payload:e}),(0,y.isJsonRpcRequest)(e)){if(!e.method.endsWith("_subscription"))return;const t=e.params,{topic:i,message:s,publishedAt:r,attestation:n}=t.data,o={topic:i,message:s,publishedAt:r,transportType:M.relay,attestation:n};this.logger.debug("Emitting Relayer Payload"),this.logger.trace(Zt({type:"event",event:t.id},o)),this.events.emit(t.id,o),await this.acknowledgePayload(e),await this.onMessageEvent(o)}else(0,y.isJsonRpcResponse)(e)&&this.events.emit(O.message_ack,e)}async onMessageEvent(e){await this.shouldIgnoreMessageEvent(e)||(this.events.emit(O.message,e),await this.recordMessageEvent(e))}async acknowledgePayload(e){const t=(0,y.formatJsonRpcResult)(e.id,!0);await this.provider.connection.send(t)}unregisterProviderListeners(){this.provider.off(k,this.onPayloadHandler),this.provider.off(R,this.onConnectHandler),this.provider.off(D,this.onDisconnectHandler),this.provider.off(z,this.onProviderErrorHandler),clearTimeout(this.pingTimeout)}async registerEventListeners(){let e=await(0,g.Ggh)();(0,g.uwg)((async t=>{e!==t&&(e=t,t?await this.restartTransport().catch((e=>this.logger.error(e))):(this.hasExperiencedNetworkDisruption=!0,await this.transportDisconnect(),this.transportExplicitlyClosed=!1))}))}async onProviderDisconnect(){await this.subscriber.stop(),this.requestsInFlight.clear(),clearTimeout(this.pingTimeout),this.events.emit(O.disconnect),this.connectionAttemptInProgress=!1,!this.transportExplicitlyClosed&&(this.reconnectTimeout||(this.reconnectTimeout=setTimeout((async()=>{await this.transportOpen().catch((e=>this.logger.error(e)))}),(0,c.toMiliseconds)(.1))))}isInitialized(){if(!this.initialized){const{message:e}=(0,g.kCb)("NOT_INITIALIZED",this.name);throw new Error(e)}}async toEstablishConnection(){await this.confirmOnlineStateOrThrow(),!this.connected&&(this.connectionAttemptInProgress&&await new Promise((e=>{const t=setInterval((()=>{this.connected&&(clearInterval(t),e())}),this.connectionStatusPollingInterval)})),await this.transportOpen())}}var Xt=Object.defineProperty,ei=Object.getOwnPropertySymbols,ti=Object.prototype.hasOwnProperty,ii=Object.prototype.propertyIsEnumerable,si=(e,t,i)=>t in e?Xt(e,t,{enumerable:!0,configurable:!0,writable:!0,value:i}):e[t]=i,ri=(e,t)=>{for(var i in t||(t={}))ti.call(t,i)&&si(e,i,t[i]);if(ei)for(var i of ei(t))ii.call(t,i)&&si(e,i,t[i]);return e};class ni extends h.pZ{constructor(e,t,i,s=_,r=void 0){super(e,t,i,s),this.core=e,this.logger=t,this.name=i,this.map=new Map,this.version="0.3",this.cached=[],this.initialized=!1,this.storagePrefix=_,this.recentlyDeleted=[],this.recentlyDeletedLimit=200,this.init=async()=>{this.initialized||(this.logger.trace("Initialized"),await this.restore(),this.cached.forEach((e=>{this.getKey&&null!==e&&!(0,g.o8e)(e)?this.map.set(this.getKey(e),e):(0,g.xWS)(e)?this.map.set(e.id,e):(0,g.h1R)(e)&&this.map.set(e.topic,e)})),this.cached=[],this.initialized=!0)},this.set=async(e,t)=>{this.isInitialized(),this.map.has(e)?await this.update(e,t):(this.logger.debug("Setting value"),this.logger.trace({type:"method",method:"set",key:e,value:t}),this.map.set(e,t),await this.persist())},this.get=e=>(this.isInitialized(),this.logger.debug("Getting value"),this.logger.trace({type:"method",method:"get",key:e}),this.getData(e)),this.getAll=e=>(this.isInitialized(),e?this.values.filter((t=>Object.keys(e).every((i=>f()(t[i],e[i]))))):this.values),this.update=async(e,t)=>{this.isInitialized(),this.logger.debug("Updating value"),this.logger.trace({type:"method",method:"update",key:e,update:t});const i=ri(ri({},this.getData(e)),t);this.map.set(e,i),await this.persist()},this.delete=async(e,t)=>{this.isInitialized(),this.map.has(e)&&(this.logger.debug("Deleting value"),this.logger.trace({type:"method",method:"delete",key:e,reason:t}),this.map.delete(e),this.addToRecentlyDeleted(e),await this.persist())},this.logger=(0,a.Ep)(t,this.name),this.storagePrefix=s,this.getKey=r}get context(){return(0,a.Fd)(this.logger)}get storageKey(){return this.storagePrefix+this.version+this.core.customStoragePrefix+"//"+this.name}get length(){return this.map.size}get keys(){return Array.from(this.map.keys())}get values(){return Array.from(this.map.values())}addToRecentlyDeleted(e){this.recentlyDeleted.push(e),this.recentlyDeleted.length>=this.recentlyDeletedLimit&&this.recentlyDeleted.splice(0,this.recentlyDeletedLimit/2)}async setDataStore(e){await this.core.storage.setItem(this.storageKey,e)}async getDataStore(){return await this.core.storage.getItem(this.storageKey)}getData(e){const t=this.map.get(e);if(!t){if(this.recentlyDeleted.includes(e)){const{message:t}=(0,g.kCb)("MISSING_OR_INVALID",`Record was recently deleted - ${this.name}: ${e}`);throw this.logger.error(t),new Error(t)}const{message:t}=(0,g.kCb)("NO_MATCHING_KEY",`${this.name}: ${e}`);throw this.logger.error(t),new Error(t)}return t}async persist(){await this.setDataStore(this.values)}async restore(){try{const e=await this.getDataStore();if(typeof e>"u"||!e.length)return;if(this.map.size){const{message:e}=(0,g.kCb)("RESTORE_WILL_OVERRIDE",this.name);throw this.logger.error(e),new Error(e)}this.cached=e,this.logger.debug(`Successfully Restored value for ${this.name}`),this.logger.trace({type:"method",method:"restore",value:this.values})}catch(e){this.logger.debug(`Failed to Restore value for ${this.name}`),this.logger.error(e)}}isInitialized(){if(!this.initialized){const{message:e}=(0,g.kCb)("NOT_INITIALIZED",this.name);throw new Error(e)}}}class oi{constructor(e,t){this.core=e,this.logger=t,this.name="pairing",this.version="0.3",this.events=new(r()),this.initialized=!1,this.storagePrefix=_,this.ignoredPayloadTypes=[g.rVF],this.registeredMethods=[],this.init=async()=>{this.initialized||(await this.pairings.init(),await this.cleanup(),this.registerRelayerEvents(),this.registerExpirerEvents(),this.initialized=!0,this.logger.trace("Initialized"))},this.register=({methods:e})=>{this.isInitialized(),this.registeredMethods=[...new Set([...this.registeredMethods,...e])]},this.create=async e=>{this.isInitialized();const t=(0,g.jdp)(),i=await this.core.crypto.setSymKey(t),s=(0,g.gn4)(c.FIVE_MINUTES),r={protocol:S},n={topic:i,expiry:s,relay:r,active:!1,methods:e?.methods},o=(0,g.Bvr)({protocol:this.core.protocol,version:this.core.version,topic:i,symKey:t,relay:r,expiryTimestamp:s,methods:e?.methods});return this.events.emit(F.create,n),this.core.expirer.set(i,s),await this.pairings.set(i,n),await this.core.relayer.subscribe(i,{transportType:e?.transportType}),{topic:i,uri:o}},this.pair=async e=>{this.isInitialized();const t=this.core.eventClient.createEvent({properties:{topic:e?.uri,trace:[X.pairing_started]}});this.isValidPair(e,t);const{topic:i,symKey:s,relay:r,expiryTimestamp:n,methods:o}=(0,g.heJ)(e.uri);let a;if(t.props.properties.topic=i,t.addTrace(X.pairing_uri_validation_success),t.addTrace(X.pairing_uri_not_expired),this.pairings.keys.includes(i)){if(a=this.pairings.get(i),t.addTrace(X.existing_pairing),a.active)throw t.setError(ee.active_pairing_already_exists),new Error(`Pairing already exists: ${i}. Please try again with a new connection URI.`);t.addTrace(X.pairing_not_expired)}const h=n||(0,g.gn4)(c.FIVE_MINUTES),l={topic:i,relay:r,expiry:h,active:!1,methods:o};this.core.expirer.set(i,h),await this.pairings.set(i,l),t.addTrace(X.store_new_pairing),e.activatePairing&&await this.activate({topic:i}),this.events.emit(F.create,l),t.addTrace(X.emit_inactive_pairing),this.core.crypto.keychain.has(i)||await this.core.crypto.setSymKey(s,i),t.addTrace(X.subscribing_pairing_topic);try{await this.core.relayer.confirmOnlineStateOrThrow()}catch{t.setError(ee.no_internet_connection)}try{await this.core.relayer.subscribe(i,{relay:r})}catch(e){throw t.setError(ee.subscribe_pairing_topic_failure),e}return t.addTrace(X.subscribe_pairing_topic_success),l},this.activate=async({topic:e})=>{this.isInitialized();const t=(0,g.gn4)(c.THIRTY_DAYS);this.core.expirer.set(e,t),await this.pairings.update(e,{active:!0,expiry:t})},this.ping=async e=>{this.isInitialized(),await this.isValidPing(e);const{topic:t}=e;if(this.pairings.keys.includes(t)){const e=await this.sendRequest(t,"wc_pairingPing",{}),{done:i,resolve:s,reject:r}=(0,g.H1S)();this.events.once((0,g.E0T)("pairing_ping",e),(({error:e})=>{e?r(e):s()})),await i()}},this.updateExpiry=async({topic:e,expiry:t})=>{this.isInitialized(),await this.pairings.update(e,{expiry:t})},this.updateMetadata=async({topic:e,metadata:t})=>{this.isInitialized(),await this.pairings.update(e,{peerMetadata:t})},this.getPairings=()=>(this.isInitialized(),this.pairings.values),this.disconnect=async e=>{this.isInitialized(),await this.isValidDisconnect(e);const{topic:t}=e;this.pairings.keys.includes(t)&&(await this.sendRequest(t,"wc_pairingDelete",(0,g.D6H)("USER_DISCONNECTED")),await this.deletePairing(t))},this.formatUriFromPairing=e=>{this.isInitialized();const{topic:t,relay:i,expiry:s,methods:r}=e,n=this.core.crypto.keychain.get(t);return(0,g.Bvr)({protocol:this.core.protocol,version:this.core.version,topic:t,symKey:n,relay:i,expiryTimestamp:s,methods:r})},this.sendRequest=async(e,t,i)=>{const s=(0,y.formatJsonRpcRequest)(t,i),r=await this.core.crypto.encode(e,s),n=q[t].req;return this.core.history.set(e,s),this.core.relayer.publish(e,r,n),s.id},this.sendResult=async(e,t,i)=>{const s=(0,y.formatJsonRpcResult)(e,i),r=await this.core.crypto.encode(t,s),n=await this.core.history.get(t,e),o=q[n.request.method].res;await this.core.relayer.publish(t,r,o),await this.core.history.resolve(s)},this.sendError=async(e,t,i)=>{const s=(0,y.formatJsonRpcError)(e,i),r=await this.core.crypto.encode(t,s),n=await this.core.history.get(t,e),o=q[n.request.method]?q[n.request.method].res:q.unregistered_method.res;await this.core.relayer.publish(t,r,o),await this.core.history.resolve(s)},this.deletePairing=async(e,t)=>{await this.core.relayer.unsubscribe(e),await Promise.all([this.pairings.delete(e,(0,g.D6H)("USER_DISCONNECTED")),this.core.crypto.deleteSymKey(e),t?Promise.resolve():this.core.expirer.del(e)])},this.cleanup=async()=>{const e=this.pairings.getAll().filter((e=>(0,g.BwD)(e.expiry)));await Promise.all(e.map((e=>this.deletePairing(e.topic))))},this.onRelayEventRequest=e=>{const{topic:t,payload:i}=e;switch(i.method){case"wc_pairingPing":return this.onPairingPingRequest(t,i);case"wc_pairingDelete":return this.onPairingDeleteRequest(t,i);default:return this.onUnknownRpcMethodRequest(t,i)}},this.onRelayEventResponse=async e=>{const{topic:t,payload:i}=e,s=(await this.core.history.get(t,i.id)).request.method;return"wc_pairingPing"===s?this.onPairingPingResponse(t,i):this.onUnknownRpcMethodResponse(s)},this.onPairingPingRequest=async(e,t)=>{const{id:i}=t;try{this.isValidPing({topic:e}),await this.sendResult(i,e,!0),this.events.emit(F.ping,{id:i,topic:e})}catch(t){await this.sendError(i,e,t),this.logger.error(t)}},this.onPairingPingResponse=(e,t)=>{const{id:i}=t;setTimeout((()=>{(0,y.isJsonRpcResult)(t)?this.events.emit((0,g.E0T)("pairing_ping",i),{}):(0,y.isJsonRpcError)(t)&&this.events.emit((0,g.E0T)("pairing_ping",i),{error:t.error})}),500)},this.onPairingDeleteRequest=async(e,t)=>{const{id:i}=t;try{this.isValidDisconnect({topic:e}),await this.deletePairing(e),this.events.emit(F.delete,{id:i,topic:e})}catch(t){await this.sendError(i,e,t),this.logger.error(t)}},this.onUnknownRpcMethodRequest=async(e,t)=>{const{id:i,method:s}=t;try{if(this.registeredMethods.includes(s))return;const t=(0,g.D6H)("WC_METHOD_UNSUPPORTED",s);await this.sendError(i,e,t),this.logger.error(t)}catch(t){await this.sendError(i,e,t),this.logger.error(t)}},this.onUnknownRpcMethodResponse=e=>{this.registeredMethods.includes(e)||this.logger.error((0,g.D6H)("WC_METHOD_UNSUPPORTED",e))},this.isValidPair=(e,t)=>{var i;if(!(0,g.EJd)(e)){const{message:i}=(0,g.kCb)("MISSING_OR_INVALID",`pair() params: ${e}`);throw t.setError(ee.malformed_pairing_uri),new Error(i)}if(!(0,g.jvJ)(e.uri)){const{message:i}=(0,g.kCb)("MISSING_OR_INVALID",`pair() uri: ${e.uri}`);throw t.setError(ee.malformed_pairing_uri),new Error(i)}const s=(0,g.heJ)(e?.uri);if(null==(i=s?.relay)||!i.protocol){const{message:e}=(0,g.kCb)("MISSING_OR_INVALID","pair() uri#relay-protocol");throw t.setError(ee.malformed_pairing_uri),new Error(e)}if(null==s||!s.symKey){const{message:e}=(0,g.kCb)("MISSING_OR_INVALID","pair() uri#symKey");throw t.setError(ee.malformed_pairing_uri),new Error(e)}if(null!=s&&s.expiryTimestamp&&(0,c.toMiliseconds)(s?.expiryTimestamp)<Date.now()){t.setError(ee.pairing_expired);const{message:e}=(0,g.kCb)("EXPIRED","pair() URI has expired. Please try again with a new connection URI.");throw new Error(e)}},this.isValidPing=async e=>{if(!(0,g.EJd)(e)){const{message:t}=(0,g.kCb)("MISSING_OR_INVALID",`ping() params: ${e}`);throw new Error(t)}const{topic:t}=e;await this.isValidPairingTopic(t)},this.isValidDisconnect=async e=>{if(!(0,g.EJd)(e)){const{message:t}=(0,g.kCb)("MISSING_OR_INVALID",`disconnect() params: ${e}`);throw new Error(t)}const{topic:t}=e;await this.isValidPairingTopic(t)},this.isValidPairingTopic=async e=>{if(!(0,g.M_r)(e,!1)){const{message:t}=(0,g.kCb)("MISSING_OR_INVALID",`pairing topic should be a string: ${e}`);throw new Error(t)}if(!this.pairings.keys.includes(e)){const{message:t}=(0,g.kCb)("NO_MATCHING_KEY",`pairing topic doesn't exist: ${e}`);throw new Error(t)}if((0,g.BwD)(this.pairings.get(e).expiry)){await this.deletePairing(e);const{message:t}=(0,g.kCb)("EXPIRED",`pairing topic: ${e}`);throw new Error(t)}},this.core=e,this.logger=(0,a.Ep)(t,this.name),this.pairings=new ni(this.core,this.logger,this.name,this.storagePrefix)}get context(){return(0,a.Fd)(this.logger)}isInitialized(){if(!this.initialized){const{message:e}=(0,g.kCb)("NOT_INITIALIZED",this.name);throw new Error(e)}}registerRelayerEvents(){this.core.relayer.on(O.message,(async e=>{const{topic:t,message:i,transportType:s}=e;if(!this.pairings.keys.includes(t)||s===M.link_mode||this.ignoredPayloadTypes.includes(this.core.crypto.getPayloadType(i)))return;const r=await this.core.crypto.decode(t,i);try{(0,y.isJsonRpcRequest)(r)?(this.core.history.set(t,r),this.onRelayEventRequest({topic:t,payload:r})):(0,y.isJsonRpcResponse)(r)&&(await this.core.history.resolve(r),await this.onRelayEventResponse({topic:t,payload:r}),this.core.history.delete(t,r.id))}catch(e){this.logger.error(e)}}))}registerExpirerEvents(){this.core.expirer.on(Y.expired,(async e=>{const{topic:t}=(0,g.iPz)(e.target);t&&this.pairings.keys.includes(t)&&(await this.deletePairing(t,!0),this.events.emit(F.expire,{topic:t}))}))}}class ai extends h.yy{constructor(e,t){super(e,t),this.core=e,this.logger=t,this.records=new Map,this.events=new s.EventEmitter,this.name="history",this.version="0.3",this.cached=[],this.initialized=!1,this.storagePrefix=_,this.init=async()=>{this.initialized||(this.logger.trace("Initialized"),await this.restore(),this.cached.forEach((e=>this.records.set(e.id,e))),this.cached=[],this.registerEventListeners(),this.initialized=!0)},this.set=(e,t,i)=>{if(this.isInitialized(),this.logger.debug("Setting JSON-RPC request history record"),this.logger.trace({type:"method",method:"set",topic:e,request:t,chainId:i}),this.records.has(t.id))return;const s={id:t.id,topic:e,request:{method:t.method,params:t.params||null},chainId:i,expiry:(0,g.gn4)(c.THIRTY_DAYS)};this.records.set(s.id,s),this.persist(),this.events.emit(B,s)},this.resolve=async e=>{if(this.isInitialized(),this.logger.debug("Updating JSON-RPC response history record"),this.logger.trace({type:"method",method:"update",response:e}),!this.records.has(e.id))return;const t=await this.getRecord(e.id);typeof t.response>"u"&&(t.response=(0,y.isJsonRpcError)(e)?{error:e.error}:{result:e.result},this.records.set(t.id,t),this.persist(),this.events.emit(V,t))},this.get=async(e,t)=>(this.isInitialized(),this.logger.debug("Getting record"),this.logger.trace({type:"method",method:"get",topic:e,id:t}),await this.getRecord(t)),this.delete=(e,t)=>{this.isInitialized(),this.logger.debug("Deleting record"),this.logger.trace({type:"method",method:"delete",id:t}),this.values.forEach((i=>{if(i.topic===e){if(typeof t<"u"&&i.id!==t)return;this.records.delete(i.id),this.events.emit(H,i)}})),this.persist()},this.exists=async(e,t)=>(this.isInitialized(),!!this.records.has(t)&&(await this.getRecord(t)).topic===e),this.on=(e,t)=>{this.events.on(e,t)},this.once=(e,t)=>{this.events.once(e,t)},this.off=(e,t)=>{this.events.off(e,t)},this.removeListener=(e,t)=>{this.events.removeListener(e,t)},this.logger=(0,a.Ep)(t,this.name)}get context(){return(0,a.Fd)(this.logger)}get storageKey(){return this.storagePrefix+this.version+this.core.customStoragePrefix+"//"+this.name}get size(){return this.records.size}get keys(){return Array.from(this.records.keys())}get values(){return Array.from(this.records.values())}get pending(){const e=[];return this.values.forEach((t=>{if(typeof t.response<"u")return;const i={topic:t.topic,request:(0,y.formatJsonRpcRequest)(t.request.method,t.request.params,t.id),chainId:t.chainId};return e.push(i)})),e}async setJsonRpcRecords(e){await this.core.storage.setItem(this.storageKey,e)}async getJsonRpcRecords(){return await this.core.storage.getItem(this.storageKey)}getRecord(e){this.isInitialized();const t=this.records.get(e);if(!t){const{message:t}=(0,g.kCb)("NO_MATCHING_KEY",`${this.name}: ${e}`);throw new Error(t)}return t}async persist(){await this.setJsonRpcRecords(this.values),this.events.emit(J)}async restore(){try{const e=await this.getJsonRpcRecords();if(typeof e>"u"||!e.length)return;if(this.records.size){const{message:e}=(0,g.kCb)("RESTORE_WILL_OVERRIDE",this.name);throw this.logger.error(e),new Error(e)}this.cached=e,this.logger.debug(`Successfully Restored records for ${this.name}`),this.logger.trace({type:"method",method:"restore",records:this.values})}catch(e){this.logger.debug(`Failed to Restore records for ${this.name}`),this.logger.error(e)}}registerEventListeners(){this.events.on(B,(e=>{const t=B;this.logger.info(`Emitting ${t}`),this.logger.debug({type:"event",event:t,record:e})})),this.events.on(V,(e=>{const t=V;this.logger.info(`Emitting ${t}`),this.logger.debug({type:"event",event:t,record:e})})),this.events.on(H,(e=>{const t=H;this.logger.info(`Emitting ${t}`),this.logger.debug({type:"event",event:t,record:e})})),this.core.heartbeat.on(n.Lx.pulse,(()=>{this.cleanup()}))}cleanup(){try{this.isInitialized();let e=!1;this.records.forEach((t=>{(0,c.toMiliseconds)(t.expiry||0)-Date.now()<=0&&(this.logger.info(`Deleting expired history log: ${t.id}`),this.records.delete(t.id),this.events.emit(H,t,!1),e=!0)})),e&&this.persist()}catch(e){this.logger.warn(e)}}isInitialized(){if(!this.initialized){const{message:e}=(0,g.kCb)("NOT_INITIALIZED",this.name);throw new Error(e)}}}class hi extends h.D3{constructor(e,t){super(e,t),this.core=e,this.logger=t,this.expirations=new Map,this.events=new s.EventEmitter,this.name="expirer",this.version="0.3",this.cached=[],this.initialized=!1,this.storagePrefix=_,this.init=async()=>{this.initialized||(this.logger.trace("Initialized"),await this.restore(),this.cached.forEach((e=>this.expirations.set(e.target,e))),this.cached=[],this.registerEventListeners(),this.initialized=!0)},this.has=e=>{try{const t=this.formatTarget(e);return typeof this.getExpiration(t)<"u"}catch{return!1}},this.set=(e,t)=>{this.isInitialized();const i=this.formatTarget(e),s={target:i,expiry:t};this.expirations.set(i,s),this.checkExpiry(i,s),this.events.emit(Y.created,{target:i,expiration:s})},this.get=e=>{this.isInitialized();const t=this.formatTarget(e);return this.getExpiration(t)},this.del=e=>{if(this.isInitialized(),this.has(e)){const t=this.formatTarget(e),i=this.getExpiration(t);this.expirations.delete(t),this.events.emit(Y.deleted,{target:t,expiration:i})}},this.on=(e,t)=>{this.events.on(e,t)},this.once=(e,t)=>{this.events.once(e,t)},this.off=(e,t)=>{this.events.off(e,t)},this.removeListener=(e,t)=>{this.events.removeListener(e,t)},this.logger=(0,a.Ep)(t,this.name)}get context(){return(0,a.Fd)(this.logger)}get storageKey(){return this.storagePrefix+this.version+this.core.customStoragePrefix+"//"+this.name}get length(){return this.expirations.size}get keys(){return Array.from(this.expirations.keys())}get values(){return Array.from(this.expirations.values())}formatTarget(e){if("string"==typeof e)return(0,g.Z42)(e);if("number"==typeof e)return(0,g.GqV)(e);const{message:t}=(0,g.kCb)("UNKNOWN_TYPE","Target type: "+typeof e);throw new Error(t)}async setExpirations(e){await this.core.storage.setItem(this.storageKey,e)}async getExpirations(){return await this.core.storage.getItem(this.storageKey)}async persist(){await this.setExpirations(this.values),this.events.emit(Y.sync)}async restore(){try{const e=await this.getExpirations();if(typeof e>"u"||!e.length)return;if(this.expirations.size){const{message:e}=(0,g.kCb)("RESTORE_WILL_OVERRIDE",this.name);throw this.logger.error(e),new Error(e)}this.cached=e,this.logger.debug(`Successfully Restored expirations for ${this.name}`),this.logger.trace({type:"method",method:"restore",expirations:this.values})}catch(e){this.logger.debug(`Failed to Restore expirations for ${this.name}`),this.logger.error(e)}}getExpiration(e){const t=this.expirations.get(e);if(!t){const{message:t}=(0,g.kCb)("NO_MATCHING_KEY",`${this.name}: ${e}`);throw this.logger.warn(t),new Error(t)}return t}checkExpiry(e,t){const{expiry:i}=t;(0,c.toMiliseconds)(i)-Date.now()<=0&&this.expire(e,t)}expire(e,t){this.expirations.delete(e),this.events.emit(Y.expired,{target:e,expiration:t})}checkExpirations(){this.core.relayer.connected&&this.expirations.forEach(((e,t)=>this.checkExpiry(t,e)))}registerEventListeners(){this.core.heartbeat.on(n.Lx.pulse,(()=>this.checkExpirations())),this.events.on(Y.created,(e=>{const t=Y.created;this.logger.info(`Emitting ${t}`),this.logger.debug({type:"event",event:t,data:e}),this.persist()})),this.events.on(Y.expired,(e=>{const t=Y.expired;this.logger.info(`Emitting ${t}`),this.logger.debug({type:"event",event:t,data:e}),this.persist()})),this.events.on(Y.deleted,(e=>{const t=Y.deleted;this.logger.info(`Emitting ${t}`),this.logger.debug({type:"event",event:t,data:e}),this.persist()}))}isInitialized(){if(!this.initialized){const{message:e}=(0,g.kCb)("NOT_INITIALIZED",this.name);throw new Error(e)}}}class ci extends h.Yo{constructor(e,t,i){super(e,t,i),this.core=e,this.logger=t,this.store=i,this.name="verify-api",this.verifyUrlV3=Z,this.storagePrefix=_,this.version=2,this.init=async()=>{var e;this.isDevEnv||(this.publicKey=await this.store.getItem(this.storeKey),this.publicKey&&(0,c.toMiliseconds)(null==(e=this.publicKey)?void 0:e.expiresAt)<Date.now()&&(this.logger.debug("verify v2 public key expired"),await this.removePublicKey()))},this.register=async e=>{if(!(0,g.jUY)()||this.isDevEnv)return;const t=window.location.origin,{id:i,decryptedId:s}=e,r=`${this.verifyUrlV3}/attestation?projectId=${this.core.projectId}&origin=${t}&id=${i}&decryptedId=${s}`;try{const e=(0,w.getDocument)(),t=this.startAbortTimer(5*c.ONE_SECOND),s=await new Promise(((s,n)=>{const o=()=>{window.removeEventListener("message",h),e.body.removeChild(a),n("attestation aborted")};this.abortController.signal.addEventListener("abort",o);const a=e.createElement("iframe");a.src=r,a.style.display="none",a.addEventListener("error",o,{signal:this.abortController.signal});const h=r=>{if(r.data&&"string"==typeof r.data)try{const n=JSON.parse(r.data);if("verify_attestation"===n.type){if((0,p.decodeJWT)(n.attestation).payload.id!==i)return;clearInterval(t),e.body.removeChild(a),this.abortController.signal.removeEventListener("abort",o),window.removeEventListener("message",h),s(null===n.attestation?"":n.attestation)}}catch(e){this.logger.warn(e)}};e.body.appendChild(a),window.addEventListener("message",h,{signal:this.abortController.signal})}));return this.logger.debug("jwt attestation",s),s}catch(e){this.logger.warn(e)}return""},this.resolve=async e=>{if(this.isDevEnv)return"";const{attestationId:t,hash:i,encryptedId:s}=e;if(""===t)return void this.logger.debug("resolve: attestationId is empty, skipping");if(t){if((0,p.decodeJWT)(t).payload.id!==s)return;const e=await this.isValidJwtAttestation(t);if(e)return e.isVerified?e:void this.logger.warn("resolve: jwt attestation: origin url not verified")}if(!i)return;const r=this.getVerifyUrl(e?.verifyUrl);return this.fetchAttestation(i,r)},this.fetchAttestation=async(e,t)=>{this.logger.debug(`resolving attestation: ${e} from url: ${t}`);const i=this.startAbortTimer(5*c.ONE_SECOND),s=await fetch(`${t}/attestation/${e}?v2Supported=true`,{signal:this.abortController.signal});return clearTimeout(i),200===s.status?await s.json():void 0},this.getVerifyUrl=e=>{let t=e||W;return Q.includes(t)||(this.logger.info(`verify url: ${t}, not included in trusted list, assigning default: ${W}`),t=W),t},this.fetchPublicKey=async()=>{try{this.logger.debug(`fetching public key from: ${this.verifyUrlV3}`);const e=this.startAbortTimer(c.FIVE_SECONDS),t=await fetch(`${this.verifyUrlV3}/public-key`,{signal:this.abortController.signal});return clearTimeout(e),await t.json()}catch(e){this.logger.warn(e)}},this.persistPublicKey=async e=>{this.logger.debug("persisting public key to local storage",e),await this.store.setItem(this.storeKey,e),this.publicKey=e},this.removePublicKey=async()=>{this.logger.debug("removing verify v2 public key from storage"),await this.store.removeItem(this.storeKey),this.publicKey=void 0},this.isValidJwtAttestation=async e=>{const t=await this.getPublicKey();try{if(t)return this.validateAttestation(e,t)}catch(e){this.logger.error(e),this.logger.warn("error validating attestation")}const i=await this.fetchAndPersistPublicKey();try{if(i)return this.validateAttestation(e,i)}catch(e){this.logger.error(e),this.logger.warn("error validating attestation")}},this.getPublicKey=async()=>this.publicKey?this.publicKey:await this.fetchAndPersistPublicKey(),this.fetchAndPersistPublicKey=async()=>{if(this.fetchPromise)return await this.fetchPromise,this.publicKey;this.fetchPromise=new Promise((async e=>{const t=await this.fetchPublicKey();t&&(await this.persistPublicKey(t),e(t))}));const e=await this.fetchPromise;return this.fetchPromise=void 0,e},this.validateAttestation=(e,t)=>{const i=(0,g.NbI)(e,t.publicKey),s={hasExpired:(0,c.toMiliseconds)(i.exp)<Date.now(),payload:i};if(s.hasExpired)throw this.logger.warn("resolve: jwt attestation expired"),new Error("JWT attestation expired");return{origin:s.payload.origin,isScam:s.payload.isScam,isVerified:s.payload.isVerified}},this.logger=(0,a.Ep)(t,this.name),this.abortController=new AbortController,this.isDevEnv=(0,g.h9F)(),this.init()}get storeKey(){return this.storagePrefix+this.version+this.core.customStoragePrefix+"//verify:public:key"}get context(){return(0,a.Fd)(this.logger)}startAbortTimer(e){return this.abortController=new AbortController,setTimeout((()=>this.abortController.abort()),(0,c.toMiliseconds)(e))}}class li extends h.pX{constructor(e,t){super(e,t),this.projectId=e,this.logger=t,this.context="echo",this.registerDeviceToken=async e=>{const{clientId:t,token:i,notificationType:s,enableEncrypted:r=!1}=e,n=`https://echo.walletconnect.com/${this.projectId}/clients`;await fetch(n,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({client_id:t,type:s,token:i,always_raw:r})})},this.logger=(0,a.Ep)(t,this.context)}}var pi=Object.defineProperty,gi=Object.getOwnPropertySymbols,di=Object.prototype.hasOwnProperty,ui=Object.prototype.propertyIsEnumerable,yi=(e,t,i)=>t in e?pi(e,t,{enumerable:!0,configurable:!0,writable:!0,value:i}):e[t]=i,mi=(e,t)=>{for(var i in t||(t={}))di.call(t,i)&&yi(e,i,t[i]);if(gi)for(var i of gi(t))ui.call(t,i)&&yi(e,i,t[i]);return e};class bi extends h.Mo{constructor(e,t,i=!0){super(e,t,i),this.core=e,this.logger=t,this.context="event-client",this.storagePrefix=_,this.storageVersion=.1,this.events=new Map,this.shouldPersist=!1,this.init=async()=>{if(!(0,g.h9F)())try{const e={eventId:(0,g.k$y)(),timestamp:Date.now(),domain:this.getAppDomain(),props:{event:"INIT",type:"",properties:{client_id:await this.core.crypto.getClientId(),user_agent:(0,g.oIp)(this.core.relayer.protocol,this.core.relayer.version,A)}}};await this.sendEvent([e])}catch(e){this.logger.warn(e)}},this.createEvent=e=>{const{event:t="ERROR",type:i="",properties:{topic:s,trace:r}}=e,n=(0,g.k$y)(),o=this.core.projectId||"",a=Date.now(),h=mi({eventId:n,timestamp:a,props:{event:t,type:i,properties:{topic:s,trace:r}},bundleId:o,domain:this.getAppDomain()},this.setMethods(n));return this.telemetryEnabled&&(this.events.set(n,h),this.shouldPersist=!0),h},this.getEvent=e=>{const{eventId:t,topic:i}=e;if(t)return this.events.get(t);const s=Array.from(this.events.values()).find((e=>e.props.properties.topic===i));return s?mi(mi({},s),this.setMethods(s.eventId)):void 0},this.deleteEvent=e=>{const{eventId:t}=e;this.events.delete(t),this.shouldPersist=!0},this.setEventListeners=()=>{this.core.heartbeat.on(n.Lx.pulse,(async()=>{this.shouldPersist&&await this.persist(),this.events.forEach((e=>{(0,c.fromMiliseconds)(Date.now())-(0,c.fromMiliseconds)(e.timestamp)>86400&&(this.events.delete(e.eventId),this.shouldPersist=!0)}))}))},this.setMethods=e=>({addTrace:t=>this.addTrace(e,t),setError:t=>this.setError(e,t)}),this.addTrace=(e,t)=>{const i=this.events.get(e);i&&(i.props.properties.trace.push(t),this.events.set(e,i),this.shouldPersist=!0)},this.setError=(e,t)=>{const i=this.events.get(e);i&&(i.props.type=t,i.timestamp=Date.now(),this.events.set(e,i),this.shouldPersist=!0)},this.persist=async()=>{await this.core.storage.setItem(this.storageKey,Array.from(this.events.values())),this.shouldPersist=!1},this.restore=async()=>{try{const e=await this.core.storage.getItem(this.storageKey)||[];if(!e.length)return;e.forEach((e=>{this.events.set(e.eventId,mi(mi({},e),this.setMethods(e.eventId)))}))}catch(e){this.logger.warn(e)}},this.submit=async()=>{if(!this.telemetryEnabled||0===this.events.size)return;const e=[];for(const[t,i]of this.events)i.props.type&&e.push(i);if(0!==e.length)try{if((await this.sendEvent(e)).ok)for(const t of e)this.events.delete(t.eventId),this.shouldPersist=!0}catch(e){this.logger.warn(e)}},this.sendEvent=async e=>{const t=this.getAppDomain()?"":"&sp=desktop";return await fetch(`https://pulse.walletconnect.org/batch?projectId=${this.core.projectId}&st=events_sdk&sv=js-${A}${t}`,{method:"POST",body:JSON.stringify(e)})},this.getAppDomain=()=>(0,g.DaH)().url,this.logger=(0,a.Ep)(t,this.context),this.telemetryEnabled=i,i?this.restore().then((async()=>{await this.submit(),this.setEventListeners()})):this.persist()}get storageKey(){return this.storagePrefix+this.storageVersion+this.core.customStoragePrefix+"//"+this.context}}var fi=Object.defineProperty,wi=Object.getOwnPropertySymbols,vi=Object.prototype.hasOwnProperty,_i=Object.prototype.propertyIsEnumerable,Ei=(e,t,i)=>t in e?fi(e,t,{enumerable:!0,configurable:!0,writable:!0,value:i}):e[t]=i,Ii=(e,t)=>{for(var i in t||(t={}))vi.call(t,i)&&Ei(e,i,t[i]);if(wi)for(var i of wi(t))_i.call(t,i)&&Ei(e,i,t[i]);return e};class xi extends h.N1{constructor(e){var t;super(e),this.protocol="wc",this.version=2,this.name=v,this.events=new s.EventEmitter,this.initialized=!1,this.on=(e,t)=>this.events.on(e,t),this.once=(e,t)=>this.events.once(e,t),this.off=(e,t)=>this.events.off(e,t),this.removeListener=(e,t)=>this.events.removeListener(e,t),this.dispatchEnvelope=({topic:e,message:t,sessionExists:i})=>{if(!e||!t)return;const s={topic:e,message:t,publishedAt:Date.now(),transportType:M.link_mode};this.relayer.onLinkMessageEvent(s,{sessionExists:i})},this.projectId=e?.projectId,this.relayUrl=e?.relayUrl||C,this.customStoragePrefix=null!=e&&e.customStoragePrefix?`:${e.customStoragePrefix}`:"";const i=(0,a.jI)({level:"string"==typeof e?.logger&&e.logger?e.logger:E}),{logger:r,chunkLoggerController:h}=(0,a.Rt)({opts:i,maxSizeInBytes:e?.maxLogBlobSizeInBytes,loggerOverride:e?.logger});this.logChunkController=h,null!=(t=this.logChunkController)&&t.downloadLogsBlobInBrowser&&(window.downloadLogsBlobInBrowser=async()=>{var e,t;null!=(e=this.logChunkController)&&e.downloadLogsBlobInBrowser&&(null==(t=this.logChunkController)||t.downloadLogsBlobInBrowser({clientId:await this.crypto.getClientId()}))}),this.logger=(0,a.Ep)(r,this.name),this.heartbeat=new n.C$,this.crypto=new Dt(this,this.logger,e?.keychain),this.history=new ai(this,this.logger),this.expirer=new hi(this,this.logger),this.storage=null!=e&&e.storage?e.storage:new o.Z(Ii(Ii({},I),e?.storageOptions)),this.relayer=new Qt({core:this,logger:this.logger,relayUrl:this.relayUrl,projectId:this.projectId}),this.pairing=new oi(this,this.logger),this.verify=new ci(this,this.logger,this.storage),this.echoClient=new li(this.projectId||"",this.logger),this.linkModeSupportedApps=[],this.eventClient=new bi(this,this.logger,e?.telemetryEnabled)}static async init(e){const t=new xi(e);await t.initialize();const i=await t.crypto.getClientId();return await t.storage.setItem("WALLETCONNECT_CLIENT_ID",i),t}get context(){return(0,a.Fd)(this.logger)}async start(){this.initialized||await this.initialize()}async getLogsBlob(){var e;return null==(e=this.logChunkController)?void 0:e.logsToBlob({clientId:await this.crypto.getClientId()})}async addLinkModeSupportedApp(e){this.linkModeSupportedApps.includes(e)||(this.linkModeSupportedApps.push(e),await this.storage.setItem(N,this.linkModeSupportedApps))}async initialize(){this.logger.trace("Initialized");try{await this.crypto.init(),await this.history.init(),await this.expirer.init(),await this.relayer.init(),await this.heartbeat.init(),await this.pairing.init(),this.eventClient.init(),this.linkModeSupportedApps=await this.storage.getItem(N)||[],this.initialized=!0,this.logger.info("Core Initialization Success")}catch(e){throw this.logger.warn(`Core Initialization Failure at epoch ${Date.now()}`,e),this.logger.error(e.message),e}}}const Pi=xi}}]);