(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[734],{69:function(e,t,s){"use strict";s.d(t,{iO:function(){return i}});const i={waku:{publish:"waku_publish",batchPublish:"waku_batchPublish",subscribe:"waku_subscribe",batchSubscribe:"waku_batchSubscribe",subscription:"waku_subscription",unsubscribe:"waku_unsubscribe",batchUnsubscribe:"waku_batchUnsubscribe",batchFetchMessages:"waku_batchFetchMessages"},irn:{publish:"irn_publish",batchPublish:"irn_batchPublish",subscribe:"irn_subscribe",batchSubscribe:"irn_batchSubscribe",subscription:"irn_subscription",unsubscribe:"irn_unsubscribe",batchUnsubscribe:"irn_batchUnsubscribe",batchFetchMessages:"irn_batchFetchMessages"},iridium:{publish:"iridium_publish",batchPublish:"iridium_batchPublish",subscribe:"iridium_subscribe",batchSubscribe:"iridium_batchSubscribe",subscription:"iridium_subscription",unsubscribe:"iridium_unsubscribe",batchUnsubscribe:"iridium_batchUnsubscribe",batchFetchMessages:"iridium_batchFetchMessages"}}},14374:function(e,t,s){"use strict";s.d(t,{decodeJWT:function(){return T},encodeIss:function(){return v},generateKeyPair:function(){return q},signJWT:function(){return N}});var i=s(99061),r=s(73250),n=s(2621);const o="EdDSA",a="JWT",c=".",l="base64url",p="utf8",h="utf8",d=":",u="did",g="key",y="base58btc",w="z",m="K36",_=32;var E=s(30620),f=s(56424),S=s(36201),R=s(73633);function I(e){return(0,R.D)((0,f.B)((0,S.m)(e,l),p))}function b(e){return(0,f.B)((0,S.m)((0,R.u)(e),p),l)}function v(e){const t=(0,S.m)(m,y),s=w+(0,f.B)((0,E.z)([t,e]),y);return[u,g,s].join(d)}function T(e){const t=e.split(c);var s;return{header:I(t[0]),payload:I(t[1]),signature:(s=t[2],(0,S.m)(s,l)),data:(0,S.m)(t.slice(0,2).join(c),h)}}function q(e=(0,r.randomBytes)(_)){return i._w(e)}async function N(e,t,s,r,p=(0,n.fromMiliseconds)(Date.now())){const d={alg:o,typ:a},u={iss:v(r.publicKey),sub:e,aud:t,iat:p,exp:p+s},g=(y={header:d,payload:u},(0,S.m)([b(y.header),b(y.payload)].join(c),h));var y;return function(e){return[b(e.header),b(e.payload),(t=e.signature,(0,f.B)(t,l))].join(c);var t}({header:d,payload:u,signature:i.Xx(r.secretKey,g)})}s(26090)},26090:function(){},73633:function(e,t,s){"use strict";s.d(t,{D:function(){return n},u:function(){return o}});const i=e=>JSON.stringify(e,((e,t)=>"bigint"==typeof t?t.toString()+"n":t)),r=e=>{const t=e.replace(/([\[:])?(\d{17,}|(?:[9](?:[1-9]07199254740991|0[1-9]7199254740991|00[8-9]199254740991|007[2-9]99254740991|007199[3-9]54740991|0071992[6-9]4740991|00719925[5-9]740991|007199254[8-9]40991|0071992547[5-9]0991|00719925474[1-9]991|00719925474099[2-9])))([,\}\]])/g,'$1"$2n"$3');return JSON.parse(t,((e,t)=>"string"==typeof t&&t.match(/^\d+n$/)?BigInt(t.substring(0,t.length-1)):t))};function n(e){if("string"!=typeof e)throw new Error("Cannot safe json parse value of type "+typeof e);try{return r(e)}catch(t){return e}}function o(e){return"string"==typeof e?e:i(e)||""}},78348:function(e,t,s){"use strict";s.d(t,{ZP:function(){return H},lO:function(){return w}});var i=s(32980),r=s(11899),n=s(62863),o=s(17486),a=s(25788),c=s.n(a),l=s(2621),p=s(78186);const h="client",d=`wc@2:${h}:`,u=h,g="error",y="WALLETCONNECT_DEEPLINK_CHOICE",w="Proposal expired",m=l.SEVEN_DAYS,_={wc_sessionPropose:{req:{ttl:l.FIVE_MINUTES,prompt:!0,tag:1100},res:{ttl:l.FIVE_MINUTES,prompt:!1,tag:1101},reject:{ttl:l.FIVE_MINUTES,prompt:!1,tag:1120},autoReject:{ttl:l.FIVE_MINUTES,prompt:!1,tag:1121}},wc_sessionSettle:{req:{ttl:l.FIVE_MINUTES,prompt:!1,tag:1102},res:{ttl:l.FIVE_MINUTES,prompt:!1,tag:1103}},wc_sessionUpdate:{req:{ttl:l.ONE_DAY,prompt:!1,tag:1104},res:{ttl:l.ONE_DAY,prompt:!1,tag:1105}},wc_sessionExtend:{req:{ttl:l.ONE_DAY,prompt:!1,tag:1106},res:{ttl:l.ONE_DAY,prompt:!1,tag:1107}},wc_sessionRequest:{req:{ttl:l.FIVE_MINUTES,prompt:!0,tag:1108},res:{ttl:l.FIVE_MINUTES,prompt:!1,tag:1109}},wc_sessionEvent:{req:{ttl:l.FIVE_MINUTES,prompt:!0,tag:1110},res:{ttl:l.FIVE_MINUTES,prompt:!1,tag:1111}},wc_sessionDelete:{req:{ttl:l.ONE_DAY,prompt:!1,tag:1112},res:{ttl:l.ONE_DAY,prompt:!1,tag:1113}},wc_sessionPing:{req:{ttl:l.ONE_DAY,prompt:!1,tag:1114},res:{ttl:l.ONE_DAY,prompt:!1,tag:1115}},wc_sessionAuthenticate:{req:{ttl:l.ONE_HOUR,prompt:!0,tag:1116},res:{ttl:l.ONE_HOUR,prompt:!1,tag:1117},reject:{ttl:l.FIVE_MINUTES,prompt:!1,tag:1118},autoReject:{ttl:l.FIVE_MINUTES,prompt:!1,tag:1119}}},E={min:l.FIVE_MINUTES,max:l.SEVEN_DAYS},f="IDLE",S="ACTIVE",R=["wc_sessionPropose","wc_sessionRequest","wc_authRequest","wc_sessionAuthenticate"],I="wc@1.5:auth:",b=`${I}:PUB_KEY`;var v=Object.defineProperty,T=Object.defineProperties,q=Object.getOwnPropertyDescriptors,N=Object.getOwnPropertySymbols,O=Object.prototype.hasOwnProperty,P=Object.prototype.propertyIsEnumerable,D=(e,t,s)=>t in e?v(e,t,{enumerable:!0,configurable:!0,writable:!0,value:s}):e[t]=s,M=(e,t)=>{for(var s in t||(t={}))O.call(t,s)&&D(e,s,t[s]);if(N)for(var s of N(t))P.call(t,s)&&D(e,s,t[s]);return e},k=(e,t)=>T(e,q(t));class C extends n.W3{constructor(e){super(e),this.name="engine",this.events=new(c()),this.initialized=!1,this.requestQueue={state:f,queue:[]},this.sessionRequestQueue={state:f,queue:[]},this.requestQueueDelay=l.ONE_SECOND,this.expectedPairingMethodMap=new Map,this.recentlyDeletedMap=new Map,this.recentlyDeletedLimit=200,this.relayMessageCache=[],this.init=async()=>{this.initialized||(await this.cleanup(),this.registerRelayerEvents(),this.registerExpirerEvents(),this.registerPairingEvents(),await this.registerLinkModeListeners(),this.client.core.pairing.register({methods:Object.keys(_)}),this.initialized=!0,setTimeout((()=>{this.sessionRequestQueue.queue=this.getPendingSessionRequests(),this.processSessionRequestQueue()}),(0,l.toMiliseconds)(this.requestQueueDelay)))},this.connect=async e=>{this.isInitialized(),await this.confirmOnlineStateOrThrow();const t=k(M({},e),{requiredNamespaces:e.requiredNamespaces||{},optionalNamespaces:e.optionalNamespaces||{}});await this.isValidConnect(t);const{pairingTopic:s,requiredNamespaces:r,optionalNamespaces:n,sessionProperties:a,relays:c}=t;let p,h=s,d=!1;try{h&&(d=this.client.core.pairing.pairings.get(h).active)}catch(e){throw this.client.logger.error(`connect() -> pairing.get(${h}) failed`),e}if(!h||!d){const{topic:e,uri:t}=await this.client.core.pairing.create();h=e,p=t}if(!h){const{message:e}=(0,o.kCb)("NO_MATCHING_KEY",`connect() pairing topic: ${h}`);throw new Error(e)}const u=await this.client.core.crypto.generateKeyPair(),g=_.wc_sessionPropose.req.ttl||l.FIVE_MINUTES,y=(0,o.gn4)(g),m=M({requiredNamespaces:r,optionalNamespaces:n,relays:c??[{protocol:i.ZF}],proposer:{publicKey:u,metadata:this.client.metadata},expiryTimestamp:y,pairingTopic:h},a&&{sessionProperties:a}),{reject:E,resolve:f,done:S}=(0,o.H1S)(g,w);this.events.once((0,o.E0T)("session_connect"),(async({error:e,session:t})=>{if(e)E(e);else if(t){t.self.publicKey=u;const e=k(M({},t),{pairingTopic:m.pairingTopic,requiredNamespaces:m.requiredNamespaces,optionalNamespaces:m.optionalNamespaces,transportType:i.QZ.relay});await this.client.session.set(t.topic,e),await this.setExpiry(t.topic,t.expiry),h&&await this.client.core.pairing.updateMetadata({topic:h,metadata:t.peer.metadata}),this.cleanupDuplicatePairings(e),f(e)}}));const R=await this.sendRequest({topic:h,method:"wc_sessionPropose",params:m,throwOnFailedPublish:!0});return await this.setProposal(R,M({id:R},m)),{uri:p,approval:S}},this.pair=async e=>{this.isInitialized(),await this.confirmOnlineStateOrThrow();try{return await this.client.core.pairing.pair(e)}catch(e){throw this.client.logger.error("pair() failed"),e}},this.approve=async e=>{var t,s,r;const n=this.client.core.eventClient.createEvent({properties:{topic:null==(t=e?.id)?void 0:t.toString(),trace:[i.Wk.session_approve_started]}});try{this.isInitialized(),await this.confirmOnlineStateOrThrow()}catch(e){throw n.setError(i.cQ.no_internet_connection),e}try{await this.isValidProposalId(e?.id)}catch(t){throw this.client.logger.error(`approve() -> proposal.get(${e?.id}) failed`),n.setError(i.cQ.proposal_not_found),t}try{await this.isValidApprove(e)}catch(e){throw this.client.logger.error("approve() -> isValidApprove() failed"),n.setError(i.cQ.session_approve_namespace_validation_failure),e}const{id:a,relayProtocol:c,namespaces:l,sessionProperties:p,sessionConfig:h}=e,d=this.client.proposal.get(a);this.client.core.eventClient.deleteEvent({eventId:n.eventId});const{pairingTopic:u,proposer:g,requiredNamespaces:y,optionalNamespaces:w}=d;let _=null==(s=this.client.core.eventClient)?void 0:s.getEvent({topic:u});_||(_=null==(r=this.client.core.eventClient)?void 0:r.createEvent({type:i.Wk.session_approve_started,properties:{topic:u,trace:[i.Wk.session_approve_started,i.Wk.session_namespaces_validation_success]}}));const E=await this.client.core.crypto.generateKeyPair(),f=g.publicKey,S=await this.client.core.crypto.generateSharedKey(E,f),R=M(M({relay:{protocol:c??"irn"},namespaces:l,controller:{publicKey:E,metadata:this.client.metadata},expiry:(0,o.gn4)(m)},p&&{sessionProperties:p}),h&&{sessionConfig:h}),I=i.QZ.relay;_.addTrace(i.Wk.subscribing_session_topic);try{await this.client.core.relayer.subscribe(S,{transportType:I})}catch(e){throw _.setError(i.cQ.subscribe_session_topic_failure),e}_.addTrace(i.Wk.subscribe_session_topic_success);const b=k(M({},R),{topic:S,requiredNamespaces:y,optionalNamespaces:w,pairingTopic:u,acknowledged:!1,self:R.controller,peer:{publicKey:g.publicKey,metadata:g.metadata},controller:E,transportType:i.QZ.relay});await this.client.session.set(S,b),_.addTrace(i.Wk.store_session);try{_.addTrace(i.Wk.publishing_session_settle),await this.sendRequest({topic:S,method:"wc_sessionSettle",params:R,throwOnFailedPublish:!0}).catch((e=>{throw _?.setError(i.cQ.session_settle_publish_failure),e})),_.addTrace(i.Wk.session_settle_publish_success),_.addTrace(i.Wk.publishing_session_approve),await this.sendResult({id:a,topic:u,result:{relay:{protocol:c??"irn"},responderPublicKey:E},throwOnFailedPublish:!0}).catch((e=>{throw _?.setError(i.cQ.session_approve_publish_failure),e})),_.addTrace(i.Wk.session_approve_publish_success)}catch(e){throw this.client.logger.error(e),this.client.session.delete(S,(0,o.D6H)("USER_DISCONNECTED")),await this.client.core.relayer.unsubscribe(S),e}return this.client.core.eventClient.deleteEvent({eventId:_.eventId}),await this.client.core.pairing.updateMetadata({topic:u,metadata:g.metadata}),await this.client.proposal.delete(a,(0,o.D6H)("USER_DISCONNECTED")),await this.client.core.pairing.activate({topic:u}),await this.setExpiry(S,(0,o.gn4)(m)),{topic:S,acknowledged:()=>Promise.resolve(this.client.session.get(S))}},this.reject=async e=>{this.isInitialized(),await this.confirmOnlineStateOrThrow();try{await this.isValidReject(e)}catch(e){throw this.client.logger.error("reject() -> isValidReject() failed"),e}const{id:t,reason:s}=e;let i;try{i=this.client.proposal.get(t).pairingTopic}catch(e){throw this.client.logger.error(`reject() -> proposal.get(${t}) failed`),e}i&&(await this.sendError({id:t,topic:i,error:s,rpcOpts:_.wc_sessionPropose.reject}),await this.client.proposal.delete(t,(0,o.D6H)("USER_DISCONNECTED")))},this.update=async e=>{this.isInitialized(),await this.confirmOnlineStateOrThrow();try{await this.isValidUpdate(e)}catch(e){throw this.client.logger.error("update() -> isValidUpdate() failed"),e}const{topic:t,namespaces:s}=e,{done:i,resolve:r,reject:n}=(0,o.H1S)(),a=(0,p.payloadId)(),c=(0,p.getBigIntRpcId)().toString(),l=this.client.session.get(t).namespaces;return this.events.once((0,o.E0T)("session_update",a),(({error:e})=>{e?n(e):r()})),await this.client.session.update(t,{namespaces:s}),await this.sendRequest({topic:t,method:"wc_sessionUpdate",params:{namespaces:s},throwOnFailedPublish:!0,clientRpcId:a,relayRpcId:c}).catch((e=>{this.client.logger.error(e),this.client.session.update(t,{namespaces:l}),n(e)})),{acknowledged:i}},this.extend=async e=>{this.isInitialized(),await this.confirmOnlineStateOrThrow();try{await this.isValidExtend(e)}catch(e){throw this.client.logger.error("extend() -> isValidExtend() failed"),e}const{topic:t}=e,s=(0,p.payloadId)(),{done:i,resolve:r,reject:n}=(0,o.H1S)();return this.events.once((0,o.E0T)("session_extend",s),(({error:e})=>{e?n(e):r()})),await this.setExpiry(t,(0,o.gn4)(m)),this.sendRequest({topic:t,method:"wc_sessionExtend",params:{},clientRpcId:s,throwOnFailedPublish:!0}).catch((e=>{n(e)})),{acknowledged:i}},this.request=async e=>{this.isInitialized();try{await this.isValidRequest(e)}catch(e){throw this.client.logger.error("request() -> isValidRequest() failed"),e}const{chainId:t,request:s,topic:r,expiry:n=_.wc_sessionRequest.req.ttl}=e,a=this.client.session.get(r);a?.transportType===i.QZ.relay&&await this.confirmOnlineStateOrThrow();const c=(0,p.payloadId)(),l=(0,p.getBigIntRpcId)().toString(),{done:h,resolve:d,reject:u}=(0,o.H1S)(n,"Request expired. Please try again.");this.events.once((0,o.E0T)("session_request",c),(({error:e,result:t})=>{e?u(e):d(t)}));const g=this.getAppLinkIfEnabled(a.peer.metadata,a.transportType);return g?(await this.sendRequest({clientRpcId:c,relayRpcId:l,topic:r,method:"wc_sessionRequest",params:{request:k(M({},s),{expiryTimestamp:(0,o.gn4)(n)}),chainId:t},expiry:n,throwOnFailedPublish:!0,appLink:g}).catch((e=>u(e))),this.client.events.emit("session_request_sent",{topic:r,request:s,chainId:t,id:c}),await h()):await Promise.all([new Promise((async e=>{await this.sendRequest({clientRpcId:c,relayRpcId:l,topic:r,method:"wc_sessionRequest",params:{request:k(M({},s),{expiryTimestamp:(0,o.gn4)(n)}),chainId:t},expiry:n,throwOnFailedPublish:!0}).catch((e=>u(e))),this.client.events.emit("session_request_sent",{topic:r,request:s,chainId:t,id:c}),e()})),new Promise((async e=>{var t;if(null==(t=a.sessionConfig)||!t.disableDeepLink){const e=await(0,o.bW6)(this.client.core.storage,y);await(0,o.HhN)({id:c,topic:r,wcDeepLink:e})}e()})),h()]).then((e=>e[2]))},this.respond=async e=>{this.isInitialized(),await this.isValidRespond(e);const{topic:t,response:s}=e,{id:r}=s,n=this.client.session.get(t);n.transportType===i.QZ.relay&&await this.confirmOnlineStateOrThrow();const o=this.getAppLinkIfEnabled(n.peer.metadata,n.transportType);(0,p.isJsonRpcResult)(s)?await this.sendResult({id:r,topic:t,result:s.result,throwOnFailedPublish:!0,appLink:o}):(0,p.isJsonRpcError)(s)&&await this.sendError({id:r,topic:t,error:s.error,appLink:o}),this.cleanupAfterResponse(e)},this.ping=async e=>{this.isInitialized(),await this.confirmOnlineStateOrThrow();try{await this.isValidPing(e)}catch(e){throw this.client.logger.error("ping() -> isValidPing() failed"),e}const{topic:t}=e;if(this.client.session.keys.includes(t)){const e=(0,p.payloadId)(),s=(0,p.getBigIntRpcId)().toString(),{done:i,resolve:r,reject:n}=(0,o.H1S)();this.events.once((0,o.E0T)("session_ping",e),(({error:e})=>{e?n(e):r()})),await Promise.all([this.sendRequest({topic:t,method:"wc_sessionPing",params:{},throwOnFailedPublish:!0,clientRpcId:e,relayRpcId:s}),i()])}else this.client.core.pairing.pairings.keys.includes(t)&&await this.client.core.pairing.ping({topic:t})},this.emit=async e=>{this.isInitialized(),await this.confirmOnlineStateOrThrow(),await this.isValidEmit(e);const{topic:t,event:s,chainId:i}=e,r=(0,p.getBigIntRpcId)().toString();await this.sendRequest({topic:t,method:"wc_sessionEvent",params:{event:s,chainId:i},throwOnFailedPublish:!0,relayRpcId:r})},this.disconnect=async e=>{this.isInitialized(),await this.confirmOnlineStateOrThrow(),await this.isValidDisconnect(e);const{topic:t}=e;if(this.client.session.keys.includes(t))await this.sendRequest({topic:t,method:"wc_sessionDelete",params:(0,o.D6H)("USER_DISCONNECTED"),throwOnFailedPublish:!0}),await this.deleteSession({topic:t,emitEvent:!1});else{if(!this.client.core.pairing.pairings.keys.includes(t)){const{message:e}=(0,o.kCb)("MISMATCHED_TOPIC",`Session or pairing topic not found: ${t}`);throw new Error(e)}await this.client.core.pairing.disconnect({topic:t})}},this.find=e=>(this.isInitialized(),this.client.session.getAll().filter((t=>(0,o.Ih8)(t,e)))),this.getPendingSessionRequests=()=>this.client.pendingRequest.getAll(),this.authenticate=async(e,t)=>{var s;this.isInitialized(),this.isValidAuthenticate(e);const r=t&&this.client.core.linkModeSupportedApps.includes(t)&&(null==(s=this.client.metadata.redirect)?void 0:s.linkMode),n=r?i.QZ.link_mode:i.QZ.relay;n===i.QZ.relay&&await this.confirmOnlineStateOrThrow();const{chains:a,statement:c="",uri:l,domain:h,nonce:d,type:u,exp:g,nbf:y,methods:w=[],expiry:E}=e,f=[...e.resources||[]],{topic:S,uri:R}=await this.client.core.pairing.create({methods:["wc_sessionAuthenticate"],transportType:n});this.client.logger.info({message:"Generated new pairing",pairing:{topic:S,uri:R}});const I=await this.client.core.crypto.generateKeyPair(),v=(0,o.YmJ)(I);if(await Promise.all([this.client.auth.authKeys.set(b,{responseTopic:v,publicKey:I}),this.client.auth.pairingTopics.set(v,{topic:v,pairingTopic:S})]),await this.client.core.relayer.subscribe(v,{transportType:n}),this.client.logger.info(`sending request to new pairing topic: ${S}`),w.length>0){const{namespace:e}=(0,o.DQe)(a[0]);let t=(0,o.IkP)(e,"request",w);(0,o.hA9)(f)&&(t=(0,o.qJM)(t,f.pop())),f.push(t)}const T=E&&E>_.wc_sessionAuthenticate.req.ttl?E:_.wc_sessionAuthenticate.req.ttl,q={authPayload:{type:u??"caip122",chains:a,statement:c,aud:l,domain:h,version:"1",nonce:d,iat:(new Date).toISOString(),exp:g,nbf:y,resources:f},requester:{publicKey:I,metadata:this.client.metadata},expiryTimestamp:(0,o.gn4)(T)},N={requiredNamespaces:{},optionalNamespaces:{eip155:{chains:a,methods:[...new Set(["personal_sign",...w])],events:["chainChanged","accountsChanged"]}},relays:[{protocol:"irn"}],pairingTopic:S,proposer:{publicKey:I,metadata:this.client.metadata},expiryTimestamp:(0,o.gn4)(_.wc_sessionPropose.req.ttl)},{done:O,resolve:P,reject:D}=(0,o.H1S)(T,"Request expired"),C=async({error:e,session:t})=>{if(this.events.off((0,o.E0T)("session_request",x),A),e)D(e);else if(t){t.self.publicKey=I,await this.client.session.set(t.topic,t),await this.setExpiry(t.topic,t.expiry),S&&await this.client.core.pairing.updateMetadata({topic:S,metadata:t.peer.metadata});const e=this.client.session.get(t.topic);await this.deleteProposal(V),P({session:e})}},A=async e=>{var s,r,a;if(await this.deletePendingAuthRequest(x,{message:"fulfilled",code:0}),e.error){const t=(0,o.D6H)("WC_METHOD_UNSUPPORTED","wc_sessionAuthenticate");return e.error.code===t.code?void 0:(this.events.off((0,o.E0T)("session_connect"),C),D(e.error.message))}await this.deleteProposal(V),this.events.off((0,o.E0T)("session_connect"),C);const{cacaos:c,responder:l}=e.result,p=[],h=[];for(const e of c){await(0,o.c4l)({cacao:e,projectId:this.client.core.projectId})||(this.client.logger.error(e,"Signature verification failed"),D((0,o.D6H)("SESSION_SETTLEMENT_FAILED","Signature verification failed")));const{p:t}=e,s=(0,o.hA9)(t.resources),i=[(0,o.DJo)(t.iss)],r=(0,o.NmC)(t.iss);if(s){const e=(0,o.Y31)(s),t=(0,o.ouN)(s);p.push(...e),i.push(...t)}for(const e of i)h.push(`${e}:${r}`)}const d=await this.client.core.crypto.generateSharedKey(I,l.publicKey);let u;p.length>0&&(u={topic:d,acknowledged:!0,self:{publicKey:I,metadata:this.client.metadata},peer:l,controller:l.publicKey,expiry:(0,o.gn4)(m),requiredNamespaces:{},optionalNamespaces:{},relay:{protocol:"irn"},pairingTopic:S,namespaces:(0,o.E12)([...new Set(p)],[...new Set(h)]),transportType:n},await this.client.core.relayer.subscribe(d,{transportType:n}),await this.client.session.set(d,u),S&&await this.client.core.pairing.updateMetadata({topic:S,metadata:l.metadata}),u=this.client.session.get(d)),null!=(s=this.client.metadata.redirect)&&s.linkMode&&null!=(r=l.metadata.redirect)&&r.linkMode&&null!=(a=l.metadata.redirect)&&a.universal&&t&&(this.client.core.addLinkModeSupportedApp(l.metadata.redirect.universal),this.client.session.update(d,{transportType:i.QZ.link_mode})),P({auths:c,session:u})},x=(0,p.payloadId)(),V=(0,p.payloadId)();let U;this.events.once((0,o.E0T)("session_connect"),C),this.events.once((0,o.E0T)("session_request",x),A);try{if(r){const e=(0,p.formatJsonRpcRequest)("wc_sessionAuthenticate",q,x);this.client.core.history.set(S,e);const s=await this.client.core.crypto.encode("",e,{type:o.FpL,encoding:o.zl_});U=(0,o.L9d)(t,S,s)}else await Promise.all([this.sendRequest({topic:S,method:"wc_sessionAuthenticate",params:q,expiry:e.expiry,throwOnFailedPublish:!0,clientRpcId:x}),this.sendRequest({topic:S,method:"wc_sessionPropose",params:N,expiry:_.wc_sessionPropose.req.ttl,throwOnFailedPublish:!0,clientRpcId:V})])}catch(e){throw this.events.off((0,o.E0T)("session_connect"),C),this.events.off((0,o.E0T)("session_request",x),A),e}return await this.setProposal(V,M({id:V},N)),await this.setAuthRequest(x,{request:k(M({},q),{verifyContext:{}}),pairingTopic:S,transportType:n}),{uri:U??R,response:O}},this.approveSessionAuthenticate=async e=>{const{id:t,auths:s}=e,r=this.client.core.eventClient.createEvent({properties:{topic:t.toString(),trace:[i.t7.authenticated_session_approve_started]}});try{this.isInitialized()}catch(e){throw r.setError(i.E9.no_internet_connection),e}const n=this.getPendingAuthRequest(t);if(!n)throw r.setError(i.E9.authenticated_session_pending_request_not_found),new Error(`Could not find pending auth request with id ${t}`);const a=n.transportType||i.QZ.relay;a===i.QZ.relay&&await this.confirmOnlineStateOrThrow();const c=n.requester.publicKey,l=await this.client.core.crypto.generateKeyPair(),p=(0,o.YmJ)(c),h={type:o.rVF,receiverPublicKey:c,senderPublicKey:l},d=[],u=[];for(const e of s){if(!await(0,o.c4l)({cacao:e,projectId:this.client.core.projectId})){r.setError(i.E9.invalid_cacao);const e=(0,o.D6H)("SESSION_SETTLEMENT_FAILED","Signature verification failed");throw await this.sendError({id:t,topic:p,error:e,encodeOpts:h}),new Error(e.message)}r.addTrace(i.t7.cacaos_verified);const{p:s}=e,n=(0,o.hA9)(s.resources),a=[(0,o.DJo)(s.iss)],c=(0,o.NmC)(s.iss);if(n){const e=(0,o.Y31)(n),t=(0,o.ouN)(n);d.push(...e),a.push(...t)}for(const e of a)u.push(`${e}:${c}`)}const g=await this.client.core.crypto.generateSharedKey(l,c);let y;if(r.addTrace(i.t7.create_authenticated_session_topic),d?.length>0){y={topic:g,acknowledged:!0,self:{publicKey:l,metadata:this.client.metadata},peer:{publicKey:c,metadata:n.requester.metadata},controller:c,expiry:(0,o.gn4)(m),authentication:s,requiredNamespaces:{},optionalNamespaces:{},relay:{protocol:"irn"},pairingTopic:n.pairingTopic,namespaces:(0,o.E12)([...new Set(d)],[...new Set(u)]),transportType:a},r.addTrace(i.t7.subscribing_authenticated_session_topic);try{await this.client.core.relayer.subscribe(g,{transportType:a})}catch(e){throw r.setError(i.E9.subscribe_authenticated_session_topic_failure),e}r.addTrace(i.t7.subscribe_authenticated_session_topic_success),await this.client.session.set(g,y),r.addTrace(i.t7.store_authenticated_session),await this.client.core.pairing.updateMetadata({topic:n.pairingTopic,metadata:n.requester.metadata})}r.addTrace(i.t7.publishing_authenticated_session_approve);try{await this.sendResult({topic:p,id:t,result:{cacaos:s,responder:{publicKey:l,metadata:this.client.metadata}},encodeOpts:h,throwOnFailedPublish:!0,appLink:this.getAppLinkIfEnabled(n.requester.metadata,a)})}catch(e){throw r.setError(i.E9.authenticated_session_approve_publish_failure),e}return await this.client.auth.requests.delete(t,{message:"fulfilled",code:0}),await this.client.core.pairing.activate({topic:n.pairingTopic}),this.client.core.eventClient.deleteEvent({eventId:r.eventId}),{session:y}},this.rejectSessionAuthenticate=async e=>{this.isInitialized();const{id:t,reason:s}=e,r=this.getPendingAuthRequest(t);if(!r)throw new Error(`Could not find pending auth request with id ${t}`);r.transportType===i.QZ.relay&&await this.confirmOnlineStateOrThrow();const n=r.requester.publicKey,a=await this.client.core.crypto.generateKeyPair(),c=(0,o.YmJ)(n),l={type:o.rVF,receiverPublicKey:n,senderPublicKey:a};await this.sendError({id:t,topic:c,error:s,encodeOpts:l,rpcOpts:_.wc_sessionAuthenticate.reject,appLink:this.getAppLinkIfEnabled(r.requester.metadata,r.transportType)}),await this.client.auth.requests.delete(t,{message:"rejected",code:0}),await this.client.proposal.delete(t,(0,o.D6H)("USER_DISCONNECTED"))},this.formatAuthMessage=e=>{this.isInitialized();const{request:t,iss:s}=e;return(0,o.wvx)(t,s)},this.processRelayMessageCache=()=>{setTimeout((async()=>{if(0!==this.relayMessageCache.length)for(;this.relayMessageCache.length>0;)try{const e=this.relayMessageCache.shift();e&&await this.onRelayMessage(e)}catch(e){this.client.logger.error(e)}}),50)},this.cleanupDuplicatePairings=async e=>{if(e.pairingTopic)try{const t=this.client.core.pairing.pairings.get(e.pairingTopic),s=this.client.core.pairing.pairings.getAll().filter((s=>{var i,r;return(null==(i=s.peerMetadata)?void 0:i.url)&&(null==(r=s.peerMetadata)?void 0:r.url)===e.peer.metadata.url&&s.topic&&s.topic!==t.topic}));if(0===s.length)return;this.client.logger.info(`Cleaning up ${s.length} duplicate pairing(s)`),await Promise.all(s.map((e=>this.client.core.pairing.disconnect({topic:e.topic})))),this.client.logger.info("Duplicate pairings clean up finished")}catch(e){this.client.logger.error(e)}},this.deleteSession=async e=>{var t;const{topic:s,expirerHasDeleted:i=!1,emitEvent:r=!0,id:n=0}=e,{self:a}=this.client.session.get(s);await this.client.core.relayer.unsubscribe(s),await this.client.session.delete(s,(0,o.D6H)("USER_DISCONNECTED")),this.addToRecentlyDeleted(s,"session"),this.client.core.crypto.keychain.has(a.publicKey)&&await this.client.core.crypto.deleteKeyPair(a.publicKey),this.client.core.crypto.keychain.has(s)&&await this.client.core.crypto.deleteSymKey(s),i||this.client.core.expirer.del(s),this.client.core.storage.removeItem(y).catch((e=>this.client.logger.warn(e))),this.getPendingSessionRequests().forEach((e=>{e.topic===s&&this.deletePendingSessionRequest(e.id,(0,o.D6H)("USER_DISCONNECTED"))})),s===(null==(t=this.sessionRequestQueue.queue[0])?void 0:t.topic)&&(this.sessionRequestQueue.state=f),r&&this.client.events.emit("session_delete",{id:n,topic:s})},this.deleteProposal=async(e,t)=>{if(t)try{const t=this.client.proposal.get(e),s=this.client.core.eventClient.getEvent({topic:t.pairingTopic});s?.setError(i.cQ.proposal_expired)}catch{}await Promise.all([this.client.proposal.delete(e,(0,o.D6H)("USER_DISCONNECTED")),t?Promise.resolve():this.client.core.expirer.del(e)]),this.addToRecentlyDeleted(e,"proposal")},this.deletePendingSessionRequest=async(e,t,s=!1)=>{await Promise.all([this.client.pendingRequest.delete(e,t),s?Promise.resolve():this.client.core.expirer.del(e)]),this.addToRecentlyDeleted(e,"request"),this.sessionRequestQueue.queue=this.sessionRequestQueue.queue.filter((t=>t.id!==e)),s&&(this.sessionRequestQueue.state=f,this.client.events.emit("session_request_expire",{id:e}))},this.deletePendingAuthRequest=async(e,t,s=!1)=>{await Promise.all([this.client.auth.requests.delete(e,t),s?Promise.resolve():this.client.core.expirer.del(e)])},this.setExpiry=async(e,t)=>{this.client.session.keys.includes(e)&&(this.client.core.expirer.set(e,t),await this.client.session.update(e,{expiry:t}))},this.setProposal=async(e,t)=>{this.client.core.expirer.set(e,(0,o.gn4)(_.wc_sessionPropose.req.ttl)),await this.client.proposal.set(e,t)},this.setAuthRequest=async(e,t)=>{const{request:s,pairingTopic:r,transportType:n=i.QZ.relay}=t;this.client.core.expirer.set(e,s.expiryTimestamp),await this.client.auth.requests.set(e,{authPayload:s.authPayload,requester:s.requester,expiryTimestamp:s.expiryTimestamp,id:e,pairingTopic:r,verifyContext:s.verifyContext,transportType:n})},this.setPendingSessionRequest=async e=>{const{id:t,topic:s,params:i,verifyContext:r}=e,n=i.request.expiryTimestamp||(0,o.gn4)(_.wc_sessionRequest.req.ttl);this.client.core.expirer.set(t,n),await this.client.pendingRequest.set(t,{id:t,topic:s,params:i,verifyContext:r})},this.sendRequest=async e=>{const{topic:t,method:i,params:r,expiry:n,relayRpcId:a,clientRpcId:c,throwOnFailedPublish:l,appLink:h}=e,d=(0,p.formatJsonRpcRequest)(i,r,c);let u;const g=!!h;try{const e=g?o.zl_:o.$dT;u=await this.client.core.crypto.encode(t,d,{encoding:e})}catch(e){throw await this.cleanup(),this.client.logger.error(`sendRequest() -> core.crypto.encode() for topic ${t} failed`),e}let y;if(R.includes(i)){const e=(0,o.rjm)(JSON.stringify(d)),t=(0,o.rjm)(u);y=await this.client.core.verify.register({id:t,decryptedId:e})}const w=_[i].req;if(w.attestation=y,n&&(w.ttl=n),a&&(w.id=a),this.client.core.history.set(t,d),g){const e=(0,o.L9d)(h,t,u);await s.g.Linking.openURL(e,this.client.name)}else{const e=_[i].req;n&&(e.ttl=n),a&&(e.id=a),l?(e.internal=k(M({},e.internal),{throwOnFailedPublish:!0}),await this.client.core.relayer.publish(t,u,e)):this.client.core.relayer.publish(t,u,e).catch((e=>this.client.logger.error(e)))}return d.id},this.sendResult=async e=>{const{id:t,topic:i,result:r,throwOnFailedPublish:n,encodeOpts:a,appLink:c}=e,l=(0,p.formatJsonRpcResult)(t,r);let h;const d=c&&typeof(null==s.g?void 0:s.g.Linking)<"u";try{const e=d?o.zl_:o.$dT;h=await this.client.core.crypto.encode(i,l,k(M({},a||{}),{encoding:e}))}catch(e){throw await this.cleanup(),this.client.logger.error(`sendResult() -> core.crypto.encode() for topic ${i} failed`),e}let u;try{u=await this.client.core.history.get(i,t)}catch(e){throw this.client.logger.error(`sendResult() -> history.get(${i}, ${t}) failed`),e}if(d){const e=(0,o.L9d)(c,i,h);await s.g.Linking.openURL(e,this.client.name)}else{const e=_[u.request.method].res;n?(e.internal=k(M({},e.internal),{throwOnFailedPublish:!0}),await this.client.core.relayer.publish(i,h,e)):this.client.core.relayer.publish(i,h,e).catch((e=>this.client.logger.error(e)))}await this.client.core.history.resolve(l)},this.sendError=async e=>{const{id:t,topic:i,error:r,encodeOpts:n,rpcOpts:a,appLink:c}=e,l=(0,p.formatJsonRpcError)(t,r);let h;const d=c&&typeof(null==s.g?void 0:s.g.Linking)<"u";try{const e=d?o.zl_:o.$dT;h=await this.client.core.crypto.encode(i,l,k(M({},n||{}),{encoding:e}))}catch(e){throw await this.cleanup(),this.client.logger.error(`sendError() -> core.crypto.encode() for topic ${i} failed`),e}let u;try{u=await this.client.core.history.get(i,t)}catch(e){throw this.client.logger.error(`sendError() -> history.get(${i}, ${t}) failed`),e}if(d){const e=(0,o.L9d)(c,i,h);await s.g.Linking.openURL(e,this.client.name)}else{const e=a||_[u.request.method].res;this.client.core.relayer.publish(i,h,e)}await this.client.core.history.resolve(l)},this.cleanup=async()=>{const e=[],t=[];this.client.session.getAll().forEach((t=>{let s=!1;(0,o.BwD)(t.expiry)&&(s=!0),this.client.core.crypto.keychain.has(t.topic)||(s=!0),s&&e.push(t.topic)})),this.client.proposal.getAll().forEach((e=>{(0,o.BwD)(e.expiryTimestamp)&&t.push(e.id)})),await Promise.all([...e.map((e=>this.deleteSession({topic:e}))),...t.map((e=>this.deleteProposal(e)))])},this.onRelayEventRequest=async e=>{this.requestQueue.queue.push(e),await this.processRequestsQueue()},this.processRequestsQueue=async()=>{if(this.requestQueue.state!==S){for(this.client.logger.info(`Request queue starting with ${this.requestQueue.queue.length} requests`);this.requestQueue.queue.length>0;){this.requestQueue.state=S;const e=this.requestQueue.queue.shift();if(e)try{await this.processRequest(e)}catch(e){this.client.logger.warn(e)}}this.requestQueue.state=f}else this.client.logger.info("Request queue already active, skipping...")},this.processRequest=async e=>{const{topic:t,payload:s,attestation:i,transportType:r,encryptedId:n}=e,o=s.method;if(!this.shouldIgnorePairingRequest({topic:t,requestMethod:o}))switch(o){case"wc_sessionPropose":return await this.onSessionProposeRequest({topic:t,payload:s,attestation:i,encryptedId:n});case"wc_sessionSettle":return await this.onSessionSettleRequest(t,s);case"wc_sessionUpdate":return await this.onSessionUpdateRequest(t,s);case"wc_sessionExtend":return await this.onSessionExtendRequest(t,s);case"wc_sessionPing":return await this.onSessionPingRequest(t,s);case"wc_sessionDelete":return await this.onSessionDeleteRequest(t,s);case"wc_sessionRequest":return await this.onSessionRequest({topic:t,payload:s,attestation:i,encryptedId:n,transportType:r});case"wc_sessionEvent":return await this.onSessionEventRequest(t,s);case"wc_sessionAuthenticate":return await this.onSessionAuthenticateRequest({topic:t,payload:s,attestation:i,encryptedId:n,transportType:r});default:return this.client.logger.info(`Unsupported request method ${o}`)}},this.onRelayEventResponse=async e=>{const{topic:t,payload:s,transportType:i}=e,r=(await this.client.core.history.get(t,s.id)).request.method;switch(r){case"wc_sessionPropose":return this.onSessionProposeResponse(t,s,i);case"wc_sessionSettle":return this.onSessionSettleResponse(t,s);case"wc_sessionUpdate":return this.onSessionUpdateResponse(t,s);case"wc_sessionExtend":return this.onSessionExtendResponse(t,s);case"wc_sessionPing":return this.onSessionPingResponse(t,s);case"wc_sessionRequest":return this.onSessionRequestResponse(t,s);case"wc_sessionAuthenticate":return this.onSessionAuthenticateResponse(t,s);default:return this.client.logger.info(`Unsupported response method ${r}`)}},this.onRelayEventUnknownPayload=e=>{const{topic:t}=e,{message:s}=(0,o.kCb)("MISSING_OR_INVALID",`Decoded payload on topic ${t} is not identifiable as a JSON-RPC request or a response.`);throw new Error(s)},this.shouldIgnorePairingRequest=e=>{const{topic:t,requestMethod:s}=e,i=this.expectedPairingMethodMap.get(t);return!(!i||i.includes(s))&&!!(i.includes("wc_sessionAuthenticate")&&this.client.events.listenerCount("session_authenticate")>0)},this.onSessionProposeRequest=async e=>{const{topic:t,payload:s,attestation:r,encryptedId:n}=e,{params:a,id:c}=s;try{const e=this.client.core.eventClient.getEvent({topic:t});this.isValidConnect(M({},s.params));const l=a.expiryTimestamp||(0,o.gn4)(_.wc_sessionPropose.req.ttl),p=M({id:c,pairingTopic:t,expiryTimestamp:l},a);await this.setProposal(c,p);const h=await this.getVerifyContext({attestationId:r,hash:(0,o.rjm)(JSON.stringify(s)),encryptedId:n,metadata:p.proposer.metadata});0===this.client.events.listenerCount("session_proposal")&&(console.warn("No listener for session_proposal event"),e?.setError(i.jb.proposal_listener_not_found)),e?.addTrace(i.ne.emit_session_proposal),this.client.events.emit("session_proposal",{id:c,params:p,verifyContext:h})}catch(e){await this.sendError({id:c,topic:t,error:e,rpcOpts:_.wc_sessionPropose.autoReject}),this.client.logger.error(e)}},this.onSessionProposeResponse=async(e,t,s)=>{const{id:i}=t;if((0,p.isJsonRpcResult)(t)){const{result:r}=t;this.client.logger.trace({type:"method",method:"onSessionProposeResponse",result:r});const n=this.client.proposal.get(i);this.client.logger.trace({type:"method",method:"onSessionProposeResponse",proposal:n});const o=n.proposer.publicKey;this.client.logger.trace({type:"method",method:"onSessionProposeResponse",selfPublicKey:o});const a=r.responderPublicKey;this.client.logger.trace({type:"method",method:"onSessionProposeResponse",peerPublicKey:a});const c=await this.client.core.crypto.generateSharedKey(o,a);this.client.logger.trace({type:"method",method:"onSessionProposeResponse",sessionTopic:c});const l=await this.client.core.relayer.subscribe(c,{transportType:s});this.client.logger.trace({type:"method",method:"onSessionProposeResponse",subscriptionId:l}),await this.client.core.pairing.activate({topic:e})}else if((0,p.isJsonRpcError)(t)){await this.client.proposal.delete(i,(0,o.D6H)("USER_DISCONNECTED"));const e=(0,o.E0T)("session_connect");if(0===this.events.listenerCount(e))throw new Error(`emitting ${e} without any listeners, 954`);this.events.emit((0,o.E0T)("session_connect"),{error:t.error})}},this.onSessionSettleRequest=async(e,t)=>{const{id:s,params:r}=t;try{this.isValidSessionSettleRequest(r);const{relay:s,controller:n,expiry:a,namespaces:c,sessionProperties:l,sessionConfig:p}=t.params,h=k(M(M({topic:e,relay:s,expiry:a,namespaces:c,acknowledged:!0,pairingTopic:"",requiredNamespaces:{},optionalNamespaces:{},controller:n.publicKey,self:{publicKey:"",metadata:this.client.metadata},peer:{publicKey:n.publicKey,metadata:n.metadata}},l&&{sessionProperties:l}),p&&{sessionConfig:p}),{transportType:i.QZ.relay}),d=(0,o.E0T)("session_connect");if(0===this.events.listenerCount(d))throw new Error(`emitting ${d} without any listeners 997`);this.events.emit((0,o.E0T)("session_connect"),{session:h}),await this.sendResult({id:t.id,topic:e,result:!0,throwOnFailedPublish:!0})}catch(t){await this.sendError({id:s,topic:e,error:t}),this.client.logger.error(t)}},this.onSessionSettleResponse=async(e,t)=>{const{id:s}=t;(0,p.isJsonRpcResult)(t)?(await this.client.session.update(e,{acknowledged:!0}),this.events.emit((0,o.E0T)("session_approve",s),{})):(0,p.isJsonRpcError)(t)&&(await this.client.session.delete(e,(0,o.D6H)("USER_DISCONNECTED")),this.events.emit((0,o.E0T)("session_approve",s),{error:t.error}))},this.onSessionUpdateRequest=async(e,t)=>{const{params:s,id:i}=t;try{const t=`${e}_session_update`,r=o.O6B.get(t);if(r&&this.isRequestOutOfSync(r,i))return this.client.logger.info(`Discarding out of sync request - ${i}`),void this.sendError({id:i,topic:e,error:(0,o.D6H)("INVALID_UPDATE_REQUEST")});this.isValidUpdate(M({topic:e},s));try{o.O6B.set(t,i),await this.client.session.update(e,{namespaces:s.namespaces}),await this.sendResult({id:i,topic:e,result:!0,throwOnFailedPublish:!0})}catch(e){throw o.O6B.delete(t),e}this.client.events.emit("session_update",{id:i,topic:e,params:s})}catch(t){await this.sendError({id:i,topic:e,error:t}),this.client.logger.error(t)}},this.isRequestOutOfSync=(e,t)=>parseInt(t.toString().slice(0,-3))<=parseInt(e.toString().slice(0,-3)),this.onSessionUpdateResponse=(e,t)=>{const{id:s}=t,i=(0,o.E0T)("session_update",s);if(0===this.events.listenerCount(i))throw new Error(`emitting ${i} without any listeners`);(0,p.isJsonRpcResult)(t)?this.events.emit((0,o.E0T)("session_update",s),{}):(0,p.isJsonRpcError)(t)&&this.events.emit((0,o.E0T)("session_update",s),{error:t.error})},this.onSessionExtendRequest=async(e,t)=>{const{id:s}=t;try{this.isValidExtend({topic:e}),await this.setExpiry(e,(0,o.gn4)(m)),await this.sendResult({id:s,topic:e,result:!0,throwOnFailedPublish:!0}),this.client.events.emit("session_extend",{id:s,topic:e})}catch(t){await this.sendError({id:s,topic:e,error:t}),this.client.logger.error(t)}},this.onSessionExtendResponse=(e,t)=>{const{id:s}=t,i=(0,o.E0T)("session_extend",s);if(0===this.events.listenerCount(i))throw new Error(`emitting ${i} without any listeners`);(0,p.isJsonRpcResult)(t)?this.events.emit((0,o.E0T)("session_extend",s),{}):(0,p.isJsonRpcError)(t)&&this.events.emit((0,o.E0T)("session_extend",s),{error:t.error})},this.onSessionPingRequest=async(e,t)=>{const{id:s}=t;try{this.isValidPing({topic:e}),await this.sendResult({id:s,topic:e,result:!0,throwOnFailedPublish:!0}),this.client.events.emit("session_ping",{id:s,topic:e})}catch(t){await this.sendError({id:s,topic:e,error:t}),this.client.logger.error(t)}},this.onSessionPingResponse=(e,t)=>{const{id:s}=t,i=(0,o.E0T)("session_ping",s);if(0===this.events.listenerCount(i))throw new Error(`emitting ${i} without any listeners`);setTimeout((()=>{(0,p.isJsonRpcResult)(t)?this.events.emit((0,o.E0T)("session_ping",s),{}):(0,p.isJsonRpcError)(t)&&this.events.emit((0,o.E0T)("session_ping",s),{error:t.error})}),500)},this.onSessionDeleteRequest=async(e,t)=>{const{id:s}=t;try{this.isValidDisconnect({topic:e,reason:t.params}),Promise.all([new Promise((t=>{this.client.core.relayer.once(i.Mb.publish,(async()=>{t(await this.deleteSession({topic:e,id:s}))}))})),this.sendResult({id:s,topic:e,result:!0,throwOnFailedPublish:!0}),this.cleanupPendingSentRequestsForTopic({topic:e,error:(0,o.D6H)("USER_DISCONNECTED")})]).catch((e=>this.client.logger.error(e)))}catch(e){this.client.logger.error(e)}},this.onSessionRequest=async e=>{var t,s,r;const{topic:n,payload:a,attestation:c,encryptedId:l,transportType:h}=e,{id:d,params:u}=a;try{await this.isValidRequest(M({topic:n},u));const e=this.client.session.get(n),a={id:d,topic:n,params:u,verifyContext:await this.getVerifyContext({attestationId:c,hash:(0,o.rjm)(JSON.stringify((0,p.formatJsonRpcRequest)("wc_sessionRequest",u,d))),encryptedId:l,metadata:e.peer.metadata,transportType:h})};await this.setPendingSessionRequest(a),h===i.QZ.link_mode&&null!=(t=e.peer.metadata.redirect)&&t.universal&&this.client.core.addLinkModeSupportedApp(null==(s=e.peer.metadata.redirect)?void 0:s.universal),null!=(r=this.client.signConfig)&&r.disableRequestQueue?this.emitSessionRequest(a):(this.addSessionRequestToSessionRequestQueue(a),this.processSessionRequestQueue())}catch(e){await this.sendError({id:d,topic:n,error:e}),this.client.logger.error(e)}},this.onSessionRequestResponse=(e,t)=>{const{id:s}=t,i=(0,o.E0T)("session_request",s);if(0===this.events.listenerCount(i))throw new Error(`emitting ${i} without any listeners`);(0,p.isJsonRpcResult)(t)?this.events.emit((0,o.E0T)("session_request",s),{result:t.result}):(0,p.isJsonRpcError)(t)&&this.events.emit((0,o.E0T)("session_request",s),{error:t.error})},this.onSessionEventRequest=async(e,t)=>{const{id:s,params:i}=t;try{const t=`${e}_session_event_${i.event.name}`,r=o.O6B.get(t);if(r&&this.isRequestOutOfSync(r,s))return void this.client.logger.info(`Discarding out of sync request - ${s}`);this.isValidEmit(M({topic:e},i)),this.client.events.emit("session_event",{id:s,topic:e,params:i}),o.O6B.set(t,s)}catch(t){await this.sendError({id:s,topic:e,error:t}),this.client.logger.error(t)}},this.onSessionAuthenticateResponse=(e,t)=>{const{id:s}=t;this.client.logger.trace({type:"method",method:"onSessionAuthenticateResponse",topic:e,payload:t}),(0,p.isJsonRpcResult)(t)?this.events.emit((0,o.E0T)("session_request",s),{result:t.result}):(0,p.isJsonRpcError)(t)&&this.events.emit((0,o.E0T)("session_request",s),{error:t.error})},this.onSessionAuthenticateRequest=async e=>{var t;const{topic:s,payload:r,attestation:n,encryptedId:a,transportType:c}=e;try{const{requester:e,authPayload:l,expiryTimestamp:p}=r.params,h=await this.getVerifyContext({attestationId:n,hash:(0,o.rjm)(JSON.stringify(r)),encryptedId:a,metadata:e.metadata,transportType:c}),d={requester:e,pairingTopic:s,id:r.id,authPayload:l,verifyContext:h,expiryTimestamp:p};await this.setAuthRequest(r.id,{request:d,pairingTopic:s,transportType:c}),c===i.QZ.link_mode&&null!=(t=e.metadata.redirect)&&t.universal&&this.client.core.addLinkModeSupportedApp(e.metadata.redirect.universal),this.client.events.emit("session_authenticate",{topic:s,params:r.params,id:r.id,verifyContext:h})}catch(e){this.client.logger.error(e);const t=r.params.requester.publicKey,i=await this.client.core.crypto.generateKeyPair(),n=this.getAppLinkIfEnabled(r.params.requester.metadata,c),a={type:o.rVF,receiverPublicKey:t,senderPublicKey:i};await this.sendError({id:r.id,topic:s,error:e,encodeOpts:a,rpcOpts:_.wc_sessionAuthenticate.autoReject,appLink:n})}},this.addSessionRequestToSessionRequestQueue=e=>{this.sessionRequestQueue.queue.push(e)},this.cleanupAfterResponse=e=>{this.deletePendingSessionRequest(e.response.id,{message:"fulfilled",code:0}),setTimeout((()=>{this.sessionRequestQueue.state=f,this.processSessionRequestQueue()}),(0,l.toMiliseconds)(this.requestQueueDelay))},this.cleanupPendingSentRequestsForTopic=({topic:e,error:t})=>{const s=this.client.core.history.pending;s.length>0&&s.filter((t=>t.topic===e&&"wc_sessionRequest"===t.request.method)).forEach((e=>{const s=e.request.id,i=(0,o.E0T)("session_request",s);if(0===this.events.listenerCount(i))throw new Error(`emitting ${i} without any listeners`);this.events.emit((0,o.E0T)("session_request",e.request.id),{error:t})}))},this.processSessionRequestQueue=()=>{if(this.sessionRequestQueue.state===S)return void this.client.logger.info("session request queue is already active.");const e=this.sessionRequestQueue.queue[0];if(e)try{this.sessionRequestQueue.state=S,this.emitSessionRequest(e)}catch(e){this.client.logger.error(e)}else this.client.logger.info("session request queue is empty.")},this.emitSessionRequest=e=>{this.client.events.emit("session_request",e)},this.onPairingCreated=e=>{if(e.methods&&this.expectedPairingMethodMap.set(e.topic,e.methods),e.active)return;const t=this.client.proposal.getAll().find((t=>t.pairingTopic===e.topic));t&&this.onSessionProposeRequest({topic:e.topic,payload:(0,p.formatJsonRpcRequest)("wc_sessionPropose",{requiredNamespaces:t.requiredNamespaces,optionalNamespaces:t.optionalNamespaces,relays:t.relays,proposer:t.proposer,sessionProperties:t.sessionProperties},t.id)})},this.isValidConnect=async e=>{if(!(0,o.EJd)(e)){const{message:t}=(0,o.kCb)("MISSING_OR_INVALID",`connect() params: ${JSON.stringify(e)}`);throw new Error(t)}const{pairingTopic:t,requiredNamespaces:s,optionalNamespaces:i,sessionProperties:r,relays:n}=e;if((0,o.o8e)(t)||await this.isValidPairingTopic(t),!(0,o.PMr)(n,!0)){const{message:e}=(0,o.kCb)("MISSING_OR_INVALID",`connect() relays: ${n}`);throw new Error(e)}!(0,o.o8e)(s)&&0!==(0,o.L5o)(s)&&this.validateNamespaces(s,"requiredNamespaces"),!(0,o.o8e)(i)&&0!==(0,o.L5o)(i)&&this.validateNamespaces(i,"optionalNamespaces"),(0,o.o8e)(r)||this.validateSessionProps(r,"sessionProperties")},this.validateNamespaces=(e,t)=>{const s=(0,o.naP)(e,"connect()",t);if(s)throw new Error(s.message)},this.isValidApprove=async e=>{if(!(0,o.EJd)(e))throw new Error((0,o.kCb)("MISSING_OR_INVALID",`approve() params: ${e}`).message);const{id:t,namespaces:s,relayProtocol:i,sessionProperties:r}=e;this.checkRecentlyDeleted(t),await this.isValidProposalId(t);const n=this.client.proposal.get(t),a=(0,o.ing)(s,"approve()");if(a)throw new Error(a.message);const c=(0,o.rFo)(n.requiredNamespaces,s,"approve()");if(c)throw new Error(c.message);if(!(0,o.M_r)(i,!0)){const{message:e}=(0,o.kCb)("MISSING_OR_INVALID",`approve() relayProtocol: ${i}`);throw new Error(e)}(0,o.o8e)(r)||this.validateSessionProps(r,"sessionProperties")},this.isValidReject=async e=>{if(!(0,o.EJd)(e)){const{message:t}=(0,o.kCb)("MISSING_OR_INVALID",`reject() params: ${e}`);throw new Error(t)}const{id:t,reason:s}=e;if(this.checkRecentlyDeleted(t),await this.isValidProposalId(t),!(0,o.H4H)(s)){const{message:e}=(0,o.kCb)("MISSING_OR_INVALID",`reject() reason: ${JSON.stringify(s)}`);throw new Error(e)}},this.isValidSessionSettleRequest=e=>{if(!(0,o.EJd)(e)){const{message:t}=(0,o.kCb)("MISSING_OR_INVALID",`onSessionSettleRequest() params: ${e}`);throw new Error(t)}const{relay:t,controller:s,namespaces:i,expiry:r}=e;if(!(0,o.Z26)(t)){const{message:e}=(0,o.kCb)("MISSING_OR_INVALID","onSessionSettleRequest() relay protocol should be a string");throw new Error(e)}const n=(0,o.DdM)(s,"onSessionSettleRequest()");if(n)throw new Error(n.message);const a=(0,o.ing)(i,"onSessionSettleRequest()");if(a)throw new Error(a.message);if((0,o.BwD)(r)){const{message:e}=(0,o.kCb)("EXPIRED","onSessionSettleRequest()");throw new Error(e)}},this.isValidUpdate=async e=>{if(!(0,o.EJd)(e)){const{message:t}=(0,o.kCb)("MISSING_OR_INVALID",`update() params: ${e}`);throw new Error(t)}const{topic:t,namespaces:s}=e;this.checkRecentlyDeleted(t),await this.isValidSessionTopic(t);const i=this.client.session.get(t),r=(0,o.ing)(s,"update()");if(r)throw new Error(r.message);const n=(0,o.rFo)(i.requiredNamespaces,s,"update()");if(n)throw new Error(n.message)},this.isValidExtend=async e=>{if(!(0,o.EJd)(e)){const{message:t}=(0,o.kCb)("MISSING_OR_INVALID",`extend() params: ${e}`);throw new Error(t)}const{topic:t}=e;this.checkRecentlyDeleted(t),await this.isValidSessionTopic(t)},this.isValidRequest=async e=>{if(!(0,o.EJd)(e)){const{message:t}=(0,o.kCb)("MISSING_OR_INVALID",`request() params: ${e}`);throw new Error(t)}const{topic:t,request:s,chainId:i,expiry:r}=e;this.checkRecentlyDeleted(t),await this.isValidSessionTopic(t);const{namespaces:n}=this.client.session.get(t);if(!(0,o.p8o)(n,i)){const{message:e}=(0,o.kCb)("MISSING_OR_INVALID",`request() chainId: ${i}`);throw new Error(e)}if(!(0,o.hHR)(s)){const{message:e}=(0,o.kCb)("MISSING_OR_INVALID",`request() ${JSON.stringify(s)}`);throw new Error(e)}if(!(0,o.alS)(n,i,s.method)){const{message:e}=(0,o.kCb)("MISSING_OR_INVALID",`request() method: ${s.method}`);throw new Error(e)}if(r&&!(0,o.ONw)(r,E)){const{message:e}=(0,o.kCb)("MISSING_OR_INVALID",`request() expiry: ${r}. Expiry must be a number (in seconds) between ${E.min} and ${E.max}`);throw new Error(e)}},this.isValidRespond=async e=>{var t;if(!(0,o.EJd)(e)){const{message:t}=(0,o.kCb)("MISSING_OR_INVALID",`respond() params: ${e}`);throw new Error(t)}const{topic:s,response:i}=e;try{await this.isValidSessionTopic(s)}catch(s){throw null!=(t=e?.response)&&t.id&&this.cleanupAfterResponse(e),s}if(!(0,o.JTI)(i)){const{message:e}=(0,o.kCb)("MISSING_OR_INVALID",`respond() response: ${JSON.stringify(i)}`);throw new Error(e)}},this.isValidPing=async e=>{if(!(0,o.EJd)(e)){const{message:t}=(0,o.kCb)("MISSING_OR_INVALID",`ping() params: ${e}`);throw new Error(t)}const{topic:t}=e;await this.isValidSessionOrPairingTopic(t)},this.isValidEmit=async e=>{if(!(0,o.EJd)(e)){const{message:t}=(0,o.kCb)("MISSING_OR_INVALID",`emit() params: ${e}`);throw new Error(t)}const{topic:t,event:s,chainId:i}=e;await this.isValidSessionTopic(t);const{namespaces:r}=this.client.session.get(t);if(!(0,o.p8o)(r,i)){const{message:e}=(0,o.kCb)("MISSING_OR_INVALID",`emit() chainId: ${i}`);throw new Error(e)}if(!(0,o.nfW)(s)){const{message:e}=(0,o.kCb)("MISSING_OR_INVALID",`emit() event: ${JSON.stringify(s)}`);throw new Error(e)}if(!(0,o.B95)(r,i,s.name)){const{message:e}=(0,o.kCb)("MISSING_OR_INVALID",`emit() event: ${JSON.stringify(s)}`);throw new Error(e)}},this.isValidDisconnect=async e=>{if(!(0,o.EJd)(e)){const{message:t}=(0,o.kCb)("MISSING_OR_INVALID",`disconnect() params: ${e}`);throw new Error(t)}const{topic:t}=e;await this.isValidSessionOrPairingTopic(t)},this.isValidAuthenticate=e=>{const{chains:t,uri:s,domain:i,nonce:r}=e;if(!Array.isArray(t)||0===t.length)throw new Error("chains is required and must be a non-empty array");if(!(0,o.M_r)(s,!1))throw new Error("uri is required parameter");if(!(0,o.M_r)(i,!1))throw new Error("domain is required parameter");if(!(0,o.M_r)(r,!1))throw new Error("nonce is required parameter");if([...new Set(t.map((e=>(0,o.DQe)(e).namespace)))].length>1)throw new Error("Multi-namespace requests are not supported. Please request single namespace only.");const{namespace:n}=(0,o.DQe)(t[0]);if("eip155"!==n)throw new Error("Only eip155 namespace is supported for authenticated sessions. Please use .connect() for non-eip155 chains.")},this.getVerifyContext=async e=>{const{attestationId:t,hash:s,encryptedId:r,metadata:n,transportType:o}=e,a={verified:{verifyUrl:n.verifyUrl||i.sG,validation:"UNKNOWN",origin:n.url||""}};try{if(o===i.QZ.link_mode){const e=this.getAppLinkIfEnabled(n,o);return a.verified.validation=e&&new URL(e).origin===new URL(n.url).origin?"VALID":"INVALID",a}const e=await this.client.core.verify.resolve({attestationId:t,hash:s,encryptedId:r,verifyUrl:n.verifyUrl});e&&(a.verified.origin=e.origin,a.verified.isScam=e.isScam,a.verified.validation=e.origin===new URL(n.url).origin?"VALID":"INVALID")}catch(e){this.client.logger.warn(e)}return this.client.logger.debug(`Verify context: ${JSON.stringify(a)}`),a},this.validateSessionProps=(e,t)=>{Object.values(e).forEach((e=>{if(!(0,o.M_r)(e,!1)){const{message:s}=(0,o.kCb)("MISSING_OR_INVALID",`${t} must be in Record<string, string> format. Received: ${JSON.stringify(e)}`);throw new Error(s)}}))},this.getPendingAuthRequest=e=>{const t=this.client.auth.requests.get(e);return"object"==typeof t?t:void 0},this.addToRecentlyDeleted=(e,t)=>{if(this.recentlyDeletedMap.set(e,t),this.recentlyDeletedMap.size>=this.recentlyDeletedLimit){let e=0;const t=this.recentlyDeletedLimit/2;for(const s of this.recentlyDeletedMap.keys()){if(e++>=t)break;this.recentlyDeletedMap.delete(s)}}},this.checkRecentlyDeleted=e=>{const t=this.recentlyDeletedMap.get(e);if(t){const{message:s}=(0,o.kCb)("MISSING_OR_INVALID",`Record was recently deleted - ${t}: ${e}`);throw new Error(s)}},this.isLinkModeEnabled=(e,t)=>{var r,n,o,a,c,l,p,h,d;return!(!e||t!==i.QZ.link_mode)&&(!0===(null==(n=null==(r=this.client.metadata)?void 0:r.redirect)?void 0:n.linkMode)&&void 0!==(null==(a=null==(o=this.client.metadata)?void 0:o.redirect)?void 0:a.universal)&&""!==(null==(l=null==(c=this.client.metadata)?void 0:c.redirect)?void 0:l.universal)&&void 0!==(null==(p=e?.redirect)?void 0:p.universal)&&""!==(null==(h=e?.redirect)?void 0:h.universal)&&!0===(null==(d=e?.redirect)?void 0:d.linkMode)&&this.client.core.linkModeSupportedApps.includes(e.redirect.universal)&&typeof(null==s.g?void 0:s.g.Linking)<"u")},this.getAppLinkIfEnabled=(e,t)=>{var s;return this.isLinkModeEnabled(e,t)?null==(s=e?.redirect)?void 0:s.universal:void 0},this.handleLinkModeMessage=({url:e})=>{if(!e||!e.includes("wc_ev")||!e.includes("topic"))return;const t=(0,o.waw)(e,"topic")||"",s=decodeURIComponent((0,o.waw)(e,"wc_ev")||""),r=this.client.session.keys.includes(t);r&&this.client.session.update(t,{transportType:i.QZ.link_mode}),this.client.core.dispatchEnvelope({topic:t,message:s,sessionExists:r})},this.registerLinkModeListeners=async()=>{var e;if((0,o.h9F)()||(0,o.b$m)()&&null!=(e=this.client.metadata.redirect)&&e.linkMode){const e=null==s.g?void 0:s.g.Linking;if(typeof e<"u"){e.addEventListener("url",this.handleLinkModeMessage,this.client.name);const t=await e.getInitialURL();t&&setTimeout((()=>{this.handleLinkModeMessage({url:t})}),50)}}}}isInitialized(){if(!this.initialized){const{message:e}=(0,o.kCb)("NOT_INITIALIZED",this.name);throw new Error(e)}}async confirmOnlineStateOrThrow(){await this.client.core.relayer.confirmOnlineStateOrThrow()}registerRelayerEvents(){this.client.core.relayer.on(i.Mb.message,(e=>{!this.initialized||this.relayMessageCache.length>0?this.relayMessageCache.push(e):this.onRelayMessage(e)}))}async onRelayMessage(e){const{topic:t,message:s,attestation:r,transportType:n}=e,{publicKey:a}=this.client.auth.authKeys.keys.includes(b)?this.client.auth.authKeys.get(b):{responseTopic:void 0,publicKey:void 0},c=await this.client.core.crypto.decode(t,s,{receiverPublicKey:a,encoding:n===i.QZ.link_mode?o.zl_:o.$dT});try{(0,p.isJsonRpcRequest)(c)?(this.client.core.history.set(t,c),this.onRelayEventRequest({topic:t,payload:c,attestation:r,transportType:n,encryptedId:(0,o.rjm)(s)})):(0,p.isJsonRpcResponse)(c)?(await this.client.core.history.resolve(c),await this.onRelayEventResponse({topic:t,payload:c,transportType:n}),this.client.core.history.delete(t,c.id)):this.onRelayEventUnknownPayload({topic:t,payload:c,transportType:n})}catch(e){this.client.logger.error(e)}}registerExpirerEvents(){this.client.core.expirer.on(i.i9.expired,(async e=>{const{topic:t,id:s}=(0,o.iPz)(e.target);return s&&this.client.pendingRequest.keys.includes(s)?await this.deletePendingSessionRequest(s,(0,o.kCb)("EXPIRED"),!0):s&&this.client.auth.requests.keys.includes(s)?await this.deletePendingAuthRequest(s,(0,o.kCb)("EXPIRED"),!0):void(t?this.client.session.keys.includes(t)&&(await this.deleteSession({topic:t,expirerHasDeleted:!0}),this.client.events.emit("session_expire",{topic:t})):s&&(await this.deleteProposal(s,!0),this.client.events.emit("proposal_expire",{id:s})))}))}registerPairingEvents(){this.client.core.pairing.events.on(i.I8.create,(e=>this.onPairingCreated(e))),this.client.core.pairing.events.on(i.I8.delete,(e=>{this.addToRecentlyDeleted(e.topic,"pairing")}))}isValidPairingTopic(e){if(!(0,o.M_r)(e,!1)){const{message:t}=(0,o.kCb)("MISSING_OR_INVALID",`pairing topic should be a string: ${e}`);throw new Error(t)}if(!this.client.core.pairing.pairings.keys.includes(e)){const{message:t}=(0,o.kCb)("NO_MATCHING_KEY",`pairing topic doesn't exist: ${e}`);throw new Error(t)}if((0,o.BwD)(this.client.core.pairing.pairings.get(e).expiry)){const{message:t}=(0,o.kCb)("EXPIRED",`pairing topic: ${e}`);throw new Error(t)}}async isValidSessionTopic(e){if(!(0,o.M_r)(e,!1)){const{message:t}=(0,o.kCb)("MISSING_OR_INVALID",`session topic should be a string: ${e}`);throw new Error(t)}if(this.checkRecentlyDeleted(e),!this.client.session.keys.includes(e)){const{message:t}=(0,o.kCb)("NO_MATCHING_KEY",`session topic doesn't exist: ${e}`);throw new Error(t)}if((0,o.BwD)(this.client.session.get(e).expiry)){await this.deleteSession({topic:e});const{message:t}=(0,o.kCb)("EXPIRED",`session topic: ${e}`);throw new Error(t)}if(!this.client.core.crypto.keychain.has(e)){const{message:t}=(0,o.kCb)("MISSING_OR_INVALID",`session topic does not exist in keychain: ${e}`);throw await this.deleteSession({topic:e}),new Error(t)}}async isValidSessionOrPairingTopic(e){if(this.checkRecentlyDeleted(e),this.client.session.keys.includes(e))await this.isValidSessionTopic(e);else{if(!this.client.core.pairing.pairings.keys.includes(e)){if((0,o.M_r)(e,!1)){const{message:t}=(0,o.kCb)("NO_MATCHING_KEY",`session or pairing topic doesn't exist: ${e}`);throw new Error(t)}{const{message:t}=(0,o.kCb)("MISSING_OR_INVALID",`session or pairing topic should be a string: ${e}`);throw new Error(t)}}this.isValidPairingTopic(e)}}async isValidProposalId(e){if(!(0,o.Q01)(e)){const{message:t}=(0,o.kCb)("MISSING_OR_INVALID",`proposal id should be a number: ${e}`);throw new Error(t)}if(!this.client.proposal.keys.includes(e)){const{message:t}=(0,o.kCb)("NO_MATCHING_KEY",`proposal id doesn't exist: ${e}`);throw new Error(t)}if((0,o.BwD)(this.client.proposal.get(e).expiryTimestamp)){await this.deleteProposal(e);const{message:t}=(0,o.kCb)("EXPIRED",`proposal id: ${e}`);throw new Error(t)}}}class A extends i.yh{constructor(e,t){super(e,t,"proposal",d),this.core=e,this.logger=t}}class x extends i.yh{constructor(e,t){super(e,t,"session",d),this.core=e,this.logger=t}}class V extends i.yh{constructor(e,t){super(e,t,"request",d,(e=>e.id)),this.core=e,this.logger=t}}class U extends i.yh{constructor(e,t){super(e,t,"authKeys",I,(()=>b)),this.core=e,this.logger=t}}class L extends i.yh{constructor(e,t){super(e,t,"pairingTopics",I),this.core=e,this.logger=t}}class $ extends i.yh{constructor(e,t){super(e,t,"requests",I,(e=>e.id)),this.core=e,this.logger=t}}class K{constructor(e,t){this.core=e,this.logger=t,this.authKeys=new U(this.core,this.logger),this.pairingTopics=new L(this.core,this.logger),this.requests=new $(this.core,this.logger)}async init(){await this.authKeys.init(),await this.pairingTopics.init(),await this.requests.init()}}class H extends n.lV{constructor(e){super(e),this.protocol="wc",this.version=2,this.name=u,this.events=new a.EventEmitter,this.on=(e,t)=>this.events.on(e,t),this.once=(e,t)=>this.events.once(e,t),this.off=(e,t)=>this.events.off(e,t),this.removeListener=(e,t)=>this.events.removeListener(e,t),this.removeAllListeners=e=>this.events.removeAllListeners(e),this.connect=async e=>{try{return await this.engine.connect(e)}catch(e){throw this.logger.error(e.message),e}},this.pair=async e=>{try{return await this.engine.pair(e)}catch(e){throw this.logger.error(e.message),e}},this.approve=async e=>{try{return await this.engine.approve(e)}catch(e){throw this.logger.error(e.message),e}},this.reject=async e=>{try{return await this.engine.reject(e)}catch(e){throw this.logger.error(e.message),e}},this.update=async e=>{try{return await this.engine.update(e)}catch(e){throw this.logger.error(e.message),e}},this.extend=async e=>{try{return await this.engine.extend(e)}catch(e){throw this.logger.error(e.message),e}},this.request=async e=>{try{return await this.engine.request(e)}catch(e){throw this.logger.error(e.message),e}},this.respond=async e=>{try{return await this.engine.respond(e)}catch(e){throw this.logger.error(e.message),e}},this.ping=async e=>{try{return await this.engine.ping(e)}catch(e){throw this.logger.error(e.message),e}},this.emit=async e=>{try{return await this.engine.emit(e)}catch(e){throw this.logger.error(e.message),e}},this.disconnect=async e=>{try{return await this.engine.disconnect(e)}catch(e){throw this.logger.error(e.message),e}},this.find=e=>{try{return this.engine.find(e)}catch(e){throw this.logger.error(e.message),e}},this.getPendingSessionRequests=()=>{try{return this.engine.getPendingSessionRequests()}catch(e){throw this.logger.error(e.message),e}},this.authenticate=async(e,t)=>{try{return await this.engine.authenticate(e,t)}catch(e){throw this.logger.error(e.message),e}},this.formatAuthMessage=e=>{try{return this.engine.formatAuthMessage(e)}catch(e){throw this.logger.error(e.message),e}},this.approveSessionAuthenticate=async e=>{try{return await this.engine.approveSessionAuthenticate(e)}catch(e){throw this.logger.error(e.message),e}},this.rejectSessionAuthenticate=async e=>{try{return await this.engine.rejectSessionAuthenticate(e)}catch(e){throw this.logger.error(e.message),e}},this.name=e?.name||u,this.metadata=e?.metadata||(0,o.DaH)(),this.signConfig=e?.signConfig;const t=typeof e?.logger<"u"&&"string"!=typeof e?.logger?e.logger:(0,r.gw)((0,r.jI)({level:e?.logger||g}));this.core=e?.core||new i.QY(e),this.logger=(0,r.Ep)(t,this.name),this.session=new x(this.core,this.logger),this.proposal=new A(this.core,this.logger),this.pendingRequest=new V(this.core,this.logger),this.engine=new C(this),this.auth=new K(this.core,this.logger)}static async init(e){const t=new H(e);return await t.initialize(),t}get context(){return(0,r.Fd)(this.logger)}get pairing(){return this.core.pairing.pairings}async initialize(){this.logger.trace("Initialized");try{await this.core.start(),await this.session.init(),await this.proposal.init(),await this.pendingRequest.init(),await this.auth.init(),await this.engine.init(),this.logger.info("SignClient Initialization Success"),this.engine.processRelayMessageCache()}catch(e){throw this.logger.info("SignClient Initialization Failure"),this.logger.error(e.message),e}}}},4459:function(e,t,s){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const i=s(45451);i.__exportStar(s(40793),t),i.__exportStar(s(41010),t)},40793:function(e,t){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.ONE_THOUSAND=t.ONE_HUNDRED=void 0,t.ONE_HUNDRED=100,t.ONE_THOUSAND=1e3},41010:function(e,t){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.ONE_YEAR=t.FOUR_WEEKS=t.THREE_WEEKS=t.TWO_WEEKS=t.ONE_WEEK=t.THIRTY_DAYS=t.SEVEN_DAYS=t.FIVE_DAYS=t.THREE_DAYS=t.ONE_DAY=t.TWENTY_FOUR_HOURS=t.TWELVE_HOURS=t.SIX_HOURS=t.THREE_HOURS=t.ONE_HOUR=t.SIXTY_MINUTES=t.THIRTY_MINUTES=t.TEN_MINUTES=t.FIVE_MINUTES=t.ONE_MINUTE=t.SIXTY_SECONDS=t.THIRTY_SECONDS=t.TEN_SECONDS=t.FIVE_SECONDS=t.ONE_SECOND=void 0,t.ONE_SECOND=1,t.FIVE_SECONDS=5,t.TEN_SECONDS=10,t.THIRTY_SECONDS=30,t.SIXTY_SECONDS=60,t.ONE_MINUTE=t.SIXTY_SECONDS,t.FIVE_MINUTES=5*t.ONE_MINUTE,t.TEN_MINUTES=10*t.ONE_MINUTE,t.THIRTY_MINUTES=30*t.ONE_MINUTE,t.SIXTY_MINUTES=60*t.ONE_MINUTE,t.ONE_HOUR=t.SIXTY_MINUTES,t.THREE_HOURS=3*t.ONE_HOUR,t.SIX_HOURS=6*t.ONE_HOUR,t.TWELVE_HOURS=12*t.ONE_HOUR,t.TWENTY_FOUR_HOURS=24*t.ONE_HOUR,t.ONE_DAY=t.TWENTY_FOUR_HOURS,t.THREE_DAYS=3*t.ONE_DAY,t.FIVE_DAYS=5*t.ONE_DAY,t.SEVEN_DAYS=7*t.ONE_DAY,t.THIRTY_DAYS=30*t.ONE_DAY,t.ONE_WEEK=t.SEVEN_DAYS,t.TWO_WEEKS=2*t.ONE_WEEK,t.THREE_WEEKS=3*t.ONE_WEEK,t.FOUR_WEEKS=4*t.ONE_WEEK,t.ONE_YEAR=365*t.ONE_DAY},2621:function(e,t,s){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const i=s(45451);i.__exportStar(s(85419),t),i.__exportStar(s(25366),t),i.__exportStar(s(72078),t),i.__exportStar(s(4459),t)},72078:function(e,t,s){"use strict";Object.defineProperty(t,"__esModule",{value:!0});s(45451).__exportStar(s(18810),t)},18810:function(e,t){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.IWatch=void 0;t.IWatch=class{}},19979:function(e,t,s){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.fromMiliseconds=t.toMiliseconds=void 0;const i=s(4459);t.toMiliseconds=function(e){return e*i.ONE_THOUSAND},t.fromMiliseconds=function(e){return Math.floor(e/i.ONE_THOUSAND)}},76557:function(e,t){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.delay=void 0,t.delay=function(e){return new Promise((t=>{setTimeout((()=>{t(!0)}),e)}))}},85419:function(e,t,s){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const i=s(45451);i.__exportStar(s(76557),t),i.__exportStar(s(19979),t)},25366:function(e,t){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.Watch=void 0;class s{constructor(){this.timestamps=new Map}start(e){if(this.timestamps.has(e))throw new Error(`Watch already started for label: ${e}`);this.timestamps.set(e,{started:Date.now()})}stop(e){const t=this.get(e);if(void 0!==t.elapsed)throw new Error(`Watch already stopped for label: ${e}`);const s=Date.now()-t.started;this.timestamps.set(e,{started:t.started,elapsed:s})}get(e){const t=this.timestamps.get(e);if(void 0===t)throw new Error(`No timestamp found for label: ${e}`);return t}elapsed(e){const t=this.get(e);return t.elapsed||Date.now()-t.started}}t.Watch=s,t.default=s},62863:function(e,t,s){"use strict";s.d(t,{D3:function(){return u},Mo:function(){return w},N1:function(){return o},W3:function(){return _},Yo:function(){return g},kZ:function(){return c},lV:function(){return m},oe:function(){return p},pX:function(){return y},pZ:function(){return h},sY:function(){return d},yy:function(){return a},z9:function(){return l}});var i=s(26037),r=s(25788),n=s.n(r);class o extends i.q{constructor(e){super(),this.opts=e,this.protocol="wc",this.version=2}}class a extends i.q{constructor(e,t){super(),this.core=e,this.logger=t,this.records=new Map}}class c{constructor(e,t){this.logger=e,this.core=t}}class l extends i.q{constructor(e,t){super(),this.relayer=e,this.logger=t}}class p extends i.q{constructor(e){super()}}class h{constructor(e,t,s,i){this.core=e,this.logger=t,this.name=s}}class d extends i.q{constructor(e,t){super(),this.relayer=e,this.logger=t}}class u extends i.q{constructor(e,t){super(),this.core=e,this.logger=t}}class g{constructor(e,t,s){this.core=e,this.logger=t,this.store=s}}class y{constructor(e,t){this.projectId=e,this.logger=t}}class w{constructor(e,t,s){this.core=e,this.logger=t,this.telemetryEnabled=s}}n();class m{constructor(e){this.opts=e,this.protocol="wc",this.version=2}}r.EventEmitter;class _{constructor(e){this.client=e}}}}]);