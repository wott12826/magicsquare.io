(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[1989],{1989:function(t,e,r){t.exports=function(t){const{Buffer:e}=r(870838),s="api.js: ",i=this,n=r(181260),h=r(467926),u=r(387002),a=new(r(177142)),{attributes:o,showAttributes:l,showAttributeErrors:c,showRuleDependencies:p}=r(584058),d=r(469594),f=function(t,e,r){const s=`<span class="${n.style.CLASS_CTRLCHAR}">`,i="</span>",h=`<span class="${n.style.CLASS_NOMATCH}">`,u="</span>";let a,o="";for(;Array.isArray(t)&&0!==t.length;){if("number"!=typeof e)throw new Error("abnfToHtml: beg must be type number");if(e>=t.length)break;a="number"!=typeof r||e+r>=t.length?t.length:e+r;let l=0;for(let r=e;r<a;r+=1){const e=t[r];if(e>=32&&e<=126)switch(1===l?(o+=i,l=0):2===l&&(o+=u,l=0),e){case 32:o+="&nbsp;";break;case 60:o+="&lt;";break;case 62:o+="&gt;";break;case 38:o+="&amp;";break;case 34:o+="&quot;";break;case 39:o+="&#039;";break;case 92:o+="&#092;";break;default:o+=String.fromCharCode(e)}else 9===e||10===e||13===e?(0===l?(o+=s,l=1):2===l&&(o+=u+s,l=1),9===e&&(o+="TAB"),10===e&&(o+="LF"),13===e&&(o+="CR")):(0===l?(o+=h,l=2):1===l&&(o+=i+h,l=2),o+=`\\x${n.utils.charToHex(e)}`)}2===l&&(o+=u),1===l&&(o+=i);break}return o},b=function(t,e,r){let s="";for(let i=e;i<e+r;i+=1){const e=t[i];if(e>=32&&e<=126)s+=String.fromCharCode(e);else switch(e){case 9:s+="\\t";break;case 10:s+="\\n";break;case 13:s+="\\r";break;default:s+="\\unknown"}}return s};let g,m=!1,y=!1,A=!1,C=!1,w=0;if(this.errors=[],e.isBuffer(t))this.chars=h.decode("BINARY",t);else if(Array.isArray(t))this.chars=t.slice();else{if("string"!=typeof t)throw new Error(`${s}input source is not a string, byte Buffer or character array`);this.chars=h.decode("STRING",t)}this.sabnf=h.encode("STRING",this.chars),this.scan=function(t,e){this.lines=u(this.chars,this.errors,t,e),m=!0},this.parse=function(t,e,r){if(!m)throw new Error(`${s}grammar not scanned`);a.syntax(this.chars,this.lines,this.errors,t,e,r),y=!0},this.translate=function(){if(!y)throw new Error(`${s}grammar not scanned and parsed`);const t=a.semantic(this.chars,this.lines,this.errors);0===this.errors.length&&(this.rules=t.rules,this.udts=t.udts,g=t.lineMap,A=!0)},this.attributes=function(){if(!A)throw new Error(`${s}grammar not scanned, parsed and translated`);return w=o(this.rules,this.udts,g,this.errors),C=!0,w},this.generate=function(t){if(this.lines=u(this.chars,this.errors,t),this.errors.length)return;if(a.syntax(this.chars,this.lines,this.errors,t),this.errors.length)return;const e=a.semantic(this.chars,this.lines,this.errors);this.errors.length||(this.rules=e.rules,this.udts=e.udts,g=e.lineMap,w=o(this.rules,this.udts,g,this.errors),C=!0)},this.displayRules=function(t="index"){if(!A)throw new Error(`${s}grammar not scanned, parsed and translated`);return d(this.rules,this.udts,t)},this.displayRuleDependencies=function(t="index"){if(!C)throw new Error(`${s}no attributes - must be preceeded by call to attributes()`);return p(t)},this.displayAttributes=function(t="index"){if(!C)throw new Error(`${s}no attributes - must be preceeded by call to attributes()`);return w&&c(t),l(t)},this.displayAttributeErrors=function(){if(!C)throw new Error(`${s}no attributes - must be preceeded by call to attributes()`);return c()},this.toSource=function(t=void 0){if(!C)throw new Error(`${s}can't generate parser source - must be preceeded by call to attributes()`);if(w)throw new Error(`${s}can't generate parser source - attributes have ${w} errors`);return a.generateSource(this.chars,this.lines,this.rules,this.udts,t)},this.toObject=function(){if(!C)throw new Error(`${s}can't generate parser source - must be preceeded by call to attributes()`);if(w)throw new Error(`${s}can't generate parser source - attributes have ${w} errors`);return a.generateObject(this.sabnf,this.rules,this.udts)},this.errorsToAscii=function(){return function(t,e,r){let s,i,n,h;return s="",t.forEach((t=>{i=e[t.line],s+=`${i.lineNo}: `,s+=`${i.beginChar}: `,s+=t.char-i.beginChar+": ",n=i.beginChar,h=t.char-i.beginChar,s+=b(r,n,h),s+=" >> ",n=t.char,h=i.beginChar+i.length-t.char,s+=b(r,n,h),s+="\n",s+=`${i.lineNo}: `,s+=`${i.beginChar}: `,s+=t.char-i.beginChar+": ",s+="error: ",s+=t.msg,s+="\n"})),s}(this.errors,this.lines,this.chars)},this.errorsToHtml=function(t){return function(t,e,r,s){const[i]=n;let h="";const u=`<span class="${i.CLASS_NOMATCH}">&raquo;</span>`;return h+=`<p><table class="${i.CLASS_GRAMMAR}">\n`,s&&"string"==typeof s&&(h+=`<caption>${s}</caption>\n`),h+="<tr><th>line<br>no.</th><th>line<br>offset</th><th>error<br>offset</th><th><br>text</th></tr>\n",t.forEach((t=>{let s,i,a,o,l,c="",p="";0===e.length?(l=u,i=0):(s=e[t.line],a=s.beginChar,t.char>a&&(c=f(r,a,t.char-a)),a=t.char,o=s.beginChar+s.length,a<o&&(p=f(r,a,o-a)),l=c+u+p,i=t.char-s.beginChar,h+="<tr>",h+=`<td>${t.line}</td><td>${s.beginChar}</td><td>${i}</td><td>${l}</td>`,h+="</tr>\n",h+="<tr>",h+=`<td colspan="3"></td><td>&uarr;:&nbsp;${n.utils.stringToAsciiHtml(t.msg)}</td>`,h+="</tr>\n")})),h+="</table></p>\n",h}(this.errors,this.lines,this.chars,t)},this.linesToAscii=function(){return function(t){let e="Annotated Input Grammar";return t.forEach((t=>{e+="\n",e+=`line no: ${t.lineNo}`,e+=` : char index: ${t.beginChar}`,e+=` : length: ${t.length}`,e+=` : abnf: ${b(i.chars,t.beginChar,t.length)}`})),e+="\n",e}(this.lines)},this.linesToHtml=function(){return function(t){let e="";return e+=`<table class="${n.style.CLASS_GRAMMAR}">\n`,e+="<caption>Annotated Input Grammar</caption>\n",e+="<tr>",e+="<th>line<br>no.</th><th>first<br>char</th><th><br>length</th><th><br>text</th>",e+="</tr>\n",t.forEach((t=>{e+="<tr>",e+=`<td>${t.lineNo}`,e+=`</td><td>${t.beginChar}`,e+=`</td><td>${t.length}`,e+=`</td><td>${f(i.chars,t.beginChar,t.length)}`,e+="</td>",e+="</tr>\n"})),e+="</table>\n",e}(this.lines)}}},584058:function(t,e,r){t.exports=function(){const t=r(462086),{ruleAttributes:e,showAttributes:s,showAttributeErrors:i}=r(129933),{ruleDependencies:n,showRuleDependencies:h}=r(706462);class u{constructor(t,e){this.rules=t,this.udts=e,this.ruleCount=t.length,this.udtCount=e.length,this.startRule=0,this.dependenciesComplete=!1,this.attributesComplete=!1,this.isMutuallyRecursive=!1,this.ruleIndexes=this.indexArray(this.ruleCount),this.ruleAlphaIndexes=this.indexArray(this.ruleCount),this.ruleTypeIndexes=this.indexArray(this.ruleCount),this.udtIndexes=this.indexArray(this.udtCount),this.udtAlphaIndexes=this.indexArray(this.udtCount),this.attrsErrorCount=0,this.attrs=[],this.attrsErrors=[],this.attrsWorking=[],this.ruleDeps=[];for(let e=0;e<this.ruleCount;e+=1)this.attrs.push(this.attrGen(this.rules[e])),this.attrsWorking.push(this.attrGen(this.rules[e])),this.ruleDeps.push(this.rdGen(t[e],this.ruleCount,this.udtCount));this.compRulesAlpha=this.compRulesAlpha.bind(this),this.compUdtsAlpha=this.compUdtsAlpha.bind(this),this.compRulesType=this.compRulesType.bind(this),this.compRulesGroup=this.compRulesGroup.bind(this)}attrGen(t){return{left:!1,nested:!1,right:!1,empty:!1,finite:!1,cyclic:!1,leaf:!1,isOpen:!1,isComplete:!1,rule:t}}attrInit(t){t.left=!1,t.nested=!1,t.right=!1,t.empty=!1,t.finite=!1,t.cyclic=!1,t.leaf=!1,t.isOpen=!1,t.isComplete=!1}attrCopy(t,e){t.left=e.left,t.nested=e.nested,t.right=e.right,t.empty=e.empty,t.finite=e.finite,t.cyclic=e.cyclic,t.leaf=e.leaf,t.isOpen=e.isOpen,t.isComplete=e.isComplete,t.rule=e.rule}rdGen(e,r,s){return{rule:e,recursiveType:t.ATTR_N,groupNumber:-1,refersTo:this.falseArray(r),refersToUdt:this.falseArray(s),referencedBy:this.falseArray(r)}}typeToString(e){switch(e){case t.ATTR_N:return" N";case t.ATTR_R:return" R";case t.ATTR_MR:return"MR";default:return"UNKNOWN"}}falseArray(t){const e=[];if(t>0)for(let r=0;r<t;r+=1)e.push(!1);return e}falsifyArray(t){for(let e=0;e<t.length;e+=1)t[e]=!1}indexArray(t){const e=[];if(t>0)for(let r=0;r<t;r+=1)e.push(r);return e}compRulesAlpha(t,e){return this.rules[t].lower<this.rules[e].lower?-1:this.rules[t].lower>this.rules[e].lower?1:0}compUdtsAlpha(t,e){return this.udts[t].lower<this.udts[e].lower?-1:this.udts[t].lower>this.udts[e].lower?1:0}compRulesType(t,e){return this.ruleDeps[t].recursiveType<this.ruleDeps[e].recursiveType?-1:this.ruleDeps[t].recursiveType>this.ruleDeps[e].recursiveType?1:0}compRulesGroup(e,r){if(this.ruleDeps[e].recursiveType===t.ATTR_MR&&this.ruleDeps[r].recursiveType===t.ATTR_MR){if(this.ruleDeps[e].groupNumber<this.ruleDeps[r].groupNumber)return-1;if(this.ruleDeps[e].groupNumber>this.ruleDeps[r].groupNumber)return 1}return 0}}return{attributes:function(t=[],r=[],s=[],i=[]){const h=new u(t,r);return n(h),e(h),h.attrsErrorCount&&i.push({line:0,char:0,msg:`${h.attrsErrorCount} attribute errors`}),h.attrsErrorCount},showAttributes:s,showAttributeErrors:i,showRuleDependencies:h}}()}}]);
//# sourceMappingURL=1989-5884ac20b408af23.js.map