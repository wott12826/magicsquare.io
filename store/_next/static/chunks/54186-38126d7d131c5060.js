/*! For license information please see 54186-38126d7d131c5060.js.LICENSE.txt */
"use strict";(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[54186],{771569:function(t,e,n){n.d(e,{e4:function(){return w}});var r=n(603286),o=n(893672),i=n(392194);function s(t){void 0!==t.lowS&&(0,i.uw)("lowS",t.lowS),void 0!==t.prehash&&(0,i.uw)("prehash",t.prehash)}const{bytesToNumberBE:a,hexToBytes:f}=i,u={Err:class extends Error{constructor(t=""){super(t)}},_tlv:{encode:(t,e)=>{const{Err:n}=u;if(t<0||t>256)throw new n("tlv.encode: wrong tag");if(1&e.length)throw new n("tlv.encode: unpadded data");const r=e.length/2,o=i.uz(r);if(o.length/2&128)throw new n("tlv.encode: long form length too big");const s=r>127?i.uz(o.length/2|128):"";return`${i.uz(t)}${s}${o}${e}`},decode(t,e){const{Err:n}=u;let r=0;if(t<0||t>256)throw new n("tlv.encode: wrong tag");if(e.length<2||e[r++]!==t)throw new n("tlv.decode: wrong tlv");const o=e[r++];let i=0;if(!!(128&o)){const t=127&o;if(!t)throw new n("tlv.decode(long): indefinite length not supported");if(t>4)throw new n("tlv.decode(long): byte length is too big");const s=e.subarray(r,r+t);if(s.length!==t)throw new n("tlv.decode: length bytes not complete");if(0===s[0])throw new n("tlv.decode(long): zero leftmost byte");for(const t of s)i=i<<8|t;if(r+=t,i<128)throw new n("tlv.decode(long): not minimal encoding")}else i=o;const s=e.subarray(r,r+i);if(s.length!==i)throw new n("tlv.decode: wrong value length");return{v:s,l:e.subarray(r+i)}}},_int:{encode(t){const{Err:e}=u;if(t<c)throw new e("integer: negative integers are not allowed");let n=i.uz(t);if(8&Number.parseInt(n[0],16)&&(n="00"+n),1&n.length)throw new e("unexpected assertion");return n},decode(t){const{Err:e}=u;if(128&t[0])throw new e("Invalid signature integer: negative");if(0===t[0]&&!(128&t[1]))throw new e("Invalid signature integer: unnecessary leading zero");return a(t)}},toSig(t){const{Err:e,_int:n,_tlv:r}=u,o="string"==typeof t?f(t):t;i.gk(o);const{v:s,l:a}=r.decode(48,o);if(a.length)throw new e("Invalid signature: left bytes after parsing");const{v:c,l:l}=r.decode(2,s),{v:d,l:h}=r.decode(2,l);if(h.length)throw new e("Invalid signature: left bytes after parsing");return{r:n.decode(c),s:n.decode(d)}},hexFromSig(t){const{_tlv:e,_int:n}=u,r=`${e.encode(2,n.encode(t.r))}${e.encode(2,n.encode(t.s))}`;return e.encode(48,r)}},c=BigInt(0),l=BigInt(1),d=(BigInt(2),BigInt(3));BigInt(4);function h(t){const e=function(t){const e=(0,r.Kd)(t);i.FF(e,{a:"field",b:"field"},{allowedPrivateKeyLengths:"array",wrapPrivateKey:"boolean",isTorsionFree:"function",clearCofactor:"function",allowInfinityPoint:"boolean",fromBytes:"function",toBytes:"function"});const{endo:n,Fp:o,a:s}=e;if(n){if(!o.eql(s,o.ZERO))throw new Error("Endomorphism can only be defined for Koblitz curves that have a=0");if("object"!=typeof n||"bigint"!=typeof n.beta||"function"!=typeof n.splitScalar)throw new Error("Expected endomorphism with beta: bigint and splitScalar: function")}return Object.freeze({...e})}(t),{Fp:n}=e,s=o.gN(e.n,e.nBitLength),a=e.toBytes||((t,e,r)=>{const o=e.toAffine();return i.eV(Uint8Array.from([4]),n.toBytes(o.x),n.toBytes(o.y))}),f=e.fromBytes||(t=>{const e=t.subarray(1);return{x:n.fromBytes(e.subarray(0,n.BYTES)),y:n.fromBytes(e.subarray(n.BYTES,2*n.BYTES))}});function u(t){const{a:r,b:o}=e,i=n.sqr(t),s=n.mul(i,t);return n.add(n.add(s,n.mul(t,r)),o)}if(!n.eql(n.sqr(e.Gy),u(e.Gx)))throw new Error("bad generator point: equation left != right");function h(t){const{allowedPrivateKeyLengths:n,nByteLength:r,wrapPrivateKey:s,n:a}=e;if(n&&"bigint"!=typeof t){if(i._t(t)&&(t=i.ci(t)),"string"!=typeof t||!n.includes(t.length))throw new Error("Invalid key");t=t.padStart(2*r,"0")}let f;try{f="bigint"==typeof t?t:i.bytesToNumberBE((0,i.ql)("private key",t,r))}catch(e){throw new Error(`private key must be ${r} bytes, hex or bigint, not ${typeof t}`)}return s&&(f=o.wQ(f,a)),i.Fy("private key",f,l,a),f}function w(t){if(!(t instanceof g))throw new Error("ProjectivePoint expected")}const y=(0,i.H9)(((t,e)=>{const{px:r,py:o,pz:i}=t;if(n.eql(i,n.ONE))return{x:r,y:o};const s=t.is0();null==e&&(e=s?n.ONE:n.inv(i));const a=n.mul(r,e),f=n.mul(o,e),u=n.mul(i,e);if(s)return{x:n.ZERO,y:n.ZERO};if(!n.eql(u,n.ONE))throw new Error("invZ was invalid");return{x:a,y:f}})),p=(0,i.H9)((t=>{if(t.is0()){if(e.allowInfinityPoint&&!n.is0(t.py))return;throw new Error("bad point: ZERO")}const{x:r,y:o}=t.toAffine();if(!n.isValid(r)||!n.isValid(o))throw new Error("bad point: x or y not FE");const i=n.sqr(o),s=u(r);if(!n.eql(i,s))throw new Error("bad point: equation left != right");if(!t.isTorsionFree())throw new Error("bad point: not in prime-order subgroup");return!0}));class g{constructor(t,e,r){if(this.px=t,this.py=e,this.pz=r,null==t||!n.isValid(t))throw new Error("x required");if(null==e||!n.isValid(e))throw new Error("y required");if(null==r||!n.isValid(r))throw new Error("z required");Object.freeze(this)}static fromAffine(t){const{x:e,y:r}=t||{};if(!t||!n.isValid(e)||!n.isValid(r))throw new Error("invalid affine point");if(t instanceof g)throw new Error("projective point not allowed");const o=t=>n.eql(t,n.ZERO);return o(e)&&o(r)?g.ZERO:new g(e,r,n.ONE)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static normalizeZ(t){const e=n.invertBatch(t.map((t=>t.pz)));return t.map(((t,n)=>t.toAffine(e[n]))).map(g.fromAffine)}static fromHex(t){const e=g.fromAffine(f((0,i.ql)("pointHex",t)));return e.assertValidity(),e}static fromPrivateKey(t){return g.BASE.multiply(h(t))}static msm(t,e){return(0,r.D1)(g,s,t,e)}_setWindowSize(t){E.setWindowSize(this,t)}assertValidity(){p(this)}hasEvenY(){const{y:t}=this.toAffine();if(n.isOdd)return!n.isOdd(t);throw new Error("Field doesn't support isOdd")}equals(t){w(t);const{px:e,py:r,pz:o}=this,{px:i,py:s,pz:a}=t,f=n.eql(n.mul(e,a),n.mul(i,o)),u=n.eql(n.mul(r,a),n.mul(s,o));return f&&u}negate(){return new g(this.px,n.neg(this.py),this.pz)}double(){const{a:t,b:r}=e,o=n.mul(r,d),{px:i,py:s,pz:a}=this;let f=n.ZERO,u=n.ZERO,c=n.ZERO,l=n.mul(i,i),h=n.mul(s,s),w=n.mul(a,a),y=n.mul(i,s);return y=n.add(y,y),c=n.mul(i,a),c=n.add(c,c),f=n.mul(t,c),u=n.mul(o,w),u=n.add(f,u),f=n.sub(h,u),u=n.add(h,u),u=n.mul(f,u),f=n.mul(y,f),c=n.mul(o,c),w=n.mul(t,w),y=n.sub(l,w),y=n.mul(t,y),y=n.add(y,c),c=n.add(l,l),l=n.add(c,l),l=n.add(l,w),l=n.mul(l,y),u=n.add(u,l),w=n.mul(s,a),w=n.add(w,w),l=n.mul(w,y),f=n.sub(f,l),c=n.mul(w,h),c=n.add(c,c),c=n.add(c,c),new g(f,u,c)}add(t){w(t);const{px:r,py:o,pz:i}=this,{px:s,py:a,pz:f}=t;let u=n.ZERO,c=n.ZERO,l=n.ZERO;const h=e.a,y=n.mul(e.b,d);let p=n.mul(r,s),m=n.mul(o,a),E=n.mul(i,f),b=n.add(r,o),B=n.add(s,a);b=n.mul(b,B),B=n.add(p,m),b=n.sub(b,B),B=n.add(r,i);let v=n.add(s,f);return B=n.mul(B,v),v=n.add(p,E),B=n.sub(B,v),v=n.add(o,i),u=n.add(a,f),v=n.mul(v,u),u=n.add(m,E),v=n.sub(v,u),l=n.mul(h,B),u=n.mul(y,E),l=n.add(u,l),u=n.sub(m,l),l=n.add(m,l),c=n.mul(u,l),m=n.add(p,p),m=n.add(m,p),E=n.mul(h,E),B=n.mul(y,B),m=n.add(m,E),E=n.sub(p,E),E=n.mul(h,E),B=n.add(B,E),p=n.mul(m,B),c=n.add(c,p),p=n.mul(v,B),u=n.mul(b,u),u=n.sub(u,p),p=n.mul(b,m),l=n.mul(v,l),l=n.add(l,p),new g(u,c,l)}subtract(t){return this.add(t.negate())}is0(){return this.equals(g.ZERO)}wNAF(t){return E.wNAFCached(this,t,g.normalizeZ)}multiplyUnsafe(t){i.Fy("scalar",t,c,e.n);const r=g.ZERO;if(t===c)return r;if(t===l)return this;const{endo:o}=e;if(!o)return E.unsafeLadder(this,t);let{k1neg:s,k1:a,k2neg:f,k2:u}=o.splitScalar(t),d=r,h=r,w=this;for(;a>c||u>c;)a&l&&(d=d.add(w)),u&l&&(h=h.add(w)),w=w.double(),a>>=l,u>>=l;return s&&(d=d.negate()),f&&(h=h.negate()),h=new g(n.mul(h.px,o.beta),h.py,h.pz),d.add(h)}multiply(t){const{endo:r,n:o}=e;let s,a;if(i.Fy("scalar",t,l,o),r){const{k1neg:e,k1:o,k2neg:i,k2:f}=r.splitScalar(t);let{p:u,f:c}=this.wNAF(o),{p:l,f:d}=this.wNAF(f);u=E.constTimeNegate(e,u),l=E.constTimeNegate(i,l),l=new g(n.mul(l.px,r.beta),l.py,l.pz),s=u.add(l),a=c.add(d)}else{const{p:e,f:n}=this.wNAF(t);s=e,a=n}return g.normalizeZ([s,a])[0]}multiplyAndAddUnsafe(t,e,n){const r=g.BASE,o=(t,e)=>e!==c&&e!==l&&t.equals(r)?t.multiply(e):t.multiplyUnsafe(e),i=o(this,e).add(o(t,n));return i.is0()?void 0:i}toAffine(t){return y(this,t)}isTorsionFree(){const{h:t,isTorsionFree:n}=e;if(t===l)return!0;if(n)return n(g,this);throw new Error("isTorsionFree() has not been declared for the elliptic curve")}clearCofactor(){const{h:t,clearCofactor:n}=e;return t===l?this:n?n(g,this):this.multiplyUnsafe(e.h)}toRawBytes(t=!0){return(0,i.uw)("isCompressed",t),this.assertValidity(),a(g,this,t)}toHex(t=!0){return(0,i.uw)("isCompressed",t),i.ci(this.toRawBytes(t))}}g.BASE=new g(e.Gx,e.Gy,n.ONE),g.ZERO=new g(n.ZERO,n.ONE,n.ZERO);const m=e.nBitLength,E=(0,r.Mx)(g,e.endo?Math.ceil(m/2):m);return{CURVE:e,ProjectivePoint:g,normPrivateKeyToScalar:h,weierstrassEquation:u,isWithinCurveOrder:function(t){return i.Z2(t,l,e.n)}}}function w(t){const e=function(t){const e=(0,r.Kd)(t);return i.FF(e,{hash:"hash",hmac:"function",randomBytes:"function"},{bits2int:"function",bits2int_modN:"function",lowS:"boolean"}),Object.freeze({lowS:!0,...e})}(t),{Fp:n,n:a}=e,f=n.BYTES+1,d=2*n.BYTES+1;function w(t){return o.wQ(t,a)}function y(t){return o.U_(t,a)}const{ProjectivePoint:p,normPrivateKeyToScalar:g,weierstrassEquation:m,isWithinCurveOrder:E}=h({...e,toBytes(t,e,r){const o=e.toAffine(),s=n.toBytes(o.x),a=i.eV;return(0,i.uw)("isCompressed",r),r?a(Uint8Array.from([e.hasEvenY()?2:3]),s):a(Uint8Array.from([4]),s,n.toBytes(o.y))},fromBytes(t){const e=t.length,r=t[0],o=t.subarray(1);if(e!==f||2!==r&&3!==r){if(e===d&&4===r){return{x:n.fromBytes(o.subarray(0,n.BYTES)),y:n.fromBytes(o.subarray(n.BYTES,2*n.BYTES))}}throw new Error(`Point of length ${e} was invalid. Expected ${f} compressed bytes or ${d} uncompressed bytes`)}{const t=i.bytesToNumberBE(o);if(!i.Z2(t,l,n.ORDER))throw new Error("Point is not on curve");const e=m(t);let s;try{s=n.sqrt(e)}catch(t){const e=t instanceof Error?": "+t.message:"";throw new Error("Point is not on curve"+e)}return!(1&~r)!==((s&l)===l)&&(s=n.neg(s)),{x:t,y:s}}}}),b=t=>i.ci(i.tL(t,e.nByteLength));function B(t){return t>a>>l}const v=(t,e,n)=>i.bytesToNumberBE(t.slice(e,n));class x{constructor(t,e,n){this.r=t,this.s=e,this.recovery=n,this.assertValidity()}static fromCompact(t){const n=e.nByteLength;return t=(0,i.ql)("compactSignature",t,2*n),new x(v(t,0,n),v(t,n,2*n))}static fromDER(t){const{r:e,s:n}=u.toSig((0,i.ql)("DER",t));return new x(e,n)}assertValidity(){i.Fy("r",this.r,l,a),i.Fy("s",this.s,l,a)}addRecoveryBit(t){return new x(this.r,this.s,t)}recoverPublicKey(t){const{r:r,s:o,recovery:s}=this,a=H((0,i.ql)("msgHash",t));if(null==s||![0,1,2,3].includes(s))throw new Error("recovery id invalid");const f=2===s||3===s?r+e.n:r;if(f>=n.ORDER)throw new Error("recovery id 2 or 3 invalid");const u=1&s?"03":"02",c=p.fromHex(u+b(f)),l=y(f),d=w(-a*l),h=w(o*l),g=p.BASE.multiplyAndAddUnsafe(c,d,h);if(!g)throw new Error("point at infinify");return g.assertValidity(),g}hasHighS(){return B(this.s)}normalizeS(){return this.hasHighS()?new x(this.r,w(-this.s),this.recovery):this}toDERRawBytes(){return i.hexToBytes(this.toDERHex())}toDERHex(){return u.hexFromSig({r:this.r,s:this.s})}toCompactRawBytes(){return i.hexToBytes(this.toCompactHex())}toCompactHex(){return b(this.r)+b(this.s)}}const S={isValidPrivateKey(t){try{return g(t),!0}catch(t){return!1}},normPrivateKeyToScalar:g,randomPrivateKey:()=>{const t=o.PS(e.n);return o.Us(e.randomBytes(t),e.n)},precompute(t=8,e=p.BASE){return e._setWindowSize(t),e.multiply(BigInt(3)),e}};function A(t){const e=i._t(t),n="string"==typeof t,r=(e||n)&&t.length;return e?r===f||r===d:n?r===2*f||r===2*d:t instanceof p}const I=e.bits2int||function(t){const n=i.bytesToNumberBE(t),r=8*t.length-e.nBitLength;return r>0?n>>BigInt(r):n},H=e.bits2int_modN||function(t){return w(I(t))},R=i.dQ(e.nBitLength);function O(t){return i.Fy(`num < 2^${e.nBitLength}`,t,c,R),i.tL(t,e.nByteLength)}function q(t,r,o=k){if(["recovered","canonical"].some((t=>t in o)))throw new Error("sign() legacy options not supported");const{hash:a,randomBytes:f}=e;let{lowS:u,prehash:d,extraEntropy:h}=o;null==u&&(u=!0),t=(0,i.ql)("msgHash",t),s(o),d&&(t=(0,i.ql)("prehashed msgHash",a(t)));const m=H(t),b=g(r),v=[O(b),O(m)];if(null!=h&&!1!==h){const t=!0===h?f(n.BYTES):h;v.push((0,i.ql)("extraEntropy",t))}const S=i.eV(...v),A=m;return{seed:S,k2sig:function(t){const e=I(t);if(!E(e))return;const n=y(e),r=p.BASE.multiply(e).toAffine(),o=w(r.x);if(o===c)return;const i=w(n*w(A+o*b));if(i===c)return;let s=(r.x===o?0:2)|Number(r.y&l),a=i;return u&&B(i)&&(a=function(t){return B(t)?w(-t):t}(i),s^=1),new x(o,a,s)}}}const k={lowS:e.lowS,prehash:!1},P={lowS:e.lowS,prehash:!1};return p.BASE._setWindowSize(8),{CURVE:e,getPublicKey:function(t,e=!0){return p.fromPrivateKey(t).toRawBytes(e)},getSharedSecret:function(t,e,n=!0){if(A(t))throw new Error("first arg must be private key");if(!A(e))throw new Error("second arg must be public key");return p.fromHex(e).multiply(g(t)).toRawBytes(n)},sign:function(t,n,r=k){const{seed:o,k2sig:s}=q(t,n,r),a=e;return i.n$(a.hash.outputLen,a.nByteLength,a.hmac)(o,s)},verify:function(t,n,r,o=P){const a=t;if(n=(0,i.ql)("msgHash",n),r=(0,i.ql)("publicKey",r),"strict"in o)throw new Error("options.strict was renamed to lowS");s(o);const{lowS:f,prehash:c}=o;let l,d;try{if("string"==typeof a||i._t(a))try{l=x.fromDER(a)}catch(t){if(!(t instanceof u.Err))throw t;l=x.fromCompact(a)}else{if("object"!=typeof a||"bigint"!=typeof a.r||"bigint"!=typeof a.s)throw new Error("PARSE");{const{r:t,s:e}=a;l=new x(t,e)}}d=p.fromHex(r)}catch(t){if("PARSE"===t.message)throw new Error("signature must be Signature instance, Uint8Array or hex string");return!1}if(f&&l.hasHighS())return!1;c&&(n=e.hash(n));const{r:h,s:g}=l,m=H(n),E=y(g),b=w(m*E),B=w(h*E),v=p.BASE.multiplyAndAddUnsafe(d,b,B)?.toAffine();return!!v&&w(v.x)===h},ProjectivePoint:p,Signature:x,utils:S}}},916604:function(t,e,n){n.d(e,{secp256k1:function(){return h}});var r=n(825512),o=n(528751),i=n(893672);const s=BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),a=BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),f=BigInt(1),u=BigInt(2),c=(t,e)=>(t+e/u)/e;function l(t){const e=s,n=BigInt(3),r=BigInt(6),o=BigInt(11),a=BigInt(22),f=BigInt(23),c=BigInt(44),l=BigInt(88),h=t*t*t%e,w=h*h*t%e,y=(0,i.oA)(w,n,e)*w%e,p=(0,i.oA)(y,n,e)*w%e,g=(0,i.oA)(p,u,e)*h%e,m=(0,i.oA)(g,o,e)*g%e,E=(0,i.oA)(m,a,e)*m%e,b=(0,i.oA)(E,c,e)*E%e,B=(0,i.oA)(b,l,e)*b%e,v=(0,i.oA)(B,c,e)*E%e,x=(0,i.oA)(v,n,e)*w%e,S=(0,i.oA)(x,f,e)*m%e,A=(0,i.oA)(S,r,e)*h%e,I=(0,i.oA)(A,u,e);if(!d.eql(d.sqr(I),t))throw new Error("Cannot find square root");return I}const d=(0,i.gN)(s,void 0,void 0,{sqrt:l}),h=(0,o._)({a:BigInt(0),b:BigInt(7),Fp:d,n:a,Gx:BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),Gy:BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),h:BigInt(1),lowS:!0,endo:{beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),splitScalar:t=>{const e=a,n=BigInt("0x3086d221a7d46bcde86c90e49284eb15"),r=-f*BigInt("0xe4437ed6010e88286f547fa90abfe4c3"),o=BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),s=n,u=BigInt("0x100000000000000000000000000000000"),l=c(s*t,e),d=c(-r*t,e);let h=(0,i.wQ)(t-l*n-d*o,e),w=(0,i.wQ)(-l*r-d*s,e);const y=h>u,p=w>u;if(y&&(h=e-h),p&&(w=e-w),h>u||w>u)throw new Error("splitScalar: Endomorphism failed, k="+t);return{k1neg:y,k1:h,k2neg:p,k2:w}}}},r.JQ);BigInt(0);h.ProjectivePoint},779342:function(t,e,n){n.d(e,{b:function(){return s}});var r=n(89834),o=n(784755);class i extends o.kb{constructor(t,e){super(),this.finished=!1,this.destroyed=!1,(0,r.vp)(t);const n=(0,o.O0)(e);if(this.iHash=t.create(),"function"!=typeof this.iHash.update)throw new Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;const i=this.blockLen,s=new Uint8Array(i);s.set(n.length>i?t.create().update(n).digest():n);for(let t=0;t<s.length;t++)s[t]^=54;this.iHash.update(s),this.oHash=t.create();for(let t=0;t<s.length;t++)s[t]^=106;this.oHash.update(s),s.fill(0)}update(t){return(0,r.Gg)(this),this.iHash.update(t),this}digestInto(t){(0,r.Gg)(this),(0,r.aI)(t,this.outputLen),this.finished=!0,this.iHash.digestInto(t),this.oHash.update(t),this.oHash.digestInto(t),this.destroy()}digest(){const t=new Uint8Array(this.oHash.outputLen);return this.digestInto(t),t}_cloneInto(t){t||(t=Object.create(Object.getPrototypeOf(this),{}));const{oHash:e,iHash:n,finished:r,destroyed:o,blockLen:i,outputLen:s}=this;return t.finished=r,t.destroyed=o,t.blockLen=i,t.outputLen=s,t.oHash=e._cloneInto(t.oHash),t.iHash=n._cloneInto(t.iHash),t}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}}const s=(t,e,n)=>new i(t,e).update(n).digest();s.create=(t,e)=>new i(t,e)}}]);
//# sourceMappingURL=54186-38126d7d131c5060.js.map