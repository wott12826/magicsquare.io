"use strict";(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[9244],{209244:function(e,n,t){t.d(n,{K:function(){return Z}});t(473942);var i=t(132194),s=t(675104),a=t(706560),o=t(740095),r=t(637891),c=t(865762),d=t(443602),h=t(15096),g=t(391934),m=t(871558),l=t(665521),u=t(167237),w=t(415516),C=t(109466),p=t(292591),f=t(856489),I=t(779811),v=t(791631),N=t(246654),b=t(335692),y=t(203534),E=t(957290),P=t(959969),k=t(964072),T=t(340081),A=t(256440),q=(t(669270),t(19371)),_=t(839321),U=t(882309),W=t(747978);var D=t(971168),R=t(543585),L=t(171621),O=(t(71703),t(959540));function S(e,n,t){const i=e.isNewChainsStale??!0;let a,o,r,c,d,h,g;return(0,A.K)((e=>({id:"walletConnect",name:"WalletConnect",type:S.type,async setup(){const e=await this.getProvider().catch((()=>null));e&&(c||(c=this.onConnect.bind(this),e.on("connect",c)),h||(h=this.onSessionDelete.bind(this),e.on("session_delete",h)))},async connect({...e}={}){try{const n=await this.getProvider();if(!n)throw new R.M;d||(d=this.onDisplayUri,n.on("display_uri",d));const i=await this.isChainsStale();if(n.session&&i&&await n.disconnect(),!n.session||i){const i=D.sQ.createNamespaces(t);await n.connect({optionalNamespaces:i,..."pairingTopic"in e?{pairingTopic:e.pairingTopic}:{}}),this.setRequestedChainsIds(t.map((e=>Number(e.id))))}const s=(await n.enable()).map((e=>(0,_.K)(e))),a=await this.getChainId();return d&&(n.removeListener("display_uri",d),d=void 0),c&&(n.removeListener("connect",c),c=void 0),o||(o=this.onAccountsChanged.bind(this),n.on("accountsChanged",o)),r||(r=this.onChainChanged.bind(this),n.on("chainChanged",r)),g||(g=this.onDisconnect.bind(this),n.on("disconnect",g)),h||(h=this.onSessionDelete.bind(this),n.on("session_delete",h)),{accounts:s,chainId:a}}catch(e){if(/(user rejected|connection request reset)/i.test(e?.message))throw new q.ab(e);throw e}},async disconnect(){const e=await this.getProvider();try{await(e?.disconnect())}catch(e){if(!/No matching key/i.test(e.message))throw e}finally{r&&(e?.removeListener("chainChanged",r),r=void 0),g&&(e?.removeListener("disconnect",g),g=void 0),c||(c=this.onConnect.bind(this),e?.on("connect",c)),o&&(e?.removeListener("accountsChanged",o),o=void 0),h&&(e?.removeListener("session_delete",h),h=void 0),this.setRequestedChainsIds([])}},async getAccounts(){const e=await this.getProvider();if(!e?.session?.namespaces)return[];const n=e?.session?.namespaces[T.bq.CHAIN.EVM]?.accounts;return n?.map((e=>e.split(":")[2]))??[]},async getProvider({chainId:e}={}){a||(a=await n.getUniversalProvider(),a?.events.setMaxListeners(Number.POSITIVE_INFINITY));const t=s.MO.getActiveNamespace(),i=n.getCaipNetwork()?.id;if(e&&i!==e&&t){const e=s.MO.getStoredActiveCaipNetworkId(),i=n?.getCaipNetworks(t),a=i?.find((n=>n.id===e));a&&a.chainNamespace===T.bq.CHAIN.EVM&&await(this.switchChain?.({chainId:Number(a.id)}))}return a},async getChainId(){const e=n.getCaipNetwork()?.id;if(e)return e;const i=await this.getProvider(),s=i.session?.namespaces[T.bq.CHAIN.EVM]?.chains?.[0],a=t.find((e=>e.id===s));return a?.id},async isAuthorized(){try{const[e,n]=await Promise.all([this.getAccounts(),this.getProvider()]);if(!e.length)return!1;return!await this.isChainsStale()||!n.session||(await n.disconnect().catch((()=>{})),!1)}catch{return!1}},async switchChain({addEthereumChainParameter:n,chainId:i}){const s=await this.getProvider();if(!s)throw new R.M;const a=t.find((e=>e.id===i));if(!a)throw new q.x3(new L.X4);try{await s.request({method:"wallet_switchEthereumChain",params:[{chainId:(0,O.eC)(i)}]}),a?.caipNetworkId&&s.setDefaultChain(a?.caipNetworkId),e.emitter.emit("change",{chainId:Number(i)});const n=await this.getRequestedChainsIds();return this.setRequestedChainsIds([...n,i]),{...a,id:a.id}}catch(e){const t=e;if(/(?:user rejected)/iu.test(t.message))throw new q.ab(t);try{let e;e=n?.blockExplorerUrls?n.blockExplorerUrls:a.blockExplorers?.default.url?[a.blockExplorers?.default.url]:[];const t=a.rpcUrls?.chainDefault?.http||[],o={blockExplorerUrls:e,chainId:(0,O.eC)(i),chainName:a.name,iconUrls:n?.iconUrls,nativeCurrency:a.nativeCurrency,rpcUrls:t};await s.request({method:"wallet_addEthereumChain",params:[o]});const r=await this.getRequestedChainsIds();return this.setRequestedChainsIds([...r,i]),{...a,id:a.id}}catch(e){throw new q.ab(e)}}},onAccountsChanged(n){0===n.length?this.onDisconnect():e.emitter.emit("change",{accounts:n.map((e=>(0,_.K)(e)))})},onChainChanged(n){const t=Number(n);e.emitter.emit("change",{chainId:t})},onConnect(e){this.setRequestedChainsIds(t.map((e=>Number(e.id))))},async onDisconnect(n){this.setRequestedChainsIds([]),e.emitter.emit("disconnect");const t=await this.getProvider();o&&(t.removeListener("accountsChanged",o),o=void 0),r&&(t.removeListener("chainChanged",r),r=void 0),g&&(t.removeListener("disconnect",g),g=void 0),h&&(t.removeListener("session_delete",h),h=void 0),c||(c=this.onConnect.bind(this),t.on("connect",c))},onDisplayUri(n){e.emitter.emit("message",{type:"display_uri",data:n})},onSessionDelete(){this.onDisconnect()},getNamespaceChainsIds(){if(!a?.session?.namespaces)return[];const e=a?.session?.namespaces[T.bq.CHAIN.EVM]?.accounts;return e?.map((e=>Number.parseInt(e.split(":")[1]??"")))??[]},async getRequestedChainsIds(){const n=await(e.storage?.getItem(this.requestedChainsStorageKey))??[];return[...new Set(n)]},async isChainsStale(){if(!i)return!1;const n=e.chains.map((e=>e.id)),t=this.getNamespaceChainsIds();if(t.length&&!t.some((e=>n.includes(e))))return!1;const s=await this.getRequestedChainsIds();return!n.every((e=>s.includes(Number(e))))},async setRequestedChainsIds(n){await(e.storage?.setItem(this.requestedChainsStorageKey,n))},get requestedChainsStorageKey(){return`${this.id}.requestedChains`}})))}S.type="walletConnect";var j=t(949122),M=t(134129),x=t(695849),K=t(617339);var H=t(496146);const F=(0,t(777154).sj)({pendingTransactions:0}),V={state:F,subscribeKey(e,n){return(0,H.VW)(F,e,n)},increase(e){F[e]+=1},decrease(e){F[e]-=1},reset(e){F[e]=0}},G={enable:!1,pollingInterval:3e4};class Z extends i.q{constructor(e){super({projectId:e.projectId,networks:U.fZ.extendCaipNetworks(e.networks,{projectId:e.projectId,customNetworkImageUrls:{},customRpcChainIds:e.transports?Object.keys(e.transports).map(Number):[]})}),this.adapterType="wagmi",this.pendingTransactionsFilter={...G,...e.pendingTransactionsFilter??{}},this.namespace=T.bq.CHAIN.EVM,this.createConfig({...e,networks:U.fZ.extendCaipNetworks(e.networks,{projectId:e.projectId,customNetworkImageUrls:{},customRpcChainIds:e.transports?Object.keys(e.transports).map(Number):[]}),projectId:e.projectId}),this.setupWatchers()}async getAccounts(e){const n=this.getWagmiConnector(e.id);if(!n)return{accounts:[]};if(n.id===T.bq.CONNECTOR_ID.AUTH){const e=n.provider,{address:t,accounts:i}=await e.connect();return Promise.resolve({accounts:(i||[{address:t,type:"eoa"}]).map((e=>s.j1.createAccount("eip155",e.address,e.type)))})}const{addresses:t,address:i}=(0,a.D)(this.wagmiConfig);return Promise.resolve({accounts:(t||[i])?.map((e=>s.j1.createAccount("eip155",e||"","eoa")))})}getWagmiConnector(e){return this.wagmiConfig.connectors.find((n=>n.id===e))}createConfig(e){this.caipNetworks=e.networks,this.wagmiChains=this.caipNetworks.filter((e=>e.chainNamespace===T.bq.CHAIN.EVM));const n=this.wagmiChains.map((e=>[e.id,U.fZ.getViemTransport(e)]));Object.entries(e.transports??{}).forEach((([e,t])=>{const i=n.findIndex((([n])=>n===Number(e)));-1===i?n.push([Number(e),t]):n[i]=[Number(e),t]}));const t=Object.fromEntries(n),i=[...e.connectors??[]];this.wagmiConfig=(0,o._)({...e,chains:this.wagmiChains,transports:t,connectors:i})}setupWatchPendingTransactions(){if(!this.pendingTransactionsFilter.enable||this.unwatchPendingTransactions)return;this.unwatchPendingTransactions=(0,r.O)(this.wagmiConfig,{pollingInterval:this.pendingTransactionsFilter.pollingInterval,onError:()=>{},onTransactions:()=>{this.emit("pendingTransactions"),V.increase("pendingTransactions")}});const e=V.subscribeKey("pendingTransactions",(n=>{n>=T.bq.LIMITS.PENDING_TRANSACTIONS&&(this.unwatchPendingTransactions?.(),e())}))}setupWatchers(){(0,c.u)(this.wagmiConfig,{onChange:(e,n)=>{"disconnected"===e.status&&this.emit("disconnect"),"connected"===e.status&&(e.address!==n?.address&&(this.setupWatchPendingTransactions(),this.emit("accountChanged",{address:e.address})),e.chainId!==n?.chainId&&this.emit("switchNetwork",{address:e.address,chainId:e.chainId}))}}),(0,d.a)(this.wagmiConfig,{onChange:e=>{0===e.length&&this.emit("disconnect")}})}addWagmiConnectors(e,n){const t=[];!1!==e.enableCoinbase&&t.push((0,j.D)({version:"4",appName:e.metadata?.name??"Unknown",appLogoUrl:e.metadata?.icons[0]??"Unknown",preference:e.coinbasePreference??"all"})),!1!==e.enableWalletConnect&&t.push(S(e,n,this.caipNetworks)),!1!==e.enableInjected&&t.push((0,h.L)({shimDisconnect:!0}));const i=void 0===e.features?.email?s.bq.DEFAULT_FEATURES.email:e.features?.email,a=e.features?.socials?e.features?.socials?.length>0:s.bq.DEFAULT_FEATURES.socials;(i||a)&&t.push(function(e){let n=[];function t(e){return T.p1.parseEvmChainId(e)||1}return(0,A.K)((i=>({id:T.bq.CONNECTOR_ID.AUTH,name:"AppKit Auth",type:"AUTH",chain:T.bq.CHAIN.EVM,async connect(e={}){const i=await this.getProvider();let s=e.chainId;if(e.isReconnecting&&(s=i.getLastUsedChainId(),!s))throw new Error("ChainId not found in provider");const{address:a,chainId:o,accounts:r}=await i.connect({chainId:s});n=r?.map((e=>e.address))||[a],await i.getSmartAccountEnabledNetworks();const c=t(o);return{accounts:n,account:a,chainId:c,chain:{id:c,unsuported:!1}}},async disconnect(){const e=await this.getProvider();await e.disconnect()},getAccounts(){return n?.length?(i.emitter.emit("change",{accounts:n}),Promise.resolve(n)):Promise.resolve([])},async getProvider(){return this.provider||(this.provider=W.D.getInstance({projectId:e.options.projectId,enableLogger:e.options.enableAuthLogger,onTimeout:()=>{s.AlertController.open(U.jD.ALERT_ERRORS.SOCIALS_TIMEOUT,"error")}})),Promise.resolve(this.provider)},async getChainId(){const e=await this.getProvider(),{chainId:n}=await e.getChainId();return t(n)},async isAuthorized(){const e=await this.getProvider();return Promise.resolve(e.getLoginEmailUsed())},async switchChain({chainId:e}){try{const t=i.chains.find((n=>n.id===e));if(!t)throw new q.x3(new Error("chain not found on connector."));const s=await this.getProvider(),a=await s.connect({chainId:e});return n=a?.accounts?.map((e=>e.address))||[a.address],i.emitter.emit("change",{chainId:Number(e),accounts:n}),t}catch(e){if(e instanceof Error)throw new q.x3(e);throw e}},onAccountsChanged(e){0===e.length?this.onDisconnect():i.emitter.emit("change",{accounts:e.map(_.K)})},onChainChanged(e){const n=Number(e);i.emitter.emit("change",{chainId:n})},async onDisconnect(e){const n=await this.getProvider();await n.disconnect()}})))}({chains:this.wagmiChains,options:{projectId:e.projectId,enableAuthLogger:e.enableAuthLogger}})),t.forEach((e=>{const n=this.wagmiConfig._internal.connectors.setup(e);this.wagmiConfig._internal.connectors.setState((e=>[...e,n]))}))}async signMessage(e){try{return{signature:await(0,g.l)(this.wagmiConfig,{message:e.message,account:e.address})}}catch(e){throw new Error("WagmiAdapter:signMessage - Sign message failed")}}async sendTransaction(e){const{chainId:n}=(0,a.D)(this.wagmiConfig),t={account:e.address,to:e.to,value:e.value,gas:e.gas,gasPrice:e.gasPrice,data:e.data,chainId:n,type:"legacy"};await(0,m.Z)(this.wagmiConfig,t);const i=await(0,l.T)(this.wagmiConfig,t);return await(0,u.e)(this.wagmiConfig,{hash:i,timeout:25e3}),{hash:i}}async writeContract(e){const{caipNetwork:n,...t}=e,i=Number(T.p1.caipNetworkIdToNumber(n.caipNetworkId));return{hash:await(0,w.n)(this.wagmiConfig,{chain:this.wagmiChains?.[i],chainId:i,address:t.tokenAddress,account:t.fromAddress,abi:t.abi,functionName:t.method,args:t.args})}}async getEnsAddress(e){const{name:n,caipNetwork:t}=e;try{if(!this.wagmiConfig)throw new Error("networkControllerClient:getApprovedCaipNetworksData - wagmiConfig is undefined");let e=!1,i=!1;return(0,T.oL)(n)&&(i=await D.sQ.resolveReownName(n)||!1),1===t.id&&(e=await(0,C.O)(this.wagmiConfig,{name:(0,K.F)(n),chainId:t.id})),{address:e||i||!1}}catch{return{address:!1}}}async estimateGas(e){try{return{gas:await(0,p.Q)(this.wagmiConfig,{account:e.address,to:e.to,data:e.data,type:"legacy"})}}catch(e){throw new Error("WagmiAdapter:estimateGas - error estimating gas")}}parseUnits(e){return(0,M.v)(e.value,e.decimals)}formatUnits(e){return(0,x.b)(e.value,e.decimals)}addWagmiConnector(e,n){e.id!==T.bq.CONNECTOR_ID.AUTH&&e.id!==T.bq.CONNECTOR_ID.WALLET_CONNECT&&this.addConnector({id:e.id,explorerId:U.CK.ConnectorExplorerIds[e.id],imageUrl:n?.connectorImages?.[e.id]??e.icon,name:U.CK.ConnectorNamesMap[e.id]??e.name,imageId:U.CK.ConnectorImageIds[e.id],type:U.CK.ConnectorTypesMap[e.type]??"EXTERNAL",info:e.id===T.bq.CONNECTOR_ID.INJECTED?void 0:{rdns:e.id},chain:this.namespace,chains:[]})}syncConnectors(e,n){this.addWagmiConnectors(e,n),this.wagmiConfig.connectors.forEach((n=>this.addWagmiConnector(n,e))),(0,f.f)(this.wagmiConfig,{onChange:n=>n.forEach((n=>this.addWagmiConnector(n,e)))})}async syncConnection(e){const{id:n}=e,t=(0,I.E)(this.wagmiConfig).find((e=>e.connector.id===n)),i=this.getWagmiConnector(n),s=await(i?.getProvider());return{chainId:Number(t?.chainId),address:t?.accounts[0],provider:s,type:t?.connector.type,id:t?.connector.id}}async connectWalletConnect(e,n){const t=this.getWagmiConnector("walletConnect");if(!t)throw new Error("UniversalAdapter:connectWalletConnect - connector not found");const i=await t.getProvider();if(!this.caipNetworks||!i)throw new Error("UniversalAdapter:connectWalletConnect - caipNetworks or provider is undefined");i.on("display_uri",(n=>{e(n)})),await(0,v.$)(this.wagmiConfig,{connector:t,chainId:n?Number(n):void 0})}async connect(e){const{id:n,provider:t,type:i,info:s,chainId:a}=e,o=this.getWagmiConnector(n);if(!o)throw new Error("connectionControllerClient:connectExternal - connector is undefined");t&&s&&o.id===T.bq.CONNECTOR_ID.EIP6963&&o.setEip6963Wallet?.({provider:t,info:s});const r=await(0,v.$)(this.wagmiConfig,{connector:o,chainId:a?Number(a):void 0});return{address:r.accounts[0],chainId:r.chainId,provider:t,type:i,id:n}}async reconnect(e){const{id:n}=e,t=this.getWagmiConnector(n);if(!t)throw new Error("connectionControllerClient:connectExternal - connector is undefined");await(0,N.G)(this.wagmiConfig,{connectors:[t]})}async getBalance(e){const n=this.caipNetworks?.find((n=>n.id===e.chainId));if(n&&this.wagmiConfig){const t=Number(e.chainId),i=await(0,b.s)(this.wagmiConfig,{address:e.address,chainId:t,token:e.tokens?.[n.caipNetworkId]?.address});return{balance:i.formatted,symbol:i.symbol}}return{balance:"",symbol:""}}async getProfile(e){const n=e.chainId,t=await(0,y.w)(this.wagmiConfig,{address:e.address,chainId:n});if(t){return{profileName:t,profileImage:await(0,E.r)(this.wagmiConfig,{name:t,chainId:n})??void 0}}return{profileName:void 0,profileImage:void 0}}getWalletConnectProvider(){return this.getWagmiConnector("walletConnect")?.provider}async disconnect(){const e=(0,I.E)(this.wagmiConfig);await Promise.all(e.map((async e=>{const n=this.getWagmiConnector(e.connector.id);n&&await(0,P.z)(this.wagmiConfig,{connector:n})})))}async switchNetwork(e){await(0,k.c)(this.wagmiConfig,{chainId:e.caipNetwork.id})}async getCapabilities(e){if(!this.wagmiConfig)throw new Error("connectionControllerClient:getCapabilities - wagmiConfig is undefined");const n=(0,I.E)(this.wagmiConfig)[0],t=n?this.getWagmiConnector(n.connector.id):null;if(!t)throw new Error("connectionControllerClient:getCapabilities - connector is undefined");const i=await t.getProvider();if(!i)throw new Error("connectionControllerClient:getCapabilities - provider is undefined");const s=i.session?.sessionProperties?.capabilities;if(s){const n=function(e){try{return JSON.parse(e)}catch(e){throw new Error("Error parsing wallet capabilities")}}(s)[e];if(n)return n}return await i.request({method:"wallet_getCapabilities",params:[e]})}async grantPermissions(e){if(!this.wagmiConfig)throw new Error("connectionControllerClient:grantPermissions - wagmiConfig is undefined");const n=(0,I.E)(this.wagmiConfig)[0],t=n?this.getWagmiConnector(n.connector.id):null;if(!t)throw new Error("connectionControllerClient:grantPermissions - connector is undefined");const i=await t.getProvider();if(!i)throw new Error("connectionControllerClient:grantPermissions - provider is undefined");return i.request({method:"wallet_grantPermissions",params:e})}async revokePermissions(e){if(!this.wagmiConfig)throw new Error("connectionControllerClient:revokePermissions - wagmiConfig is undefined");const n=(0,I.E)(this.wagmiConfig)[0],t=n?this.getWagmiConnector(n.connector.id):null;if(!t)throw new Error("connectionControllerClient:revokePermissions - connector is undefined");const i=await t.getProvider();if(!i)throw new Error("connectionControllerClient:revokePermissions - provider is undefined");return i.request({method:"wallet_revokePermissions",params:e})}}}}]);
//# sourceMappingURL=9244-0cdfd33b4bd4ec12.js.map