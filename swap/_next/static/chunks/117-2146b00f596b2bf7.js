"use strict";(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[117],{50117:function(t,e,n){n.d(e,{HY:function(){return D},IC:function(){return W},QV:function(){return H},Xg:function(){return Z},YW:function(){return V},_R:function(){return z}});var r=n(48757),s=n(93476),a=n(693),i=n(22695);function o(t){const e=new Set;return t.forEach((t=>e.add(t))),Object.freeze(e)}const l=o("external public payable override".split(" ")),u="constant external internal payable private public pure view override",p=o(u.split(" ")),c="constructor error event fallback function receive struct",h=o(c.split(" ")),f="calldata memory storage payable indexed",y=o(f.split(" ")),m=o([c,f,"tuple returns",u].join(" ").split(" ")),g={"(":"OPEN_PAREN",")":"CLOSE_PAREN","[":"OPEN_BRACKET","]":"CLOSE_BRACKET",",":"COMMA","@":"AT"},b=new RegExp("^(\\s*)"),w=new RegExp("^([0-9]+)"),d=new RegExp("^([a-zA-Z$_][a-zA-Z0-9$_]*)"),k=new RegExp("^([a-zA-Z$_][a-zA-Z0-9$_]*)$"),E=new RegExp("^(address|bool|bytes([0-9]*)|string|u?int([0-9]*))$");class v{#t;#e;get offset(){return this.#t}get length(){return this.#e.length-this.#t}constructor(t){this.#t=0,this.#e=t.slice()}clone(){return new v(this.#e)}reset(){this.#t=0}#n(t=0,e=0){return new v(this.#e.slice(t,e).map((e=>Object.freeze(Object.assign({},e,{match:e.match-t,linkBack:e.linkBack-t,linkNext:e.linkNext-t})))))}popKeyword(t){const e=this.peek();if("KEYWORD"!==e.type||!t.has(e.text))throw new Error(`expected keyword ${e.text}`);return this.pop().text}popType(t){if(this.peek().type!==t){const e=this.peek();throw new Error(`expected ${t}; got ${e.type} ${JSON.stringify(e.text)}`)}return this.pop().text}popParen(){const t=this.peek();if("OPEN_PAREN"!==t.type)throw new Error("bad start");const e=this.#n(this.#t+1,t.match+1);return this.#t=t.match+1,e}popParams(){const t=this.peek();if("OPEN_PAREN"!==t.type)throw new Error("bad start");const e=[];for(;this.#t<t.match-1;){const t=this.peek().linkNext;e.push(this.#n(this.#t+1,t)),this.#t=t}return this.#t=t.match+1,e}peek(){if(this.#t>=this.#e.length)throw new Error("out-of-bounds");return this.#e[this.#t]}peekKeyword(t){const e=this.peekType("KEYWORD");return null!=e&&t.has(e)?e:null}peekType(t){if(0===this.length)return null;const e=this.peek();return e.type===t?e.text:null}pop(){const t=this.peek();return this.#t++,t}toString(){const t=[];for(let e=this.#t;e<this.#e.length;e++){const n=this.#e[e];t.push(`${n.type}:${n.text}`)}return`<TokenString ${t.join(" ")}>`}}function x(t){const e=[],n=e=>{const n=i<t.length?JSON.stringify(t[i]):"$EOI";throw new Error(`invalid token ${n} at ${i}: ${e}`)};let s=[],a=[],i=0;for(;i<t.length;){let o=t.substring(i),l=o.match(b);l&&(i+=l[1].length,o=t.substring(i));const u={depth:s.length,linkBack:-1,linkNext:-1,match:-1,type:"",text:"",offset:i,value:-1};e.push(u);let p=g[o[0]]||"";if(p){if(u.type=p,u.text=o[0],i++,"OPEN_PAREN"===p)s.push(e.length-1),a.push(e.length-1);else if("CLOSE_PAREN"==p)0===s.length&&n("no matching open bracket"),u.match=s.pop(),e[u.match].match=e.length-1,u.depth--,u.linkBack=a.pop(),e[u.linkBack].linkNext=e.length-1;else if("COMMA"===p)u.linkBack=a.pop(),e[u.linkBack].linkNext=e.length-1,a.push(e.length-1);else if("OPEN_BRACKET"===p)u.type="BRACKET";else if("CLOSE_BRACKET"===p){let t=e.pop().text;if(e.length>0&&"NUMBER"===e[e.length-1].type){const n=e.pop().text;t=n+t,e[e.length-1].value=(0,r.Dx)(n)}if(0===e.length||"BRACKET"!==e[e.length-1].type)throw new Error("missing opening bracket");e[e.length-1].text+=t}}else if(l=o.match(d),l){if(u.text=l[1],i+=u.text.length,m.has(u.text)){u.type="KEYWORD";continue}if(u.text.match(E)){u.type="TYPE";continue}u.type="ID"}else{if(l=o.match(w),!l)throw new Error(`unexpected token ${JSON.stringify(o[0])} at position ${i}`);u.text=l[1],u.type="NUMBER",i+=u.text.length}}return new v(e.map((t=>Object.freeze(t))))}function O(t,e){let n=[];for(const r in e.keys())t.has(r)&&n.push(r);if(n.length>1)throw new Error(`conflicting types: ${n.join(", ")}`)}function j(t,e){if(e.peekKeyword(h)){const n=e.pop().text;if(n!==t)throw new Error(`expected ${t}, got ${n}`)}return e.popType("ID")}function N(t,e){const n=new Set;for(;;){const r=t.peekType("KEYWORD");if(null==r||e&&!e.has(r))break;if(t.pop(),n.has(r))throw new Error(`duplicate keywords: ${JSON.stringify(r)}`);n.add(r)}return Object.freeze(n)}function T(t){let e=N(t,p);return O(e,o("constant payable nonpayable".split(" "))),O(e,o("pure view payable nonpayable".split(" "))),e.has("view")?"view":e.has("pure")?"pure":e.has("payable")?"payable":e.has("nonpayable")?"nonpayable":e.has("constant")?"view":"nonpayable"}function A(t,e){return t.popParams().map((t=>z.from(t,e)))}function S(t){if(t.peekType("AT")){if(t.pop(),t.peekType("NUMBER"))return(0,r.yT)(t.pop().text);throw new Error("invalid gas")}return null}function P(t){if(t.length)throw new Error(`unexpected tokens at offset ${t.offset}: ${t.toString()}`)}const $=new RegExp(/^(.*)\[([0-9]*)\]$/);function R(t){const e=t.match(E);if((0,s.en)(e,"invalid type","type",t),"uint"===t)return"uint256";if("int"===t)return"int256";if(e[2]){const n=parseInt(e[2]);(0,s.en)(0!==n&&n<=32,"invalid bytes length","type",t)}else if(e[3]){const n=parseInt(e[3]);(0,s.en)(0!==n&&n<=256&&n%8==0,"invalid numeric width","type",t)}return t}const _={},C=Symbol.for("_ethers_internal"),F="_ParamTypeInternal",J="_ErrorInternal",K="_EventInternal",M="_ConstructorInternal",I="_FallbackInternal",B="_FunctionInternal",L="_StructInternal";class z{name;type;baseType;indexed;components;arrayLength;arrayChildren;constructor(t,e,n,r,i,o,l,u){if((0,s.NK)(t,_,"ParamType"),Object.defineProperty(this,C,{value:F}),o&&(o=Object.freeze(o.slice())),"array"===r){if(null==l||null==u)throw new Error("")}else if(null!=l||null!=u)throw new Error("");if("tuple"===r){if(null==o)throw new Error("")}else if(null!=o)throw new Error("");(0,a.h)(this,{name:e,type:n,baseType:r,indexed:i,components:o,arrayLength:l,arrayChildren:u})}format(t){if(null==t&&(t="sighash"),"json"===t){const e=this.name||"";if(this.isArray()){const t=JSON.parse(this.arrayChildren.format("json"));return t.name=e,t.type+=`[${this.arrayLength<0?"":String(this.arrayLength)}]`,JSON.stringify(t)}const n={type:"tuple"===this.baseType?"tuple":this.type,name:e};return"boolean"==typeof this.indexed&&(n.indexed=this.indexed),this.isTuple()&&(n.components=this.components.map((e=>JSON.parse(e.format(t))))),JSON.stringify(n)}let e="";return this.isArray()?(e+=this.arrayChildren.format(t),e+=`[${this.arrayLength<0?"":String(this.arrayLength)}]`):this.isTuple()?e+="("+this.components.map((e=>e.format(t))).join("full"===t?", ":",")+")":e+=this.type,"sighash"!==t&&(!0===this.indexed&&(e+=" indexed"),"full"===t&&this.name&&(e+=" "+this.name)),e}isArray(){return"array"===this.baseType}isTuple(){return"tuple"===this.baseType}isIndexable(){return null!=this.indexed}walk(t,e){if(this.isArray()){if(!Array.isArray(t))throw new Error("invalid array value");if(-1!==this.arrayLength&&t.length!==this.arrayLength)throw new Error("array is wrong length");const n=this;return t.map((t=>n.arrayChildren.walk(t,e)))}if(this.isTuple()){if(!Array.isArray(t))throw new Error("invalid tuple value");if(t.length!==this.components.length)throw new Error("array is wrong length");const n=this;return t.map(((t,r)=>n.components[r].walk(t,e)))}return e(this.type,t)}#r(t,e,n,r){if(this.isArray()){if(!Array.isArray(e))throw new Error("invalid array value");if(-1!==this.arrayLength&&e.length!==this.arrayLength)throw new Error("array is wrong length");const s=this.arrayChildren,a=e.slice();return a.forEach(((e,r)=>{s.#r(t,e,n,(t=>{a[r]=t}))})),void r(a)}if(this.isTuple()){const s=this.components;let a;if(Array.isArray(e))a=e.slice();else{if(null==e||"object"!=typeof e)throw new Error("invalid tuple value");a=s.map((t=>{if(!t.name)throw new Error("cannot use object value with unnamed components");if(!(t.name in e))throw new Error(`missing value for component ${t.name}`);return e[t.name]}))}if(a.length!==this.components.length)throw new Error("array is wrong length");return a.forEach(((e,r)=>{s[r].#r(t,e,n,(t=>{a[r]=t}))})),void r(a)}const s=n(this.type,e);s.then?t.push(async function(){r(await s)}()):r(s)}async walkAsync(t,e){const n=[],r=[t];return this.#r(n,t,e,(t=>{r[0]=t})),n.length&&await Promise.all(n),r[0]}static from(t,e){if(z.isParamType(t))return t;if("string"==typeof t)try{return z.from(x(t),e)}catch(e){(0,s.en)(!1,"invalid param type","obj",t)}else if(t instanceof v){let n="",r="",s=null;N(t,o(["tuple"])).has("tuple")||t.peekType("OPEN_PAREN")?(r="tuple",s=t.popParams().map((t=>z.from(t))),n=`tuple(${s.map((t=>t.format())).join(",")})`):(n=R(t.popType("TYPE")),r=n);let a=null,i=null;for(;t.length&&t.peekType("BRACKET");){const e=t.pop();a=new z(_,"",n,r,null,s,i,a),i=e.value,n+=e.text,r="array",s=null}let l=null;if(N(t,y).has("indexed")){if(!e)throw new Error("");l=!0}const u=t.peekType("ID")?t.pop().text:"";if(t.length)throw new Error("leftover tokens");return new z(_,u,n,r,l,s,i,a)}const n=t.name;(0,s.en)(!n||"string"==typeof n&&n.match(k),"invalid name","obj.name",n);let r=t.indexed;null!=r&&((0,s.en)(e,"parameter cannot be indexed","obj.indexed",t.indexed),r=!!r);let a=t.type,i=a.match($);if(i){const e=parseInt(i[2]||"-1"),s=z.from({type:i[1],components:t.components});return new z(_,n||"",a,"array",r,null,e,s)}if("tuple"===a||a.startsWith("tuple(")||a.startsWith("(")){const e=null!=t.components?t.components.map((t=>z.from(t))):null;return new z(_,n||"",a,"tuple",r,e,null,null)}return a=R(t.type),new z(_,n||"",a,a,r,null,null,null)}static isParamType(t){return t&&t[C]===F}}class D{type;inputs;constructor(t,e,n){(0,s.NK)(t,_,"Fragment"),n=Object.freeze(n.slice()),(0,a.h)(this,{type:e,inputs:n})}static from(t){if("string"==typeof t){try{D.from(JSON.parse(t))}catch(t){}return D.from(x(t))}if(t instanceof v){switch(t.peekKeyword(h)){case"constructor":return Z.from(t);case"error":return W.from(t);case"event":return H.from(t);case"fallback":case"receive":return Q.from(t);case"function":return V.from(t);case"struct":return X.from(t)}}else if("object"==typeof t){switch(t.type){case"constructor":return Z.from(t);case"error":return W.from(t);case"event":return H.from(t);case"fallback":case"receive":return Q.from(t);case"function":return V.from(t);case"struct":return X.from(t)}(0,s.hu)(!1,`unsupported type: ${t.type}`,"UNSUPPORTED_OPERATION",{operation:"Fragment.from"})}(0,s.en)(!1,"unsupported frgament object","obj",t)}static isConstructor(t){return Z.isFragment(t)}static isError(t){return W.isFragment(t)}static isEvent(t){return H.isFragment(t)}static isFunction(t){return V.isFragment(t)}static isStruct(t){return X.isFragment(t)}}class Y extends D{name;constructor(t,e,n,r){super(t,e,r),(0,s.en)("string"==typeof n&&n.match(k),"invalid identifier","name",n),r=Object.freeze(r.slice()),(0,a.h)(this,{name:n})}}function U(t,e){return"("+e.map((e=>e.format(t))).join("full"===t?", ":",")+")"}class W extends Y{constructor(t,e,n){super(t,"error",e,n),Object.defineProperty(this,C,{value:J})}get selector(){return(0,i.id)(this.format("sighash")).substring(0,10)}format(t){if(null==t&&(t="sighash"),"json"===t)return JSON.stringify({type:"error",name:this.name,inputs:this.inputs.map((e=>JSON.parse(e.format(t))))});const e=[];return"sighash"!==t&&e.push("error"),e.push(this.name+U(t,this.inputs)),e.join(" ")}static from(t){if(W.isFragment(t))return t;if("string"==typeof t)return W.from(x(t));if(t instanceof v){const e=j("error",t),n=A(t);return P(t),new W(_,e,n)}return new W(_,t.name,t.inputs?t.inputs.map(z.from):[])}static isFragment(t){return t&&t[C]===J}}class H extends Y{anonymous;constructor(t,e,n,r){super(t,"event",e,n),Object.defineProperty(this,C,{value:K}),(0,a.h)(this,{anonymous:r})}get topicHash(){return(0,i.id)(this.format("sighash"))}format(t){if(null==t&&(t="sighash"),"json"===t)return JSON.stringify({type:"event",anonymous:this.anonymous,name:this.name,inputs:this.inputs.map((e=>JSON.parse(e.format(t))))});const e=[];return"sighash"!==t&&e.push("event"),e.push(this.name+U(t,this.inputs)),"sighash"!==t&&this.anonymous&&e.push("anonymous"),e.join(" ")}static getTopicHash(t,e){e=(e||[]).map((t=>z.from(t)));return new H(_,t,e,!1).topicHash}static from(t){if(H.isFragment(t))return t;if("string"==typeof t)try{return H.from(x(t))}catch(e){(0,s.en)(!1,"invalid event fragment","obj",t)}else if(t instanceof v){const e=j("event",t),n=A(t,!0),r=!!N(t,o(["anonymous"])).has("anonymous");return P(t),new H(_,e,n,r)}return new H(_,t.name,t.inputs?t.inputs.map((t=>z.from(t,!0))):[],!!t.anonymous)}static isFragment(t){return t&&t[C]===K}}class Z extends D{payable;gas;constructor(t,e,n,r,s){super(t,e,n),Object.defineProperty(this,C,{value:M}),(0,a.h)(this,{payable:r,gas:s})}format(t){if((0,s.hu)(null!=t&&"sighash"!==t,"cannot format a constructor for sighash","UNSUPPORTED_OPERATION",{operation:"format(sighash)"}),"json"===t)return JSON.stringify({type:"constructor",stateMutability:this.payable?"payable":"undefined",payable:this.payable,gas:null!=this.gas?this.gas:void 0,inputs:this.inputs.map((e=>JSON.parse(e.format(t))))});const e=[`constructor${U(t,this.inputs)}`];return this.payable&&e.push("payable"),null!=this.gas&&e.push(`@${this.gas.toString()}`),e.join(" ")}static from(t){if(Z.isFragment(t))return t;if("string"==typeof t)try{return Z.from(x(t))}catch(e){(0,s.en)(!1,"invalid constuctor fragment","obj",t)}else if(t instanceof v){N(t,o(["constructor"]));const e=A(t),n=!!N(t,l).has("payable"),r=S(t);return P(t),new Z(_,"constructor",e,n,r)}return new Z(_,"constructor",t.inputs?t.inputs.map(z.from):[],!!t.payable,null!=t.gas?t.gas:null)}static isFragment(t){return t&&t[C]===M}}class Q extends D{payable;constructor(t,e,n){super(t,"fallback",e),Object.defineProperty(this,C,{value:I}),(0,a.h)(this,{payable:n})}format(t){const e=0===this.inputs.length?"receive":"fallback";if("json"===t){const t=this.payable?"payable":"nonpayable";return JSON.stringify({type:e,stateMutability:t})}return`${e}()${this.payable?" payable":""}`}static from(t){if(Q.isFragment(t))return t;if("string"==typeof t)try{return Q.from(x(t))}catch(e){(0,s.en)(!1,"invalid fallback fragment","obj",t)}else if(t instanceof v){const e=t.toString(),n=t.peekKeyword(o(["fallback","receive"]));(0,s.en)(n,"type must be fallback or receive","obj",e);if("receive"===t.popKeyword(o(["fallback","receive"]))){const e=A(t);return(0,s.en)(0===e.length,"receive cannot have arguments","obj.inputs",e),N(t,o(["payable"])),P(t),new Q(_,[],!0)}let r=A(t);r.length?(0,s.en)(1===r.length&&"bytes"===r[0].type,"invalid fallback inputs","obj.inputs",r.map((t=>t.format("minimal"))).join(", ")):r=[z.from("bytes")];const a=T(t);if((0,s.en)("nonpayable"===a||"payable"===a,"fallback cannot be constants","obj.stateMutability",a),N(t,o(["returns"])).has("returns")){const e=A(t);(0,s.en)(1===e.length&&"bytes"===e[0].type,"invalid fallback outputs","obj.outputs",e.map((t=>t.format("minimal"))).join(", "))}return P(t),new Q(_,r,"payable"===a)}if("receive"===t.type)return new Q(_,[],!0);if("fallback"===t.type){const e=[z.from("bytes")],n="payable"===t.stateMutability;return new Q(_,e,n)}(0,s.en)(!1,"invalid fallback description","obj",t)}static isFragment(t){return t&&t[C]===I}}class V extends Y{constant;outputs;stateMutability;payable;gas;constructor(t,e,n,r,s,i){super(t,"function",e,r),Object.defineProperty(this,C,{value:B}),s=Object.freeze(s.slice());const o="view"===n||"pure"===n,l="payable"===n;(0,a.h)(this,{constant:o,gas:i,outputs:s,payable:l,stateMutability:n})}get selector(){return(0,i.id)(this.format("sighash")).substring(0,10)}format(t){if(null==t&&(t="sighash"),"json"===t)return JSON.stringify({type:"function",name:this.name,constant:this.constant,stateMutability:"nonpayable"!==this.stateMutability?this.stateMutability:void 0,payable:this.payable,gas:null!=this.gas?this.gas:void 0,inputs:this.inputs.map((e=>JSON.parse(e.format(t)))),outputs:this.outputs.map((e=>JSON.parse(e.format(t))))});const e=[];return"sighash"!==t&&e.push("function"),e.push(this.name+U(t,this.inputs)),"sighash"!==t&&("nonpayable"!==this.stateMutability&&e.push(this.stateMutability),this.outputs&&this.outputs.length&&(e.push("returns"),e.push(U(t,this.outputs))),null!=this.gas&&e.push(`@${this.gas.toString()}`)),e.join(" ")}static getSelector(t,e){e=(e||[]).map((t=>z.from(t)));return new V(_,t,"view",e,[],null).selector}static from(t){if(V.isFragment(t))return t;if("string"==typeof t)try{return V.from(x(t))}catch(e){(0,s.en)(!1,"invalid function fragment","obj",t)}else if(t instanceof v){const e=j("function",t),n=A(t),r=T(t);let s=[];N(t,o(["returns"])).has("returns")&&(s=A(t));const a=S(t);return P(t),new V(_,e,r,n,s,a)}let e=t.stateMutability;return null==e&&(e="payable","boolean"==typeof t.constant?(e="view",t.constant||(e="payable","boolean"!=typeof t.payable||t.payable||(e="nonpayable"))):"boolean"!=typeof t.payable||t.payable||(e="nonpayable")),new V(_,t.name,e,t.inputs?t.inputs.map(z.from):[],t.outputs?t.outputs.map(z.from):[],null!=t.gas?t.gas:null)}static isFragment(t){return t&&t[C]===B}}class X extends Y{constructor(t,e,n){super(t,"struct",e,n),Object.defineProperty(this,C,{value:L})}format(){throw new Error("@TODO")}static from(t){if("string"==typeof t)try{return X.from(x(t))}catch(e){(0,s.en)(!1,"invalid struct fragment","obj",t)}else if(t instanceof v){const e=j("struct",t),n=A(t);return P(t),new X(_,e,n)}return new X(_,t.name,t.inputs?t.inputs.map(z.from):[])}static isFragment(t){return t&&t[C]===L}}}}]);
//# sourceMappingURL=117-2146b00f596b2bf7.js.map